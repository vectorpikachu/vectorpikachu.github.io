[
  {
    "objectID": "PDF/OOP/期末复习.html",
    "href": "PDF/OOP/期末复习.html",
    "title": "面向对象技术引论期末复习",
    "section": "",
    "text": "对象：客观存在的事物\\(\\rightarrow\\)​对象，对象作为基本构成单位。\n属性与操作：属性表示性质，操作表示行为。\n对象的封装：对象的属性与操作结合为一体，成为一个独立的、不可分的实体，对外屏蔽其内部细节。公开静态的、不变的操作，而把动态的、易变的操作隐藏起来。\n\n分类：相同属性和相同操作分为一类。\n聚合：复杂的对象可以用简单的对象作为其构成部分。\n\n继承：特殊类继承一般类。\n消息：对象之间通过消息进行通讯，以实现对象之间的动态联系。\n\n关联：表示对象之间的静态关系。\n\n\n\n\n从程序设计方法的角度看，面向对象是一种程序设计范型(paradigm)。使用对象、类、继承、封装、聚合、关联、消息、多态性等基本概念来进行程序设计。\n从软件方法学的角度看，面向对象方法是一种运用对象、类、继承、封装、聚合、关联、消息、多态性等概念来构造系统的软件开发方法。\n程序=&lt;对象, 关系&gt; 对象=算法+数据结构\n\n\n\n\n需求工作：起始活动（可行性分析）\\(\\rightarrow\\) 需求获取活动（得到软件需求陈述，通过自然语言、用况图、用户故事等）\\(\\rightarrow\\) 需求分析活动（一个精确的需求模型）\\(\\rightarrow\\) 需求规约活动（软件需求规约，采用标准的模板） \\(\\rightarrow\\) 需求验证活动 \\(\\rightarrow\\) 需求管理活动\n\n\n一个需求是一个陈述，描述了待开发产品／系统（或项）功能上的能力、性能参数或者其它性质。\n\n\n\nIEEE标准830-1998要求单一需求必须具有5个基本性质:\n\n必要的(Necessary)。缺少了这个需求是不是还可以？\n无歧义的(Unambiguous)。只能用一种方式解释吗？\n\n可测试的(Testable)。可以对它进行测试吗？\n可跟踪的(Traceable)。可以从一个开发阶段到另一个阶段对它进行跟踪吗？不可能开发过程中需求就消失了。\n可测量的(Measurable)。可以对它进行测量吗？应该有一个方法可以衡量需求是否被满足了。\n\n注:确定一个需求是否满足以上五个性质是复杂耗时的过程。\n\n\n\n功能；性能；外部接口；设计约束；质量属性\n功能的需求是最重要的，所有别的需求都必须依附在功能这个需求之上。\n\n\n功能需求规约了系统或系统构件必须执行的功能。\n\n对该功能输入的假定，或者为了验证该功能输入，有关检测的假定。（类似于OI竞赛中给定的\\(n\\leq 100\\)这样）\n功能内的任一次序，这一次序是与外部有关的。（应该先干啥）\n对异常条件的响应，包括所有内外部所产生的错误。\n需求的时序或优先程度。\n功能之间的互斥规则。\n系统内部状态的假定。\n为了该功能的执行，所需要的输入和输出次序。\n用于转换或内部计算所需要的公式。\n\n\n\n\n系统或系统构件必须具有的性能特性。\n注：性能需求隐含了一些满足功能需求的设计方案，经常对设计产生一些关键的影响。例如：排序，关于花费时间的规约将确定哪种算法是可行的。\n\n\n\n应当为外部提供什么样的接口，应当使用哪些外部接口，进而必须可以处理这样的格式的数据。\n\n系统接口：与系统的其他应用进行交互。\n用户接口：规约对给用户所显示的数据，对用户所要求的数据以及用户如何控制该用户接口。\n硬件接口\n软件接口：和其他软件产品交互。比如和数据库管理系统交互，和操作系统交互。（问：和操作系统交互的接口到底是软件接口还是系统接口？）\n通讯接口：比如必须使用的网络类型。\n内存约束：描述易失性存储和永久性存储的特性和限制，特别应描述它们是否被用于与一个系统中其它处理的通讯。（问：为什么内存约束要被使用在外部接口需求这里？）\n操作：规约用户如何使系统进入正常和异常的运行以及在系统正常和异常运行下如何与系统进行交互。应该描述在用户组织中的操作模式，包括交互模式和非交互模式；描述每一模式的数据处理支持功能；描述有关系统备份、恢复和升级功能方面的需求。（问：没有理解）\n地点需求：如何安装以及调整一个地点，来适应新的系统。\n\n\n\n\n设计约束限制了系统或系统构件的设计方案。就约束的本身而言，对其进行权衡或调整是相当困难的，甚至是不可能的。它们必须予以满足。\n任取10秒，一个特定应用所消耗的可用计算能力平均不超过50%。（问：为什么不属于性能需求？）\n系统必须用C++或其他面向对象语言编写。系统用户接口需要菜单。（问：这里为什么不属于外部接口需求？）\n必须在对话窗口的中间显示错误警告，其中使用红色的、14点加粗Arial字体。（问：这里为什么不属于功能需求？）\n\n法规限制\n硬件限制\n与其他应用的接口\n并发操作\n审计功能\n控制功能\n高级语言需求\n握手协议\n应用的关键程序\n安全考虑\n\n\n\n\n可靠性、可维护性、易用性（用户友好性）、安全性、可移植性、规模、速度\n\n\n\n\n\n\n需求人员把自己作为系统的最终用户，审视该系统并提出问题：“如果是我使用这一系统，则我需要…”\n\n\n\n在交谈期间需求可能不断增长，或是以前没有认识到的合理需求的一种表现，说是“完美蠕行”(Creeping elegance)病症的体现，以至于很难予以控制，可能导致超出项目成本和进度的限制。\n解决方法：项目管理人员和客户管理人员应该定期地对交谈过程的结果进行复审。\n\n\n\n尽管了解的这些信息可以通过交谈获取，但 “第一手材料”一般总是能够比较好地“符合现实”。\n客户可能抵触这一观察。\n客户还可能认为开发者在签约之前，就已经熟悉了他们的业务。（问：这句话想表达什么？）\n\n\n\n举行客户和开发人员的联席会议，与客户组织的一些代表共同开发需求。\n\n\n\n复审技术文档。\n提炼方法是针对已经有了部分需求文档的情况。依据产品的本来情况，可能有很多文档需要复审，以确定其中是否包含相关联的信息。在有的情况，也可能只有少数文档需要复审。\n\n\n\n\n\n\n把系统看作一个黑箱，看它对外部的客观世界发挥什么作用，描述它外部可见的行为。\n\n我们可以有很多参与者在这里面。\n优势：易于探讨和理解、易于对需求规范化、有利于进行OOA、有助于发现主动对象、对系统测试来说，产生测试用例、有助于人机界面设计、etc\n系统边界、操作者、用况、关联、包含、扩展、泛化\n\n\n某些事物可能既有一个对象作为其抽象描述，而本身（作为现实世界中的事物）又是在系统边界以外与系统进行交互的操作者。如超市中的收款员，他本身是现实中的人，作为操作者；在系统边界内，又有一个相应的“收款员”对象来模拟其行为或管理其信息，作为系统成分。\n某些事物即使属于问题域，也与系统责任没有什么关系。如超市中的保安员，在现实中与超市有关系，但与所开发的系统超市商品管理系统无关系。这样的事物既不位于系统边界内，也不作为系统的操作者。\n\n\n\n尽管在模型中使用操作者，但操作者实际上并不是系统的一部分。它们存在于系统之外。\n\n我们可能的操作者。\n\n\n\n从使用视角看：用况是对操作者使用系统的一项功能时所进行的交互过程的描述。\n\n\n\n用况和操作者之间的唯一的关系，但是用况之间还有别的其他的关系。\n\n\n\n从基用况到扩展用况的扩展关系表明：按基用况中指定的扩展条件，把扩展用况的行为插入到由基用况中的扩展点定义的位置。\n\n扩展的适用条件：(1) 异常情况；(2) 正常的变形描述时，而且希望采用更多的控制方式时，采用扩展。即在一个变化点上一个附加多个变体的场合下使用；(3) 用扩展关系来区分可实现系统的可配置部分（问：什么意思？）。\n\n\n\n从基用况到供应者用况的包含关系表明：基用况在它内部说明的某一（些）位置上显式地使用供应者用况的行为的结果。\n（问：包含和扩展有什么区别呢？我的理解是一个是显式地使用包含用况，一个是隐式地使用扩展用况？）\n\n\n\n\n\n\n\n\n\n识别操作者、捕获用况（从操作者的角度来看、从系统功能的角度来看、从场景技术的角度来看）、系统的需求建模、审查\n\n\n\n\n用户+事件。其中用户表现为对主要用户的描述，事件则是场景或系统/任务价值\n用户故事相当于用况图正文的描述说明。UML实际推崇的是用况图，但在敏捷开发中使用面向对象方法时也会将用户故事作为系统的需求描述\n\n\n\n\n\n\nUML是系统分析和设计的工具\n\n\n\n\n参与者、信号、实用程序都是类。\n\n为什么对象没有操作栏？这是因为它的操作已经在它的类里面被定义了，而属性栏之所以存在是因为我们在构造这个对象的时候，必须为它填入初始的属性。\n抽象类使用斜体字。\n类可以有所在的包名。\n\n属性的默认语法：[可见性]属性名[:类型][多重性][=初始值][{特性串}]，比如+name: String[0..1] = \"Hello\"{readonly}。\n\n可见性：为什么引入可见性？为了支持信息隐蔽这一软件设计原则。信息隐蔽是指在每个模块中所包含的信息（包括表达信息的数据以及表达信息处理的过程）不允许其它不需要这些信息的模块访问。信息隐蔽是实现模块低耦合的一种有效途径。\n属性名：小写字母开头\n类型名\n多重性：省略的时候默认为[1..1]\n初始值\n性质串：a : integer = 10 {frozen}，这就表示属性是不可改变的\n\n所有的共同的属性，加上下划线，defaultSize这样子的。\n\n\n\n可见性\n符号表示\n关键字表示\n描述\n\n\n\n\n公有的\n+\npublic\n所有其他的类/类目都可以使用\n\n\n受保护的\n#\nprotected\n仅其子类/类目才能使用\n\n\n私有的\n-\nprivate\n仅本类的操作才能使用\n\n\n包内的\n~\npackage\n仅同一包中声名的类/类目才能使用\n\n\n\n操作的默认语法：[可见性] 操作名 [(参数表)] [: 返回类型] [{性质串}]，例：+ set(id : Integer, name : String) : Boolean {...}。\n参数表里的每个参数还可以如下：[方向] 参数名 : 类型 [= 默认值]，比如in name: String = \"Hello\"。\nin输入参数，inout输入参数可修改，out输出参数。\n衍型：类型的类型，用双尖括号包裹起来。&lt;&lt;datatype&gt;&gt;。\n\n\n\n\n\n\n\n\n\n\n协作是一个交互，涉及交互三要素：交互各方、交互方式以及交互内容 。\n使机器人沿着一条路径移动所涉及的类 \\(\\rightarrow\\) 一个协作\n\n\n\n一个用况描述了系统的一个完整的功能需求。\n用况是通过协作予以细化的。\n\n\n\n进程和线程都是主动类。\n主动类对象的行为通常与其他元素的行为是并发的。\n至少具有一个进程或线程的类，能够启动系统的控制活动。\n\n\n\n在遵循并提供了一组外部接口的实现的同时，隐藏内部实现。构件是描述比特世界的软件制品的系统单位。\n应用、文档、库、页和表都是构件。\n\n\n\n\n系统中包含物理信息的、可替代的物理部件。\n这里说部件是“物理的”，指软件未运行时也存在的部分，主要指文件，如源代码、可执行程序、脚本等；软件系统中可能会存在不同类型的部署制品；制品通常代表对源代码/运行时信息的物理打包。\n\n\n\n\n在运行时存在的物理元素，通常它表示一种具有记忆能力和处理能力的计算机资源（比如服务器、数据库管理系统等）\n这里的“物理的”指实际机器设备；一个构件可以驻留在一个节点中，也可以从一个节点移到另一个节点。\n\n\n\n\n\n\n\n它指明一个类的对象与另一个类的对象间的联系。如果类的对象之间通过属性有连接关系，那么这些类之间的语义关系就是关联。链是关联的实例，是对象间的语义连接，是对象引用的元组（列表）。 在最常见的情况下，它是一对对象引用。\n关联表示对象之间的静态联系。\n\n这里的多重性是一个教师可以指导0到多个学生的论文，而一个学生只能被一个教师指导论文。\n\n还可以用关联导航来解决。\n\n角色和关联端名：\n\n限定符：\n\n\n\n一种特殊形式的关联，表达一种“整体 /部分”关系。即一个类表示了一个大的事物，它是由一些小的事物（部分）组成的。\n\n\n\n\n组合是一种特殊的聚合。组合中的对象具有相同的生命周期。\n组合的末端的多重性不能超过1。因为一个对象最多组合成另一个对象。\n在一个组合中，由一个链所连接的对象而构成的任何元组，必须都属 于同一个整体类的对象（问：没有理解这句话）\n\n\n\n\n\n关联类：具有关联和类特性的模型元素，可以被看作是关联，但还有类 的特性；或被看作是一个类，但有关联的特性。\n\n比如我们能认为大学和教师之间的关联是通过任务来获得的。\n\n\n\n“is-a-kind-of” 继承关系又称为一 般一特殊关系，在UML中把继承关系称为泛化关系。\n\n\n\n\n在两个地方会使用实现的关系：接口与实现它们的类和构件之间；用况与实现它们的协作之间。\n\n\n\n\n依赖是一种使用关系，用于描述一个类目使用另一类目的信息和服务。\n\n\n\n\n\n\n使用“关联”，模型化系统中存在的大量静态结构和动态结构。\n\n以数据驱动：一个对象需要导航到另外一个对象\n以行为驱动：一个对象需要与另一个对象交互\n\n\n\n使用“泛化”，对系统中存在的一般/特殊关系规约。\n\n\n\n使用“实现”，对系统中存在的精化关系规约\n该术语用于表达不同抽象层之间的精化，体现“自顶向下，逐步求精” 的思想。如系统需求层的用况，可通过协作实现。这两者即可用 “实现”规约。\n\n\n\n使用“依赖”，对不是结构、继承、精化的关系规约。\n某类只作为另一类的操作参数，则可将它们之间的关系抽象为依赖\n\n\n\n\n\n\n\n\n可以在小矩形里写包名，大矩形中表示内容。\n也可以这样画：\n\n引入依赖和访问依赖。\n\n这样表示Controller可以访问Components和Subcomponents。\n\n\n\n注解可以是简单文字，也可以内嵌URL或文档链接，用虚线连接到所解释说明的模型元素上。\n\n\n\n\n\n\n\n类图显示了类（及其接口）、类的内部结构以及与其他类的联系。是面向对象分析与设计所得到的最重要的模型。\n\n\n\n用对象图说明在类图中所发现的事物的实例的数据结构和静态快照。\n\n\n\n就是用来表示构件之间的关系的图。\n\n\n\n\n\n\n\n\n\n\n外扩图是在UML2.5的基础上定义新建模元素的图，用以增加新的建模能力\n\n\n\n\n所以这个图可以和构件图结合在一起。\n\n\n\n\n\n\n通常都是对反应型对象（reactive object）的行为进行建模。\n\n状态机图是描述一个对象或其他实体在其生命周期中所经历的各种状态以及状态变迁的图.\n一个状态机图，规约了一个对象在其生存期内因响应事件所经历的状态序列以及对这些事件所作出的响应。\n状态之间的转化是即时的。\n延迟事件：延迟事件是指在当前状态下暂不处理，但将推迟到该对象的另一个状态下排队处理的事件。比如我现在想要识别出某一个事件，但是我现在不处理。activity/defer\n事件：事件就是状态转移的实心线上面标记的东西。activity(parameter1: Type1, ...)。\n\n信号（Signal）事件：信号是一种Type，所以它的原类型是signal。这里是衍型。\n调用（Call）事件：一个调用事件表示对象接收到一个操作调用的请求。\n时间事件：时间事件后跟有计算时间量的表达式。after (2 seconds)。\n变化事件：指定条件变为真了，譬如at (xxx)/selfTest(), when (altitude &lt; 1000)。\n\nactivityName[(Parameter list)][Guard][/Action]。比如：right-mouse-down(location)[location in window]/object:=pick_object(location)。\nUML内置关键字：\n\nentry：进入状态时首先执行该动作。它不能有参数或监护条件。\nexit：在退出状态时最后执行该动作。它不能有参数或监护条件。\ndo：在状态的进入动作表达式（如果有）执行后，开始执行do活动，并且do活动可与其他的动作或者活动并行。\n\n状态间的转移 vs. 状态内的转移 ： 如果源状态和目标状态都是自身，那么会先触发该状态的退出动作，再执行该状态的进入动作，和状态内的转移有区别。\n\n\n\n顺序子状态机（非正交）和并发子状态机（正交）\n非正交状态机：最多有一个子初态和一个子终态。\n\n转移到该组合状态：这个被嵌套的子状态机一定有一个初态，以便在进入该组合状态并执行其进入动作后，将控制传送给这一初态。\n转移到该组合状态的一个子状态：在执行完该组合状态的进入动作（如有的话）和该子状态的进入动作后，将控制传送给这一子状态。\n\n\n离开的时候：首先离开被嵌套的状态，即执行被嵌套状态的退出动作（如有的话）；然后离开该组合状态，即执行该组合状态的退出动作（如有的话）。\n正交状态机：控制流分岔，分成了并发流。\n\n\n\n\n动作是原子的和即时的。\n对象是方的矩形，而动作是圆角的矩形。\n\n\n\n\n一种详细表示 对象之间以及对象与参与者实例之间交互的图，它由一组协作的对象（或参与者实例）以及它们之间可发送的消息组成，它强调消息之间的顺序。\n对象：[ObjectName]: ClassName。\n参与者：一个小人\n对象生命线：一个垂直虚线，用X表示被析构。\n执行规约：窄长的矩形。\n消息：同步消息：实心的箭头，返回虚线箭头 异步消息：实现，空心的箭头\n\n消息分支：把分支画成从一个点出发的多个箭头，每个箭头由监护条件标示\n消息循环：*Message[Guard]，表示按照给定的表达式一直发送信息。\n回调机制：申请对象在服务对象处事先登记所关心的事件，然后继续从事自己的工作；当服务对象监控到这样的事件发生时，再通知申请对象，由申请对象进行处理。这是一个异步的。\n\n\n选择（opt,为真才执行）、条件（alt,有两种选择）、并发（par,同时做）、迭代（loop guard,循环）\n\n\n\n\n\n为表示一个消息的时间顺序，给消息加一个数字前缀（从1号消息开始），在控制流中，每个新的消息的顺序号单调增加（如2，3等等）。为了显示嵌套，可使用带小数点的号码（1表示第一个消息；1.1表示嵌套在消息1中的第一个消息；1.2表示嵌套在消息1中的第二个消息；等等）。\n通信图和顺序图两者语义上是等价的。\n\n\n\n\n用于描述系统的宏观行为，是活动图和顺序图的混合物。\n\n\n\n用于表示交互，它展现了消息跨越不同对象或角色的实际时间，而不仅仅关心消息的相对顺序。\n\n\n\n\n\n运用面向对象方法，对问题域（被开发系统的应用领域）和系统责任（所开发系统应具备的职能）进行分析和理解 。\n\n\n\n\n\n\n\n\n发现对象，定义他们的类。\n识别对象的内部特征：定义属性、定义操作。\n识别对象的外部关系：分类关系（继承）、构成关系、静态联系、使用关系\n给出系统的相关顺序图、状态图和活动图等，以建立系统的动态模型\n划分包，建立系统的包图\n建立系统的详细说明\n\n\n\n\na） 信息组织的复杂性：\n抽象:从许多事物中舍弃个别的、非本质的特征，抽取共同的、本质性 的特征：系统中的对象是对现实世界中事物的抽象； 类是对象的抽象；一般类是对特殊类的抽象； 属性是事物静态特征的抽象； 操作是事物动态特征的抽象。\n分类机制:把具有相同属性和操作的对象划分为一类，用类作为这些对象 的抽象描述。\n继承:特殊类的对象拥有其一般类的全部属性和服务（一般-特殊结构）；\n聚合:把一个复杂的事物看成若干比较简单的事物的组装体，从而简化对 复杂事物的描述。（整体-部分结构）\n消息通讯：要求对象之间只能通过消息进行通讯，而不允许在对象之外 直接地存取对象内部的属性。\n多个视图：从多个角度认识系统\nb） 文档组织的复杂性—控制机制\n包：使模型具有大小不同的粒度层次，以利于控制复杂性\n\n\n\n\n瀑布模型和喷泉模型\n\n\n\n\n\n\n\n不强调次序，逐个设计每个部分。\n\n\n它是在OOA模型基础上按实现条件进行必要的修改、调整和细节补充而得到的。\n实现条件：\n\n编程语言：对问题域的影响最大。选定的编程语言不支持某些面向对象的概念与原则；OOA阶段可能将某些与编程语言有关的对象细节推迟到OOD阶段来定义。如对象的创建、删除、复制、转存、初始化等系统行为、属性的数据类型等。\n\n为复用设计与编程的类而增加新的结构\n增加一般类以建立共同协议（比如：提供创建、删除、复制等操作，Java里面的object就可以体现这个问题，它是所有的类的父类，所有的类都要继承它）object{复用}\n按编程语言调整继承和多态：如果编程语言不支持多继承怎么办？（方法1：采用聚合，把多继承转换为单继承，方法2：重新定义对象类，方法3：压平）如果编程语言不支持继承怎么办？（方法1：把继承结构展平，所有需要的信息都放到展平后的类里面去；方法2：再加上聚合，每个类不存在信息冗余）如果编程语言不支持多态怎么办？重新命名函数。\n提高性能：调整对象分布，合并通讯频繁的类\n为实现对象永久存储做的修改\n为编程方便增加底层成分\n对复杂关联的转化并决定关联的实现方式：多对多关联转化为一对一关联\n调整与完善属性\n构造和优化算法\n决定对象间的可访问性\n定义对象实例：当系统需要通过从外存读取数据来创建一个对象时 ，先创建该对象，再从外存中读取这个对象数据，把数据赋值给对象的相应属性。\n\n硬件、操作系统及网络设施\n\n复用支持\n数据管理系统\n界面支持系统\n\n\n（道理：尽管继承和聚合反映了现实世界中两种不同的关系，但是从最终效果来看却存在共性－都是使一个类的对象能够拥有另一个（一些）类的属性和操作。）\n\n（重新审视原来用多继承结构表达的实际事物及它们之间的关系。例如，上述例子换一个角度看问题：形成这种分类的原因使什么？从而增加“身份”类，构成单继承。）\n\n（缺点：损失了信息）\n为什么要这么做：使反映问题域本质的总体框架和组织结构长期稳定，而细节可变；稳定部分与可变部分分开，使系统从容地适应变化；有利于同一个分析用于不同的设计与实现；支持系统族和相似系统的分析设计及编程结果复用；使一个成功的系统具有超出其生存期的可扩展性\n\n\n\nOOD要设计人机交互的细节，而OOA用人机交互来反映需求\n\n分析与系统交互的人：设计时重点考虑比例最大的人员情况，并适当地兼顾其他人。\n从use case分析人机交互\n\n人机交互界面的设计准则：使用简便、一致性、启发性、减少人脑记忆的负担、减少重复的输入、容错性、及时反馈、防止灾难性的错误\n\n\n\n控制流驱动部分，用于定义和表示并发系统中的每个控制流。用主动对象表示每个控制流(进程、线程) ，所有的主动类构成控制驱动部分\n如何设计控制驱动部分：用包括主动类的类图捕捉控制流的静态结构；用包括主动对象的顺序图或通信图捕捉控制流的动态行为。\n\n\n\n数据管理部分是负责在特定的数据管理系统中存储和检索持久对象的组成部分\n其目的是，存储问题域的持久对象、封装这些对象的查找和存储机制，以及为了隔离数据管理方案的影响\n文件系统、R-DBMS（关系数据库系统）、OO-DBMS（面向对象数据库系统）\n\n\n\n面向对象\n实体-联系\n关系数据库\n\n\n\n\n类\n实体类型\n表\n\n\n对象\n实体实例\n行\n\n\n属性\n属性\n列\n\n\n关系\n关系\n表\n\n\n\n\n这个关联的表是右下角，应该是一种 link1 : {EmployeeNumber , Location}这样的一行。\n如果是1对多，可以为比如公司职员记录公司ID这个属性。或者是公司ID和职员ID建立一个关联表。\n如果是多对多呢：\n\n还有对父类和子类的关系的存储可以有下面的三种情况：\n\n（下推）：为每一个子类定义一张单独的表。当增加新的父类或者子类的时候对数据库的维护和修改是很大的麻烦。\n（上拉）去掉继承的网络结构。对实例要存储大量的冗余。\n（分割表）将父类和子类的状态存储在不同的表中。这种方法很好地反映了继承网格，但它的缺点是访问数据时需要许多跨表连接。\n\n对象存储器。\n\n\n\n构件具有端口和接口。\n接口是一个圆圆的或者半圆的，端口是一个方形的那个。\n\n\n\n\n\n\n\n\n\n\n语言元素可以支持\n\n类的定义\n对象的静态声明或者动态创建\n属性和操作的定义\n继承、聚合、关联和消息的表示\n\n语言机制有：\n\n类机制\n封装机制\n继承机制\n\n高级特性：多态、多继承的表示和支持机制\n\n\n\n纯面向对象语言：Smalltalk、Eiffel、Java\n较为全面的支持OO，强调严格的封装\n混合型：C++、Objective-C、Objective-Pascal、Python\n在一种非OO语言的基础上扩充OO成分、对封装采取灵活的态度\n\n问：为什么说对象指针实现了关联?\n\n\n\n\n\n\n\n\n在高层定义接口，隐藏复杂性。可以理解为UI界面。\n或者类似于一个APP的页面。\n\n隐藏复杂性\n可以用来包装遗产系统\n用来检测某项的访问量\n\n\n\n\n将抽象部分与它的实现部分分离，使它们都可以独立地变化\n识别出一个类所具有的两个独立变化的维度，将它们设计为两个继承等级结构，并建立抽象和实现的聚合关系\n\n\n\n\n一个类只有一个实例，并提供全局的访问点。\n全局变量无法阻止多次的实例化，而单例把实例化的方法私有了，这样就只能在一开始创建的时候实例化一次了。\n先判断单例是否已经实例化，没有实例化的话再对实例化函数加锁。\n\n\n\n类似于一个存档。\n\n\n\n\n优势：低耦合！策略可以自由切换，系统扩展性、灵活性更高\n\n\n\n\n\n让所有的实例化都通过工厂来完成。\n可以减少构造对象的时候的复杂性。\n\n\n\n用来创建对象族的。\n\n\n\n\n\n代理还可以再加入一点自己的操作。\n\n\n\n提供访问数据结构的方法\n\n\n\n访问复杂的数据结构\n\n\n\n\n\n\n\n将一个请求封装成一个对象，使得发出请求的责任和执行请求的责任分开。\n\n命令模式降低了耦合，命令的使用者不再需要了解系统底层的逻辑，只需要使用包装好的命令。\n\n\n\n定义一个算法的骨架，把一些操作延迟到子类中进行。\n\n\n\n\n一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。\n\n\n\n还不太理解\n\n\n\n定义一个转换器，将一个类的接口转换成用户需要的另一个接口\n比如要修改数据格式。\n\n\n\n\n对象声明自己的依赖，而该依赖由外部注入的形式为其提供\n可以降低耦合度（如果自己里面再声明一个类，耦合度太高了）\n\n\n\n\n防御式编程 ：数组越界、空指针、函数参数、返回值、外部接口。\n考虑到输入的不确定性，在程序代码的主要逻辑之外增加了大量的检查，包括对所有外来数据的检查、对所有输入参数的检查等，并最终决定如何处理不符合预期的输入。\n理解构成良好代码风格的主要因素：\n\n命名—符合语义（是什么、做什么、易于识别）\n注释—合理使用序言式注释与功能性注释\n视觉组织—清晰的缩进、空格与换行\n语句构造—避免太长的子程序、嵌套、语句，避免一行多语句\n输入输出—检查输入输出、简化输入输出步骤、合理的输入输出提示、为输出添加注释\n避免“魔法”—何为魔法串/数字\n\n\n\n\n\n\n\n单元测试：集中于每个独立的模块。该测试以详细设计文档为指导，测试模块内的重要控制路径。（往往采用白盒测试技术）\n集成测试：集中于模块的组装。其目标是发现与接口有关的错误，将经过单元测试的模块构成一个满足设计要求的软件结构。\n确认测试（有效性测试）：目标是发现软件实现的功能与需求规格说明书不一致的错误。（通常采用黑盒测试技术）\n系统测试：集中检验系统所有元素（包括硬件、软件）之间协作是否合适，整个系统的性能、功能是否达到。\n\n\n\n\n\n主要依据详细设计说明书和源代码清单\n主要测试模块的I/O条件和模块的逻辑结构\n主要采用白盒测试方法设计测试用例，辅以黑盒测试的测试用例，使之对任何合理的和不合理的输入都要鉴别和响应\n要对所有的局部和全局数据结构、外部接口和程序代码的关键部分进行代码审查\n\n\n\n\n\n\n\n把各个模块连接起来的时候，穿越模块接口的数据是否丢失\n\n一个模块的功能是否对另一个模块的功能产生不利的影响\n\n各个子功能组合起来，能否达到预期要求的父功能\n\n全局数据结构是否有问题\n\n单个模块的误差累加起来，是否达到不可接受的程度\n\n集成测试的方法：一次性组装方法、增量式组装方法\n\n\n\n有效性测试，即验证软件的功能和性能及其他特性是否与用户的要求一致\n有效性测试是在模拟的环境（可能是开发环境）下，运用黑盒测试的方法，验证被测软件是否满足需求规格说明书列出的需求。\n软件配置审查是保证软件配置的所有成分齐全，各方面的质量符合要求，具有维护阶段所必须的细节，并且已编排好分类的目录。\n\n\n\n\n集中检验系统所有元素（包括硬件、信息等）之间协作是否合适，整个系统的性能、功能是否达到。\n系统测试实际上是一系列不同的测试，以下是用于系统测试的几种典型软件系统测试：\n\n功能测试：在规定的时间内运行软件系统的所有功能，以验证这个软件系统有无严重错误。\n恢复测试：是一种系统测试，它指采取各种人工干预方式强制性地使软件出错，使其不能正常工作，进而检验系统的恢复能力\n安全性测试：就是试图去验证建立在系统内的预防机制，以防止来自非正常的侵入\n强度测试：是在非正常数量、频率或容量资源方式下运行一个系统 （已经不正常了）\n压力测试：系统正常运行的最低限度\n性能测试：测试软件在被组装进系统的环境下运行时的性能 （还是正常的）\n可用性测试：从使用的合理性、方便性等角度对软件系统进行检验，以发现人为因素或使用上的问题\n部署测试（配置测试）：软件必须在多种平台及操作系统环境中运行。有时将部署测试称为配置测试，是在软件将要在其中运行的每一种环境中测试软件。另外，部署测试检查客户将要使用的所有安装程序及专业安装软件，并检查用于向最终用户介绍软件的所有文档。\n\n\n\n\n\n\n\n也就是类测试。面向对象软件的类测试相当于传统软件中的单元测试，类包含的操作是最小的可测试单元\n功能性测试：以类的规格说明为基础，主要检查类是否符合规格说明的要求。功能性测试包括两个层次：类的规格说明和方法的规格说明\n结构性测试：从程序出发，对类中的方法进行测试，需要考虑其中的代码是否正确。测试分为两层 ：第一层考虑类中各独立的方法，即方法要做单独测试；第二层考虑方法之间的相互作用，即方法需要进行综合测试\n基于状态的测试：基于状态的测试是通过检查对象的状态在执行某个方法后是否会转移到预期状态的一种测试技术；跟踪监视对象数据成员的值的变化。\n\n\n\n基于线程的测试（thread-based testing）：对响应系统的一个输入或一组类进行集成，每个线程单独地集成和测试事件所需的，应用回归测试以确保没有产生副作用\n基于使用的测试(use-based testing)：通过测试很少使用服务类的那些类（称之为独立类）开始构造系统，独立类测试完后，利用独立类测试下一层次的类（称之为依赖类）。继续依赖类的测试直到完成整个系统\n簇测试（cluster testing）是面向对象软件集成测试中的一步 ：利用试图发现协作中的错误的测试用例来测试协作的类簇\n\n\n\n功能测试、强度测试、性能测试、安全测试、回复测试、可用性测试、安装/卸载测试\n\n\n\n\n\n\n\n对认定的对象的测试：\n\n测试认定的对象是否全面，是否问题空间中所有涉及的实例都反映在认定的抽象对象中\n\n测试认定的对象是否具有多个属性，只有一个属性的对象通常应看成其他对象的属性，而不是抽象为独立的对象\n\n测试被认定为同一对象的实例是否具有区别于其他实例的共同属性\n\n测试被认定为同一对象的实例是否提供或者需要相同的服务。如果服务随着不同的实例而变化，那么认定的对象就需要进行分解或者继承来分类表示\n\n认定的对象的名称应该尽量准确、适用\n\n结构分为两类：分类结构（一般-特殊）和组装结构（整体-部分）\n对认定的分类结构的测试。\n对认定的组装结构的测试。\n对定义的属性和实例关联的测试\n对定义的服务和消息关联的测试\n\n\n\n对认定的类的测试\n对构造的类层次结构的测试\n对类库支持的测试\n\n\n\n数据成员是否满足数据封装的要求\n类是否实现了要求的功能"
  },
  {
    "objectID": "PDF/OOP/期末复习.html#第一章-面向对象方法概论",
    "href": "PDF/OOP/期末复习.html#第一章-面向对象方法概论",
    "title": "面向对象技术引论期末复习",
    "section": "",
    "text": "对象：客观存在的事物\\(\\rightarrow\\)​对象，对象作为基本构成单位。\n属性与操作：属性表示性质，操作表示行为。\n对象的封装：对象的属性与操作结合为一体，成为一个独立的、不可分的实体，对外屏蔽其内部细节。公开静态的、不变的操作，而把动态的、易变的操作隐藏起来。\n\n分类：相同属性和相同操作分为一类。\n聚合：复杂的对象可以用简单的对象作为其构成部分。\n\n继承：特殊类继承一般类。\n消息：对象之间通过消息进行通讯，以实现对象之间的动态联系。\n\n关联：表示对象之间的静态关系。\n\n\n\n\n从程序设计方法的角度看，面向对象是一种程序设计范型(paradigm)。使用对象、类、继承、封装、聚合、关联、消息、多态性等基本概念来进行程序设计。\n从软件方法学的角度看，面向对象方法是一种运用对象、类、继承、封装、聚合、关联、消息、多态性等概念来构造系统的软件开发方法。\n程序=&lt;对象, 关系&gt; 对象=算法+数据结构"
  },
  {
    "objectID": "PDF/OOP/期末复习.html#第二章-需求获取与分析",
    "href": "PDF/OOP/期末复习.html#第二章-需求获取与分析",
    "title": "面向对象技术引论期末复习",
    "section": "",
    "text": "需求工作：起始活动（可行性分析）\\(\\rightarrow\\) 需求获取活动（得到软件需求陈述，通过自然语言、用况图、用户故事等）\\(\\rightarrow\\) 需求分析活动（一个精确的需求模型）\\(\\rightarrow\\) 需求规约活动（软件需求规约，采用标准的模板） \\(\\rightarrow\\) 需求验证活动 \\(\\rightarrow\\) 需求管理活动\n\n\n一个需求是一个陈述，描述了待开发产品／系统（或项）功能上的能力、性能参数或者其它性质。\n\n\n\nIEEE标准830-1998要求单一需求必须具有5个基本性质:\n\n必要的(Necessary)。缺少了这个需求是不是还可以？\n无歧义的(Unambiguous)。只能用一种方式解释吗？\n\n可测试的(Testable)。可以对它进行测试吗？\n可跟踪的(Traceable)。可以从一个开发阶段到另一个阶段对它进行跟踪吗？不可能开发过程中需求就消失了。\n可测量的(Measurable)。可以对它进行测量吗？应该有一个方法可以衡量需求是否被满足了。\n\n注:确定一个需求是否满足以上五个性质是复杂耗时的过程。\n\n\n\n功能；性能；外部接口；设计约束；质量属性\n功能的需求是最重要的，所有别的需求都必须依附在功能这个需求之上。\n\n\n功能需求规约了系统或系统构件必须执行的功能。\n\n对该功能输入的假定，或者为了验证该功能输入，有关检测的假定。（类似于OI竞赛中给定的\\(n\\leq 100\\)这样）\n功能内的任一次序，这一次序是与外部有关的。（应该先干啥）\n对异常条件的响应，包括所有内外部所产生的错误。\n需求的时序或优先程度。\n功能之间的互斥规则。\n系统内部状态的假定。\n为了该功能的执行，所需要的输入和输出次序。\n用于转换或内部计算所需要的公式。\n\n\n\n\n系统或系统构件必须具有的性能特性。\n注：性能需求隐含了一些满足功能需求的设计方案，经常对设计产生一些关键的影响。例如：排序，关于花费时间的规约将确定哪种算法是可行的。\n\n\n\n应当为外部提供什么样的接口，应当使用哪些外部接口，进而必须可以处理这样的格式的数据。\n\n系统接口：与系统的其他应用进行交互。\n用户接口：规约对给用户所显示的数据，对用户所要求的数据以及用户如何控制该用户接口。\n硬件接口\n软件接口：和其他软件产品交互。比如和数据库管理系统交互，和操作系统交互。（问：和操作系统交互的接口到底是软件接口还是系统接口？）\n通讯接口：比如必须使用的网络类型。\n内存约束：描述易失性存储和永久性存储的特性和限制，特别应描述它们是否被用于与一个系统中其它处理的通讯。（问：为什么内存约束要被使用在外部接口需求这里？）\n操作：规约用户如何使系统进入正常和异常的运行以及在系统正常和异常运行下如何与系统进行交互。应该描述在用户组织中的操作模式，包括交互模式和非交互模式；描述每一模式的数据处理支持功能；描述有关系统备份、恢复和升级功能方面的需求。（问：没有理解）\n地点需求：如何安装以及调整一个地点，来适应新的系统。\n\n\n\n\n设计约束限制了系统或系统构件的设计方案。就约束的本身而言，对其进行权衡或调整是相当困难的，甚至是不可能的。它们必须予以满足。\n任取10秒，一个特定应用所消耗的可用计算能力平均不超过50%。（问：为什么不属于性能需求？）\n系统必须用C++或其他面向对象语言编写。系统用户接口需要菜单。（问：这里为什么不属于外部接口需求？）\n必须在对话窗口的中间显示错误警告，其中使用红色的、14点加粗Arial字体。（问：这里为什么不属于功能需求？）\n\n法规限制\n硬件限制\n与其他应用的接口\n并发操作\n审计功能\n控制功能\n高级语言需求\n握手协议\n应用的关键程序\n安全考虑\n\n\n\n\n可靠性、可维护性、易用性（用户友好性）、安全性、可移植性、规模、速度\n\n\n\n\n\n\n需求人员把自己作为系统的最终用户，审视该系统并提出问题：“如果是我使用这一系统，则我需要…”\n\n\n\n在交谈期间需求可能不断增长，或是以前没有认识到的合理需求的一种表现，说是“完美蠕行”(Creeping elegance)病症的体现，以至于很难予以控制，可能导致超出项目成本和进度的限制。\n解决方法：项目管理人员和客户管理人员应该定期地对交谈过程的结果进行复审。\n\n\n\n尽管了解的这些信息可以通过交谈获取，但 “第一手材料”一般总是能够比较好地“符合现实”。\n客户可能抵触这一观察。\n客户还可能认为开发者在签约之前，就已经熟悉了他们的业务。（问：这句话想表达什么？）\n\n\n\n举行客户和开发人员的联席会议，与客户组织的一些代表共同开发需求。\n\n\n\n复审技术文档。\n提炼方法是针对已经有了部分需求文档的情况。依据产品的本来情况，可能有很多文档需要复审，以确定其中是否包含相关联的信息。在有的情况，也可能只有少数文档需要复审。\n\n\n\n\n\n\n把系统看作一个黑箱，看它对外部的客观世界发挥什么作用，描述它外部可见的行为。\n\n我们可以有很多参与者在这里面。\n优势：易于探讨和理解、易于对需求规范化、有利于进行OOA、有助于发现主动对象、对系统测试来说，产生测试用例、有助于人机界面设计、etc\n系统边界、操作者、用况、关联、包含、扩展、泛化\n\n\n某些事物可能既有一个对象作为其抽象描述，而本身（作为现实世界中的事物）又是在系统边界以外与系统进行交互的操作者。如超市中的收款员，他本身是现实中的人，作为操作者；在系统边界内，又有一个相应的“收款员”对象来模拟其行为或管理其信息，作为系统成分。\n某些事物即使属于问题域，也与系统责任没有什么关系。如超市中的保安员，在现实中与超市有关系，但与所开发的系统超市商品管理系统无关系。这样的事物既不位于系统边界内，也不作为系统的操作者。\n\n\n\n尽管在模型中使用操作者，但操作者实际上并不是系统的一部分。它们存在于系统之外。\n\n我们可能的操作者。\n\n\n\n从使用视角看：用况是对操作者使用系统的一项功能时所进行的交互过程的描述。\n\n\n\n用况和操作者之间的唯一的关系，但是用况之间还有别的其他的关系。\n\n\n\n从基用况到扩展用况的扩展关系表明：按基用况中指定的扩展条件，把扩展用况的行为插入到由基用况中的扩展点定义的位置。\n\n扩展的适用条件：(1) 异常情况；(2) 正常的变形描述时，而且希望采用更多的控制方式时，采用扩展。即在一个变化点上一个附加多个变体的场合下使用；(3) 用扩展关系来区分可实现系统的可配置部分（问：什么意思？）。\n\n\n\n从基用况到供应者用况的包含关系表明：基用况在它内部说明的某一（些）位置上显式地使用供应者用况的行为的结果。\n（问：包含和扩展有什么区别呢？我的理解是一个是显式地使用包含用况，一个是隐式地使用扩展用况？）\n\n\n\n\n\n\n\n\n\n识别操作者、捕获用况（从操作者的角度来看、从系统功能的角度来看、从场景技术的角度来看）、系统的需求建模、审查\n\n\n\n\n用户+事件。其中用户表现为对主要用户的描述，事件则是场景或系统/任务价值\n用户故事相当于用况图正文的描述说明。UML实际推崇的是用况图，但在敏捷开发中使用面向对象方法时也会将用户故事作为系统的需求描述"
  },
  {
    "objectID": "PDF/OOP/期末复习.html#第三章-uml",
    "href": "PDF/OOP/期末复习.html#第三章-uml",
    "title": "面向对象技术引论期末复习",
    "section": "",
    "text": "UML是系统分析和设计的工具\n\n\n\n\n参与者、信号、实用程序都是类。\n\n为什么对象没有操作栏？这是因为它的操作已经在它的类里面被定义了，而属性栏之所以存在是因为我们在构造这个对象的时候，必须为它填入初始的属性。\n抽象类使用斜体字。\n类可以有所在的包名。\n\n属性的默认语法：[可见性]属性名[:类型][多重性][=初始值][{特性串}]，比如+name: String[0..1] = \"Hello\"{readonly}。\n\n可见性：为什么引入可见性？为了支持信息隐蔽这一软件设计原则。信息隐蔽是指在每个模块中所包含的信息（包括表达信息的数据以及表达信息处理的过程）不允许其它不需要这些信息的模块访问。信息隐蔽是实现模块低耦合的一种有效途径。\n属性名：小写字母开头\n类型名\n多重性：省略的时候默认为[1..1]\n初始值\n性质串：a : integer = 10 {frozen}，这就表示属性是不可改变的\n\n所有的共同的属性，加上下划线，defaultSize这样子的。\n\n\n\n可见性\n符号表示\n关键字表示\n描述\n\n\n\n\n公有的\n+\npublic\n所有其他的类/类目都可以使用\n\n\n受保护的\n#\nprotected\n仅其子类/类目才能使用\n\n\n私有的\n-\nprivate\n仅本类的操作才能使用\n\n\n包内的\n~\npackage\n仅同一包中声名的类/类目才能使用\n\n\n\n操作的默认语法：[可见性] 操作名 [(参数表)] [: 返回类型] [{性质串}]，例：+ set(id : Integer, name : String) : Boolean {...}。\n参数表里的每个参数还可以如下：[方向] 参数名 : 类型 [= 默认值]，比如in name: String = \"Hello\"。\nin输入参数，inout输入参数可修改，out输出参数。\n衍型：类型的类型，用双尖括号包裹起来。&lt;&lt;datatype&gt;&gt;。\n\n\n\n\n\n\n\n\n\n\n协作是一个交互，涉及交互三要素：交互各方、交互方式以及交互内容 。\n使机器人沿着一条路径移动所涉及的类 \\(\\rightarrow\\) 一个协作\n\n\n\n一个用况描述了系统的一个完整的功能需求。\n用况是通过协作予以细化的。\n\n\n\n进程和线程都是主动类。\n主动类对象的行为通常与其他元素的行为是并发的。\n至少具有一个进程或线程的类，能够启动系统的控制活动。\n\n\n\n在遵循并提供了一组外部接口的实现的同时，隐藏内部实现。构件是描述比特世界的软件制品的系统单位。\n应用、文档、库、页和表都是构件。\n\n\n\n\n系统中包含物理信息的、可替代的物理部件。\n这里说部件是“物理的”，指软件未运行时也存在的部分，主要指文件，如源代码、可执行程序、脚本等；软件系统中可能会存在不同类型的部署制品；制品通常代表对源代码/运行时信息的物理打包。\n\n\n\n\n在运行时存在的物理元素，通常它表示一种具有记忆能力和处理能力的计算机资源（比如服务器、数据库管理系统等）\n这里的“物理的”指实际机器设备；一个构件可以驻留在一个节点中，也可以从一个节点移到另一个节点。\n\n\n\n\n\n\n\n它指明一个类的对象与另一个类的对象间的联系。如果类的对象之间通过属性有连接关系，那么这些类之间的语义关系就是关联。链是关联的实例，是对象间的语义连接，是对象引用的元组（列表）。 在最常见的情况下，它是一对对象引用。\n关联表示对象之间的静态联系。\n\n这里的多重性是一个教师可以指导0到多个学生的论文，而一个学生只能被一个教师指导论文。\n\n还可以用关联导航来解决。\n\n角色和关联端名：\n\n限定符：\n\n\n\n一种特殊形式的关联，表达一种“整体 /部分”关系。即一个类表示了一个大的事物，它是由一些小的事物（部分）组成的。\n\n\n\n\n组合是一种特殊的聚合。组合中的对象具有相同的生命周期。\n组合的末端的多重性不能超过1。因为一个对象最多组合成另一个对象。\n在一个组合中，由一个链所连接的对象而构成的任何元组，必须都属 于同一个整体类的对象（问：没有理解这句话）\n\n\n\n\n\n关联类：具有关联和类特性的模型元素，可以被看作是关联，但还有类 的特性；或被看作是一个类，但有关联的特性。\n\n比如我们能认为大学和教师之间的关联是通过任务来获得的。\n\n\n\n“is-a-kind-of” 继承关系又称为一 般一特殊关系，在UML中把继承关系称为泛化关系。\n\n\n\n\n在两个地方会使用实现的关系：接口与实现它们的类和构件之间；用况与实现它们的协作之间。\n\n\n\n\n依赖是一种使用关系，用于描述一个类目使用另一类目的信息和服务。\n\n\n\n\n\n\n使用“关联”，模型化系统中存在的大量静态结构和动态结构。\n\n以数据驱动：一个对象需要导航到另外一个对象\n以行为驱动：一个对象需要与另一个对象交互\n\n\n\n使用“泛化”，对系统中存在的一般/特殊关系规约。\n\n\n\n使用“实现”，对系统中存在的精化关系规约\n该术语用于表达不同抽象层之间的精化，体现“自顶向下，逐步求精” 的思想。如系统需求层的用况，可通过协作实现。这两者即可用 “实现”规约。\n\n\n\n使用“依赖”，对不是结构、继承、精化的关系规约。\n某类只作为另一类的操作参数，则可将它们之间的关系抽象为依赖\n\n\n\n\n\n\n\n\n可以在小矩形里写包名，大矩形中表示内容。\n也可以这样画：\n\n引入依赖和访问依赖。\n\n这样表示Controller可以访问Components和Subcomponents。\n\n\n\n注解可以是简单文字，也可以内嵌URL或文档链接，用虚线连接到所解释说明的模型元素上。\n\n\n\n\n\n\n\n类图显示了类（及其接口）、类的内部结构以及与其他类的联系。是面向对象分析与设计所得到的最重要的模型。\n\n\n\n用对象图说明在类图中所发现的事物的实例的数据结构和静态快照。\n\n\n\n就是用来表示构件之间的关系的图。\n\n\n\n\n\n\n\n\n\n\n外扩图是在UML2.5的基础上定义新建模元素的图，用以增加新的建模能力\n\n\n\n\n所以这个图可以和构件图结合在一起。\n\n\n\n\n\n\n通常都是对反应型对象（reactive object）的行为进行建模。\n\n状态机图是描述一个对象或其他实体在其生命周期中所经历的各种状态以及状态变迁的图.\n一个状态机图，规约了一个对象在其生存期内因响应事件所经历的状态序列以及对这些事件所作出的响应。\n状态之间的转化是即时的。\n延迟事件：延迟事件是指在当前状态下暂不处理，但将推迟到该对象的另一个状态下排队处理的事件。比如我现在想要识别出某一个事件，但是我现在不处理。activity/defer\n事件：事件就是状态转移的实心线上面标记的东西。activity(parameter1: Type1, ...)。\n\n信号（Signal）事件：信号是一种Type，所以它的原类型是signal。这里是衍型。\n调用（Call）事件：一个调用事件表示对象接收到一个操作调用的请求。\n时间事件：时间事件后跟有计算时间量的表达式。after (2 seconds)。\n变化事件：指定条件变为真了，譬如at (xxx)/selfTest(), when (altitude &lt; 1000)。\n\nactivityName[(Parameter list)][Guard][/Action]。比如：right-mouse-down(location)[location in window]/object:=pick_object(location)。\nUML内置关键字：\n\nentry：进入状态时首先执行该动作。它不能有参数或监护条件。\nexit：在退出状态时最后执行该动作。它不能有参数或监护条件。\ndo：在状态的进入动作表达式（如果有）执行后，开始执行do活动，并且do活动可与其他的动作或者活动并行。\n\n状态间的转移 vs. 状态内的转移 ： 如果源状态和目标状态都是自身，那么会先触发该状态的退出动作，再执行该状态的进入动作，和状态内的转移有区别。\n\n\n\n顺序子状态机（非正交）和并发子状态机（正交）\n非正交状态机：最多有一个子初态和一个子终态。\n\n转移到该组合状态：这个被嵌套的子状态机一定有一个初态，以便在进入该组合状态并执行其进入动作后，将控制传送给这一初态。\n转移到该组合状态的一个子状态：在执行完该组合状态的进入动作（如有的话）和该子状态的进入动作后，将控制传送给这一子状态。\n\n\n离开的时候：首先离开被嵌套的状态，即执行被嵌套状态的退出动作（如有的话）；然后离开该组合状态，即执行该组合状态的退出动作（如有的话）。\n正交状态机：控制流分岔，分成了并发流。\n\n\n\n\n动作是原子的和即时的。\n对象是方的矩形，而动作是圆角的矩形。\n\n\n\n\n一种详细表示 对象之间以及对象与参与者实例之间交互的图，它由一组协作的对象（或参与者实例）以及它们之间可发送的消息组成，它强调消息之间的顺序。\n对象：[ObjectName]: ClassName。\n参与者：一个小人\n对象生命线：一个垂直虚线，用X表示被析构。\n执行规约：窄长的矩形。\n消息：同步消息：实心的箭头，返回虚线箭头 异步消息：实现，空心的箭头\n\n消息分支：把分支画成从一个点出发的多个箭头，每个箭头由监护条件标示\n消息循环：*Message[Guard]，表示按照给定的表达式一直发送信息。\n回调机制：申请对象在服务对象处事先登记所关心的事件，然后继续从事自己的工作；当服务对象监控到这样的事件发生时，再通知申请对象，由申请对象进行处理。这是一个异步的。\n\n\n选择（opt,为真才执行）、条件（alt,有两种选择）、并发（par,同时做）、迭代（loop guard,循环）\n\n\n\n\n\n为表示一个消息的时间顺序，给消息加一个数字前缀（从1号消息开始），在控制流中，每个新的消息的顺序号单调增加（如2，3等等）。为了显示嵌套，可使用带小数点的号码（1表示第一个消息；1.1表示嵌套在消息1中的第一个消息；1.2表示嵌套在消息1中的第二个消息；等等）。\n通信图和顺序图两者语义上是等价的。\n\n\n\n\n用于描述系统的宏观行为，是活动图和顺序图的混合物。\n\n\n\n用于表示交互，它展现了消息跨越不同对象或角色的实际时间，而不仅仅关心消息的相对顺序。"
  },
  {
    "objectID": "PDF/OOP/期末复习.html#第四章-ooa",
    "href": "PDF/OOP/期末复习.html#第四章-ooa",
    "title": "面向对象技术引论期末复习",
    "section": "",
    "text": "运用面向对象方法，对问题域（被开发系统的应用领域）和系统责任（所开发系统应具备的职能）进行分析和理解 。\n\n\n\n\n\n\n\n\n发现对象，定义他们的类。\n识别对象的内部特征：定义属性、定义操作。\n识别对象的外部关系：分类关系（继承）、构成关系、静态联系、使用关系\n给出系统的相关顺序图、状态图和活动图等，以建立系统的动态模型\n划分包，建立系统的包图\n建立系统的详细说明\n\n\n\n\na） 信息组织的复杂性：\n抽象:从许多事物中舍弃个别的、非本质的特征，抽取共同的、本质性 的特征：系统中的对象是对现实世界中事物的抽象； 类是对象的抽象；一般类是对特殊类的抽象； 属性是事物静态特征的抽象； 操作是事物动态特征的抽象。\n分类机制:把具有相同属性和操作的对象划分为一类，用类作为这些对象 的抽象描述。\n继承:特殊类的对象拥有其一般类的全部属性和服务（一般-特殊结构）；\n聚合:把一个复杂的事物看成若干比较简单的事物的组装体，从而简化对 复杂事物的描述。（整体-部分结构）\n消息通讯：要求对象之间只能通过消息进行通讯，而不允许在对象之外 直接地存取对象内部的属性。\n多个视图：从多个角度认识系统\nb） 文档组织的复杂性—控制机制\n包：使模型具有大小不同的粒度层次，以利于控制复杂性"
  },
  {
    "objectID": "PDF/OOP/期末复习.html#第五章-ood",
    "href": "PDF/OOP/期末复习.html#第五章-ood",
    "title": "面向对象技术引论期末复习",
    "section": "",
    "text": "瀑布模型和喷泉模型\n\n\n\n\n\n\n\n不强调次序，逐个设计每个部分。\n\n\n它是在OOA模型基础上按实现条件进行必要的修改、调整和细节补充而得到的。\n实现条件：\n\n编程语言：对问题域的影响最大。选定的编程语言不支持某些面向对象的概念与原则；OOA阶段可能将某些与编程语言有关的对象细节推迟到OOD阶段来定义。如对象的创建、删除、复制、转存、初始化等系统行为、属性的数据类型等。\n\n为复用设计与编程的类而增加新的结构\n增加一般类以建立共同协议（比如：提供创建、删除、复制等操作，Java里面的object就可以体现这个问题，它是所有的类的父类，所有的类都要继承它）object{复用}\n按编程语言调整继承和多态：如果编程语言不支持多继承怎么办？（方法1：采用聚合，把多继承转换为单继承，方法2：重新定义对象类，方法3：压平）如果编程语言不支持继承怎么办？（方法1：把继承结构展平，所有需要的信息都放到展平后的类里面去；方法2：再加上聚合，每个类不存在信息冗余）如果编程语言不支持多态怎么办？重新命名函数。\n提高性能：调整对象分布，合并通讯频繁的类\n为实现对象永久存储做的修改\n为编程方便增加底层成分\n对复杂关联的转化并决定关联的实现方式：多对多关联转化为一对一关联\n调整与完善属性\n构造和优化算法\n决定对象间的可访问性\n定义对象实例：当系统需要通过从外存读取数据来创建一个对象时 ，先创建该对象，再从外存中读取这个对象数据，把数据赋值给对象的相应属性。\n\n硬件、操作系统及网络设施\n\n复用支持\n数据管理系统\n界面支持系统\n\n\n（道理：尽管继承和聚合反映了现实世界中两种不同的关系，但是从最终效果来看却存在共性－都是使一个类的对象能够拥有另一个（一些）类的属性和操作。）\n\n（重新审视原来用多继承结构表达的实际事物及它们之间的关系。例如，上述例子换一个角度看问题：形成这种分类的原因使什么？从而增加“身份”类，构成单继承。）\n\n（缺点：损失了信息）\n为什么要这么做：使反映问题域本质的总体框架和组织结构长期稳定，而细节可变；稳定部分与可变部分分开，使系统从容地适应变化；有利于同一个分析用于不同的设计与实现；支持系统族和相似系统的分析设计及编程结果复用；使一个成功的系统具有超出其生存期的可扩展性\n\n\n\nOOD要设计人机交互的细节，而OOA用人机交互来反映需求\n\n分析与系统交互的人：设计时重点考虑比例最大的人员情况，并适当地兼顾其他人。\n从use case分析人机交互\n\n人机交互界面的设计准则：使用简便、一致性、启发性、减少人脑记忆的负担、减少重复的输入、容错性、及时反馈、防止灾难性的错误\n\n\n\n控制流驱动部分，用于定义和表示并发系统中的每个控制流。用主动对象表示每个控制流(进程、线程) ，所有的主动类构成控制驱动部分\n如何设计控制驱动部分：用包括主动类的类图捕捉控制流的静态结构；用包括主动对象的顺序图或通信图捕捉控制流的动态行为。\n\n\n\n数据管理部分是负责在特定的数据管理系统中存储和检索持久对象的组成部分\n其目的是，存储问题域的持久对象、封装这些对象的查找和存储机制，以及为了隔离数据管理方案的影响\n文件系统、R-DBMS（关系数据库系统）、OO-DBMS（面向对象数据库系统）\n\n\n\n面向对象\n实体-联系\n关系数据库\n\n\n\n\n类\n实体类型\n表\n\n\n对象\n实体实例\n行\n\n\n属性\n属性\n列\n\n\n关系\n关系\n表\n\n\n\n\n这个关联的表是右下角，应该是一种 link1 : {EmployeeNumber , Location}这样的一行。\n如果是1对多，可以为比如公司职员记录公司ID这个属性。或者是公司ID和职员ID建立一个关联表。\n如果是多对多呢：\n\n还有对父类和子类的关系的存储可以有下面的三种情况：\n\n（下推）：为每一个子类定义一张单独的表。当增加新的父类或者子类的时候对数据库的维护和修改是很大的麻烦。\n（上拉）去掉继承的网络结构。对实例要存储大量的冗余。\n（分割表）将父类和子类的状态存储在不同的表中。这种方法很好地反映了继承网格，但它的缺点是访问数据时需要许多跨表连接。\n\n对象存储器。\n\n\n\n构件具有端口和接口。\n接口是一个圆圆的或者半圆的，端口是一个方形的那个。"
  },
  {
    "objectID": "PDF/OOP/期末复习.html#第六章oopoopl",
    "href": "PDF/OOP/期末复习.html#第六章oopoopl",
    "title": "面向对象技术引论期末复习",
    "section": "",
    "text": "语言元素可以支持\n\n类的定义\n对象的静态声明或者动态创建\n属性和操作的定义\n继承、聚合、关联和消息的表示\n\n语言机制有：\n\n类机制\n封装机制\n继承机制\n\n高级特性：多态、多继承的表示和支持机制\n\n\n\n纯面向对象语言：Smalltalk、Eiffel、Java\n较为全面的支持OO，强调严格的封装\n混合型：C++、Objective-C、Objective-Pascal、Python\n在一种非OO语言的基础上扩充OO成分、对封装采取灵活的态度\n\n问：为什么说对象指针实现了关联?"
  },
  {
    "objectID": "PDF/OOP/期末复习.html#第七章-设计模式",
    "href": "PDF/OOP/期末复习.html#第七章-设计模式",
    "title": "面向对象技术引论期末复习",
    "section": "",
    "text": "在高层定义接口，隐藏复杂性。可以理解为UI界面。\n或者类似于一个APP的页面。\n\n隐藏复杂性\n可以用来包装遗产系统\n用来检测某项的访问量\n\n\n\n\n将抽象部分与它的实现部分分离，使它们都可以独立地变化\n识别出一个类所具有的两个独立变化的维度，将它们设计为两个继承等级结构，并建立抽象和实现的聚合关系\n\n\n\n\n一个类只有一个实例，并提供全局的访问点。\n全局变量无法阻止多次的实例化，而单例把实例化的方法私有了，这样就只能在一开始创建的时候实例化一次了。\n先判断单例是否已经实例化，没有实例化的话再对实例化函数加锁。\n\n\n\n类似于一个存档。\n\n\n\n\n优势：低耦合！策略可以自由切换，系统扩展性、灵活性更高\n\n\n\n\n\n让所有的实例化都通过工厂来完成。\n可以减少构造对象的时候的复杂性。\n\n\n\n用来创建对象族的。\n\n\n\n\n\n代理还可以再加入一点自己的操作。\n\n\n\n提供访问数据结构的方法\n\n\n\n访问复杂的数据结构\n\n\n\n\n\n\n\n将一个请求封装成一个对象，使得发出请求的责任和执行请求的责任分开。\n\n命令模式降低了耦合，命令的使用者不再需要了解系统底层的逻辑，只需要使用包装好的命令。\n\n\n\n定义一个算法的骨架，把一些操作延迟到子类中进行。\n\n\n\n\n一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。\n\n\n\n还不太理解\n\n\n\n定义一个转换器，将一个类的接口转换成用户需要的另一个接口\n比如要修改数据格式。\n\n\n\n\n对象声明自己的依赖，而该依赖由外部注入的形式为其提供\n可以降低耦合度（如果自己里面再声明一个类，耦合度太高了）"
  },
  {
    "objectID": "PDF/OOP/期末复习.html#第八章-代码风格和编码规范",
    "href": "PDF/OOP/期末复习.html#第八章-代码风格和编码规范",
    "title": "面向对象技术引论期末复习",
    "section": "",
    "text": "防御式编程 ：数组越界、空指针、函数参数、返回值、外部接口。\n考虑到输入的不确定性，在程序代码的主要逻辑之外增加了大量的检查，包括对所有外来数据的检查、对所有输入参数的检查等，并最终决定如何处理不符合预期的输入。\n理解构成良好代码风格的主要因素：\n\n命名—符合语义（是什么、做什么、易于识别）\n注释—合理使用序言式注释与功能性注释\n视觉组织—清晰的缩进、空格与换行\n语句构造—避免太长的子程序、嵌套、语句，避免一行多语句\n输入输出—检查输入输出、简化输入输出步骤、合理的输入输出提示、为输出添加注释\n避免“魔法”—何为魔法串/数字"
  },
  {
    "objectID": "PDF/OOP/期末复习.html#第九章-面向对象测试",
    "href": "PDF/OOP/期末复习.html#第九章-面向对象测试",
    "title": "面向对象技术引论期末复习",
    "section": "",
    "text": "单元测试：集中于每个独立的模块。该测试以详细设计文档为指导，测试模块内的重要控制路径。（往往采用白盒测试技术）\n集成测试：集中于模块的组装。其目标是发现与接口有关的错误，将经过单元测试的模块构成一个满足设计要求的软件结构。\n确认测试（有效性测试）：目标是发现软件实现的功能与需求规格说明书不一致的错误。（通常采用黑盒测试技术）\n系统测试：集中检验系统所有元素（包括硬件、软件）之间协作是否合适，整个系统的性能、功能是否达到。\n\n\n\n\n\n主要依据详细设计说明书和源代码清单\n主要测试模块的I/O条件和模块的逻辑结构\n主要采用白盒测试方法设计测试用例，辅以黑盒测试的测试用例，使之对任何合理的和不合理的输入都要鉴别和响应\n要对所有的局部和全局数据结构、外部接口和程序代码的关键部分进行代码审查\n\n\n\n\n\n\n\n把各个模块连接起来的时候，穿越模块接口的数据是否丢失\n\n一个模块的功能是否对另一个模块的功能产生不利的影响\n\n各个子功能组合起来，能否达到预期要求的父功能\n\n全局数据结构是否有问题\n\n单个模块的误差累加起来，是否达到不可接受的程度\n\n集成测试的方法：一次性组装方法、增量式组装方法\n\n\n\n有效性测试，即验证软件的功能和性能及其他特性是否与用户的要求一致\n有效性测试是在模拟的环境（可能是开发环境）下，运用黑盒测试的方法，验证被测软件是否满足需求规格说明书列出的需求。\n软件配置审查是保证软件配置的所有成分齐全，各方面的质量符合要求，具有维护阶段所必须的细节，并且已编排好分类的目录。\n\n\n\n\n集中检验系统所有元素（包括硬件、信息等）之间协作是否合适，整个系统的性能、功能是否达到。\n系统测试实际上是一系列不同的测试，以下是用于系统测试的几种典型软件系统测试：\n\n功能测试：在规定的时间内运行软件系统的所有功能，以验证这个软件系统有无严重错误。\n恢复测试：是一种系统测试，它指采取各种人工干预方式强制性地使软件出错，使其不能正常工作，进而检验系统的恢复能力\n安全性测试：就是试图去验证建立在系统内的预防机制，以防止来自非正常的侵入\n强度测试：是在非正常数量、频率或容量资源方式下运行一个系统 （已经不正常了）\n压力测试：系统正常运行的最低限度\n性能测试：测试软件在被组装进系统的环境下运行时的性能 （还是正常的）\n可用性测试：从使用的合理性、方便性等角度对软件系统进行检验，以发现人为因素或使用上的问题\n部署测试（配置测试）：软件必须在多种平台及操作系统环境中运行。有时将部署测试称为配置测试，是在软件将要在其中运行的每一种环境中测试软件。另外，部署测试检查客户将要使用的所有安装程序及专业安装软件，并检查用于向最终用户介绍软件的所有文档。\n\n\n\n\n\n\n\n也就是类测试。面向对象软件的类测试相当于传统软件中的单元测试，类包含的操作是最小的可测试单元\n功能性测试：以类的规格说明为基础，主要检查类是否符合规格说明的要求。功能性测试包括两个层次：类的规格说明和方法的规格说明\n结构性测试：从程序出发，对类中的方法进行测试，需要考虑其中的代码是否正确。测试分为两层 ：第一层考虑类中各独立的方法，即方法要做单独测试；第二层考虑方法之间的相互作用，即方法需要进行综合测试\n基于状态的测试：基于状态的测试是通过检查对象的状态在执行某个方法后是否会转移到预期状态的一种测试技术；跟踪监视对象数据成员的值的变化。\n\n\n\n基于线程的测试（thread-based testing）：对响应系统的一个输入或一组类进行集成，每个线程单独地集成和测试事件所需的，应用回归测试以确保没有产生副作用\n基于使用的测试(use-based testing)：通过测试很少使用服务类的那些类（称之为独立类）开始构造系统，独立类测试完后，利用独立类测试下一层次的类（称之为依赖类）。继续依赖类的测试直到完成整个系统\n簇测试（cluster testing）是面向对象软件集成测试中的一步 ：利用试图发现协作中的错误的测试用例来测试协作的类簇\n\n\n\n功能测试、强度测试、性能测试、安全测试、回复测试、可用性测试、安装/卸载测试\n\n\n\n\n\n\n\n对认定的对象的测试：\n\n测试认定的对象是否全面，是否问题空间中所有涉及的实例都反映在认定的抽象对象中\n\n测试认定的对象是否具有多个属性，只有一个属性的对象通常应看成其他对象的属性，而不是抽象为独立的对象\n\n测试被认定为同一对象的实例是否具有区别于其他实例的共同属性\n\n测试被认定为同一对象的实例是否提供或者需要相同的服务。如果服务随着不同的实例而变化，那么认定的对象就需要进行分解或者继承来分类表示\n\n认定的对象的名称应该尽量准确、适用\n\n结构分为两类：分类结构（一般-特殊）和组装结构（整体-部分）\n对认定的分类结构的测试。\n对认定的组装结构的测试。\n对定义的属性和实例关联的测试\n对定义的服务和消息关联的测试\n\n\n\n对认定的类的测试\n对构造的类层次结构的测试\n对类库支持的测试\n\n\n\n数据成员是否满足数据封装的要求\n类是否实现了要求的功能"
  },
  {
    "objectID": "course_notes.html",
    "href": "course_notes.html",
    "title": "Course Notes",
    "section": "",
    "text": "Here are the course notes written by myself. I’ve taken 58 courses (147 points) in PKU.\n\n25-26-1\n…\n\nMathmatical Logic | Click here to view the notes.  数理逻辑 | 点击此处查看笔记.\n\n\n\n24-25-3\n2 courses, 4 points in total.\n\nTopics in Quantitative Finance | Click here to view the website.  量化金融专题 | 点击此处访问网站.\nInter-cultural Communication  跨文化交流学\n\n\n\n24-25-2\n8 courses, 20 points in total.\n\nIntroduction to Database Systems | Click here to view the PDF.  数据库概论 | 点击此处查看PDF.\nPublic Intermediate German  公共中级德语\n\nThe notes. 课程笔记.\nThe tests. 课程小测.\nThe words. 课程单词.\nHere are two passages full of grammer mistakes: Ein Programmierer and Meine Ferien.\n\nSpecial Topics in China Economic Research | Click here to view the PDF.  中国经济专题 | 点击此处查看PDF.\nIntermediate Microeconomics  中级微观经济学\nProgramming in Rust  Rust程序设计\nOrienteering and Hiking  定向与徒步运动\nOperating Systems (Honor Track)  操作系统 (实验班)\nModern Astronomy  现代天文学\n\n\n\n24-25-1\n7 courses, 21 points in total.\n\nPublic Junior German | Click here to view the PDF.  公共初级德语 | 点击此处查看PDF.\nEconometrics | Click here to view the PDF.  计量经济学 | 点击此处查看PDF.\nSoftware Engineering  软件工程\n\nThe notes. 课程笔记.\nThe Assignments. 课程作业.\n\nHomework 1\nHomework 2\nHomework 3\n\n\nA Survey of Mao Tsetung Thoughts and Theory of Socialism with Chinese Charateristics  毛概\nSoftware Analysis | Check Prof. Xiong’s Course Website  软件分析技术 | 查看课程网站\nCompiler Principles  编译原理\n…\n\n\n\n23-24-3\n2 courses, 3 points in total.\n\nPhysical and Aesthetic course  体美\nAural Culture and World Civilization  听觉文化与世界文明\n\n\n\n23-24-2\n9 courses, 24 points in total.\n\nIntroduction to Object Oriented Technology | Click here to view the final-term notes.  面向对象技术引论 | 查看期末复习笔记\nComparative Constitutional Law  外国宪法\nAcademic English Listening and Speaking  学术英语听说\nAlgorithm Design and Analysis  算法设计与分析\nInformation Theory  信息论\nHistory of Rome | Click here to view the PDF.  罗马史 | 点击此处查看PDF.\nSoftware Foundations | Check Prof. Xiong’s Course Website  软件科学基础 | 查看课程网站\nProbability theory and statistics in Information science  信息学中的概率统计\nIntermediate Macroeconomics  中级宏观经济学\n\n\n\n23-24-1\n8 courses, 24 points in total.\n\nHuman Sex, Reproduction and Health  人类的性、生育与健康\nMusic and Mathematics | Click here to view the PDF.  音乐与数学 | 点击此处查看PDF.\nData Structure and Algorithm (A)  数据结构与算法 (A)\nAn Introduction to Marxist Basic Theory  马原\nIntroduction to Discrete Mathmatics  离散数学基础\nPrinciples of Economics  经济学原理\nIntroduction to Computer Systems  计算机系统导论\n…\n\n\n\n22-23-2\n8 courses, 24 points in total.\n\nText and Meaning: British and American Short Stories  英美短篇小说文本分析与鉴赏\nIntroduction to Artificial Intelligence  人工智能引论\nPractice of Programming in C&C++  程序设计实习\nOutline of Chinese Modern History  中国近现代史纲要\n习概\nLinear Algebra A (II)  线性代数A (II)\nAdvanced Mathematics A (no.2)  高等数学A (二)\n…\n\n\n\n22-23-1\n11 courses, 27 points in total.\n\nIntroduction to Seismology  地震概论\nIntroduction to Computation (A)  计算概论A\nAdvanced Mathematics A (no.1)  高等数学A (一)\nFootball  足球\nPhysics for Information Sciences (1)  信息科学中的物理学 (上)\nLinear Algebra A (I)  线性代数A (I)\nIntroduction to Information Science and Technique  信息科学技术概论\n…\n\nTO BE CONTINUED …"
  },
  {
    "objectID": "blogs.html",
    "href": "blogs.html",
    "title": "Blogs",
    "section": "",
    "text": "Here are the blogs where I share my thoughts and notes on various topics."
  },
  {
    "objectID": "blogs.html#llm-for-theorem-proving",
    "href": "blogs.html#llm-for-theorem-proving",
    "title": "Blogs",
    "section": "LLM for Theorem Proving",
    "text": "LLM for Theorem Proving\nCCF软件工程专业委员会首批发布的三个重要难题之一：自动程序定理证明（如何高度自动化地生成程序定理的形式化证明？） One of the three key challenges initially released by the CCF Technical Committee of Software Engineering: Automated Program Theorem Proving (How can formal proofs of program theorems be generated in a highly automated manner?)\n\nSeedProver: (Chen et al. 2025)\n\nLemma-Style Proving: 分解任务, 独立验证, 构建知识库, 组合证明.\nTest-Time Scaling\n\nLight: Proof Sketch → Lean → Error Feedback → Refine\nMedium: Outer Loop for main theorem, Inner Loop for hard lemmas.\nHeavy: Conjecture Proposer (Conjecture Pool) → Light Prover → Lemma Pool → Evaluate → Select High-Quality Lemmas, let Medium Prover prove main theorem again.\n\nIMO 2025: 4/6 problems solved.\n\n\nIn my opinion, some agent techniques can be helpful for theorem proving as well, so I may record some notes of agent papers here:\n\nLive-SWE-Agent: (Xia et al. 2025)\n\nthe first live software agent that can autonomously and continuously evolve itself on-the-fly during runtime\nstarts with the most basic agent scaffold with only access to bash tools\nautonomously evolves its own scaffold implementation\n75.4% in SWE-bench Verified; 45.8% in SWE-Bench Pro. (SOTA in 2025.11)\nQ: What are the tools in Coq/Lean that can help us evolve the proof strategies on-the-fly during proof construction?\n\nthe necessary helper lemmas\nReducing to only necessary hypotheses that imply the goal (Brendel, Sivaraman, and Millstein 2025)"
  },
  {
    "objectID": "blogs.html#formal-methods-in-ai",
    "href": "blogs.html#formal-methods-in-ai",
    "title": "Blogs",
    "section": "Formal Methods in AI",
    "text": "Formal Methods in AI\n\nStatic Analysis for DL Architectures\n\nDEBAR: Detecting numerical bugs in neural network architectures (Zhang et al. 2020)\n\nAffine Relations Abstract Domain.\nTensor Partitioning.\n\nRANUM: Reliability Assurance for Deep Neural Network Architectures Against Numerical Defects (Li et al. 2023)\n\nPotential-Defect Detection via Static Analysis.\nFeasibility Confirmation via Two-Step Test Generation.\nFix Suggestion via Abstract Optimization.\n\n\n\n\nStatic Analysis for DL Models\n\nUse SMT solvers to verify properties of DL models.\nUse integer programming to verify robustness of DL models.\nAbstract interpretation for DL models. (e.g., \\(\\text{AI}^2\\), DeepPoly, etc.)\n\nZonotope abstract domain.\n\n\nSOTA tools:\n\n\\(\\alpha,\\beta\\)-CROWN"
  },
  {
    "objectID": "blogs.html#dafny-blogs",
    "href": "blogs.html#dafny-blogs",
    "title": "Blogs",
    "section": "Dafny Blogs",
    "text": "Dafny Blogs\n\nTwo quantifiers in a specification"
  },
  {
    "objectID": "blogs.html#others",
    "href": "blogs.html#others",
    "title": "Blogs",
    "section": "Others",
    "text": "Others\n\nA brief note about Dataflow Analysis"
  },
  {
    "objectID": "Blogs/ICSE23.html",
    "href": "Blogs/ICSE23.html",
    "title": "Reliability Assurance for Deep Neural Network Architectures Against Numerical Defects",
    "section": "",
    "text": "To assure high reliability against numerical defects, in this paper, we propose the RANUM approach including novel techniques for three reliability assurance tasks: detection of potential numerical defects, confirmation of potential-defect feasibility, and suggestion of defect fixes. To the best of our knowledge, RANUM is the first approach that confirms potential-defect feasibility with failure-exhibiting tests and suggests fixes automatically.\nBut here I will only focus on the detection of potential numerical defects via static analysis."
  },
  {
    "objectID": "Blogs/ICSE23.html#static-analysis-for-potential-defect-detection",
    "href": "Blogs/ICSE23.html#static-analysis-for-potential-defect-detection",
    "title": "Reliability Assurance for Deep Neural Network Architectures Against Numerical Defects",
    "section": "Static Analysis for Potential-Defect Detection",
    "text": "Static Analysis for Potential-Defect Detection\nThe computational graph can be viewed as a Directed Acyclic Graph (DAG): \\(\\mathcal{G} = \\langle\\mathcal{V}, \\mathcal{E} \\rangle\\).\nWe call nodes with zero in-degree as initial nodes, which correspond to input, weight, or constant nodes.\nWe call nodes with positive in-degree as internal nodes, which correspond to concrete operators, such as matrix multiplication (MatMul) and addition (Add).\nWe let \\(\\mathbfit{x}\\) and \\(\\mathbfit{w}\\) denote the concatenation of data from all input nodes and data from all weight nodes, respectively. E.g., in Figure 1, \\(\\mathbfit{x}\\) concatenates data from nodes 1 and 11; and \\(\\mathbfit{w}\\) concatenates data from nodes 2 and 4.\nWe use \\(f_n^{\\textsf{in}}(\\mathbfit{x}; \\mathbfit{w})\\) and \\(f_n^{\\textsf{out}}(\\mathbfit{x}; \\mathbfit{w})\\) to express input and output data of node \\(n\\), respectively, given \\(\\mathbfit{x}\\) and \\(\\mathbfit{w}\\).\ninput_data = tf.placeholder(\"float\", [1, n_features], name='x-input')\ninput_labels = tf.placeholder(\"float\", [1, n_classes], name='y-input')\nself.W_ = tf.Variable(tf.zeros([n_features, n_classes]), name='weights')\nself.b_ = tf.Variable(tf.zeros([n_classes]), name='biases')\nmodel_output = tf.nn.softmax(tf.matmul(input_data, self.W_) + self.b_)\ncost = -tf.reduce_mean(input_labels * tf.log(model_output) +\n                       (1 - input_labels) * tf.log(1 - model_output),\n                       name='cost')\nself.obj_function = tf.reduce_min(tf.abs(model_output), name='obj_function')\n\n\n\n\n\n\nFigure 1: Computational graph encoded by the snippet\n\n\n\nDefinition. For the given computational graph \\(\\mathcal{G} = \\langle\\mathcal{V}, \\mathcal{E} \\rangle\\), if there is a node \\(n_0 \\in \\mathcal{V}\\), such that there exists a valid input and valid weights that can let the input of node \\(n_0\\) fall within the invalid range, we say there is a numerical defect at node \\(n_0\\). Formally, \\(\\exists \\mathbfit{x}_0 \\in \\mathcal{X}_{\\textsf{valid}}, \\mathbfit{w}_0 \\in \\mathcal{W}_{\\textsf{valid}}, f_{n_0}^{\\textsf{in}}(\\mathbfit{x}_0; \\mathbfit{w}_0) \\in \\mathcal{I}_{n_0,\\textsf{invalid}} \\Longrightarrow\\) \\(\\exists\\) numerical defect at node \\(n_0\\).\nFor example, ImageNet Resnet50 models have\n\nvalid input range \\(\\mathcal{X}_{\\textsf{valid}} = [0,1]^{3\\times 224 \\times 224}\\): image pixel intensities are within \\([0,1]\\);\nvalid weight range \\(\\mathcal{W}_{\\textsf{valid}} = [-1,1]^{p}\\): weights of well-trained Resnet50 models are typically within \\([-1,1]\\);\nThe invalid range \\(\\mathcal{I}_{n_0,\\textsf{invalid}}\\): determined by the operator type of node \\(n_0\\). For example, for the Log operator, the invalid range is \\((-\\infty,U_{\\text{min}}]\\), where \\(U_{\\text{min}}\\) is the smallest positive number of a tensor’s data type.\n\n\nDNN Static Analysis Framework with Backward Fine-Grained Node Labeling for Potential-Defect Detection\nA DNN architecture + valid ranges for input and weight nodes \\(\\Rightarrow\\) interval abstractions for possible inputs and outputs of each node.\nFormally, for given valid ranges of inference input and model weights, namely \\(\\mathcal{X}\\) and \\(\\mathcal{W}\\), for each node \\(n \\in \\mathcal{V}\\), our framework computes sound input interval abstraction \\([\\mathbfit{l}_n, \\mathbfit{u}_n] := \\{\\mathbfit{x} : \\mathbfit{l}_n \\leq x \\leq \\mathbfit{u}_n\\}\\) such that \\([\\mathbfit{l}_n,\\mathbfit{u}_n]\\) always captures all possible inputs of the node: \\([\\mathbfit{l}_n,\\mathbfit{u}_n] \\supseteq \\{f_n^{\\textsf{in}}(\\mathbfit{x}, \\mathbfit{w}) : \\mathbfit{x} \\in \\mathcal{X} , \\mathbfit{w} \\in \\mathcal{W}\\}\\). We also compute output interval abstractions similarly.\nThe interval domain with tensor partitioning provides a degree of freedom in terms of the partition granularity, i.e., we can choose the subblock size for each node’s abstraction. When the finest granularity, i.e., elementwise abstraction, is chosen, the abstraction interval is the most concrete. When the coarsest granularity (i.e., one scalar to summarize the node tensor) is chosen, the abstraction saves the most space and computational cost but loses much precision.\nE.g., \\(([−1, 0], [0, 1], [1, 2], [−1, 0])\\):\n\nthe finest granularity, \\([\\mathbfit{l}_n, \\mathbfit{u}_n] = [(−1, 0, 1, −1),(0, 1, 2, 0)]\\).\nthe coarsest granularity, \\([\\mathbfit{l}_n, \\mathbfit{u}_n] = [−1, 2]\\).\n\nUsing the finest instead of the coarsest granularity for some nodes is more beneficial for overall abstraction preciseness.\n\nthe control-flow operators, e.g., Loop\nthe indexing operators, e.g., Slice\nshaping operators, e.g., Reshape"
  },
  {
    "objectID": "Blogs/DataflowAnalysis.html",
    "href": "Blogs/DataflowAnalysis.html",
    "title": "Dataflow Analysis",
    "section": "",
    "text": "Dataflow analysis is a static analysis technique used to gather information about the possible set of values computed at various points in a program, aiding in optimization and error detection."
  },
  {
    "objectID": "Blogs/DataflowAnalysis.html#mathematical-foundations",
    "href": "Blogs/DataflowAnalysis.html#mathematical-foundations",
    "title": "Dataflow Analysis",
    "section": "Mathematical Foundations",
    "text": "Mathematical Foundations\nSemilattice (半格). Semilattice is a structure \\((S, \\sqcup)\\), where \\(S\\) is a set and \\(\\sqcup: S \\times S \\to S\\) is a binary operation on \\(S\\) that is:\n\nidempotent (幂等): \\(x \\sqcup x = x\\);\ncommutative (交换): \\(x \\sqcup y = y \\sqcup x\\);\nassociative (结合): \\(x \\sqcup (y \\sqcup z) = (x \\sqcup y) \\sqcup z\\).\n\nBounded Semilattice (有界半格). A bounded semilattice is a semilattice that has a least element (bottom) \\(\\bot\\) such that for all \\(x \\in S\\), \\(x \\sqcup \\bot = x\\).\nPartial Order (偏序). A partial order is a binary relation \\(\\sqsubseteq\\) over a set \\(S\\) that is:\n\nreflexive (自反): \\(x \\sqsubseteq x\\) for all \\(x \\in S\\);\ntransitive (传递): if \\(x \\sqsubseteq y\\) and \\(y \\sqsubseteq z\\), then \\(x \\sqsubseteq z\\);\nantisymmetric (反对称): if \\(x \\sqsubseteq y\\) and \\(y \\sqsubseteq x\\), then \\(x = y\\).\n\nEvery bounded semilattice \\((S, \\sqcup, \\bot)\\) induces a partial order \\(\\sqsubseteq\\) defined by \\(x \\sqsubseteq y\\) if and only if \\(x \\sqcup y = y\\).\nMonotone (Increasing) Function. A function \\(f: S \\to S\\) is monotone with respect to a partial order \\(\\sqsubseteq\\) if for all \\(x, y \\in S\\), \\(x \\sqsubseteq y\\) implies \\(f(x) \\sqsubseteq f(y)\\).\nFixed Point. A fixed point of a function \\(f: S \\to S\\) is an element \\(x \\in S\\) such that \\(f(x) = x\\).\nFixed Point Theorem. In a bounded semilattice, whose height is finite, every monotone function has a least fixed point, which can be computed as the limit of the ascending chain starting from the least element.\nProof. Let \\((S, \\sqcup, \\bot)\\) be a bounded semilattice with finite height, and let \\(f: S \\to S\\) be a monotone function. We construct an ascending chain starting from \\(\\bot\\): \\[\n    x_0 = \\bot, \\quad x_{n+1} = f(x_n).\n\\]\n\\(\\bot \\sqsubseteq f(\\bot) \\sqsubseteq f(f(\\bot)) \\sqsubseteq \\cdots\\), that is, \\(x_0 \\sqsubseteq x_1 \\sqsubseteq x_2 \\sqsubseteq \\cdots\\). Since the height of the semilattice is finite, this chain must stabilize at some \\(x_k\\) such that \\(x_k = f(x_k)\\). Thus, \\(x_k\\) is a fixed point of \\(f\\). Moreover, it is the least fixed point because any other fixed point \\(y\\) must satisfy \\(\\bot \\sqsubseteq y\\), and by monotonicity, \\(x_n \\sqsubseteq f^n(y) = y\\) for all \\(n\\), leading to \\(x_k \\sqsubseteq y\\). And thus, \\(x_k\\) is the least fixed point of \\(f\\)."
  },
  {
    "objectID": "Blogs/DataflowAnalysis.html#dataflow-analysis-framework",
    "href": "Blogs/DataflowAnalysis.html#dataflow-analysis-framework",
    "title": "Dataflow Analysis",
    "section": "Dataflow Analysis Framework",
    "text": "Dataflow Analysis Framework\n\n\n\\begin{algorithm} \\caption{Dataflow Analysis Framework} \\begin{algorithmic} \\Require A control flow graph (CFG) $G = (V, E)$, a semilattice $(S, \\sqcup, \\bot)$, an initial value of entry node $\\text{OUT}_{\\text{entry}} \\in S$, transfer functions $f_v: S \\to S$ for each node $v \\in V - \\text{entry}$. \\Ensure Dataflow values $\\text{OUT}_v \\in S$ for each node $v \\in V$. \\Procedure{Workflow}{$G, (S, \\sqcup, \\bot), \\text{OUT}_{\\text{entry}}, \\{f_v\\}_{v \\in V - \\text{entry}}$} \\State $\\forall v \\in V - \\text{entry}, \\text{OUT}_v = \\bot$ \\State $\\text{ToVisit} = V - \\text{entry}$ \\While{$\\text{ToVisit} \\neq \\varnothing$} \\State Select and remove a node $v$ from $\\text{ToVisit}$ \\State $\\text{IN}_v = \\bigsqcup_{(u, v) \\in E} \\text{OUT}_u$ \\State $\\text{OUT}_v^{\\text{NEW}} = f_v(\\text{IN}_v)$ \\If{$\\text{OUT}_v^{\\text{NEW}} \\neq \\text{OUT}_v$} \\State $\\text{OUT}_v = \\text{OUT}_v^{\\text{NEW}}$ \\State $\\text{ToVisit} = \\text{ToVisit} \\cup \\{ w \\mid (v, w) \\in E \\}$ \\EndIf \\EndWhile \\EndProcedure \\end{algorithmic} \\end{algorithm}\n\n\n\nConvergence and Safety\nConvergence = Termination + Confluent\n\nTermination\nTermination of Algorithm 1. Suppose \\(\\text{OUT}_v^i\\) is the value of \\(\\text{OUT}_v\\) after the \\(i\\)-th update. Now let’s prove that for each node \\(v\\), the sequence \\(\\{\\text{OUT}_v^i\\}\\) is ascending:\n\nUsing the induction on the number of updates.\nBase case: before any updates, \\(\\text{OUT}_v^0 = \\bot\\). After one update, we must have \\(\\text{OUT}_v^0 \\sqsubseteq \\text{OUT}_v^1\\).\nNow assume after \\(k\\) updates, \\(\\{\\text{OUT}_v^i\\}_{i \\leq k}\\) is ascending for all \\(v\\). Let’s consider the \\((k+1)\\)-th update.\n\nNode \\(v\\) is not selected for update: \\(\\text{OUT}_v^{k+1} = \\text{OUT}_v^k\\). And we must have \\(\\text{OUT}_v^k \\sqsubseteq \\text{OUT}_v^{k+1}\\).\nNode \\(v\\) is selected for update: \\(\\text{OUT}_v^{k+1} = f_v\\left( \\bigsqcup_{(u, v) \\in E} \\text{OUT}_u^k \\right)\\).\n\nIf \\(\\text{OUT}_v^k = \\bot\\), then \\(\\text{OUT}_v^k \\sqsubseteq \\text{OUT}_v^{k+1}\\).\nIf \\(\\text{OUT}_v^k \\neq \\bot\\), then there must be a previous update \\(j &lt; k\\) such that \\(\\text{OUT}_v^k = f_v\\left( \\bigsqcup_{(u, v) \\in E} \\text{OUT}_u^j \\right)\\). By the induction hypothesis, for all \\(u\\) with \\((u, v) \\in E\\), we have \\(\\text{OUT}_u^j \\sqsubseteq \\text{OUT}_u^k\\). By monotonicity of \\(f_v\\) and \\(\\sqcup\\), we have: \\[\n  \\text{OUT}_v^k = f_v\\left( \\bigsqcup_{(u, v) \\in E} \\text{OUT}_u^j \\right) \\sqsubseteq f_v\\left( \\bigsqcup_{(u, v) \\in E} \\text{OUT}_u^k \\right) = \\text{OUT}_v^{k+1}.\n\\]\n\nThus, in both cases, we have \\(\\text{OUT}_v^k \\sqsubseteq \\text{OUT}_v^{k+1}\\).\n\nBy induction, we conclude that for each node \\(v\\), the sequence \\(\\{\\text{OUT}_v^i\\}\\) is ascending.\n\nSince \\((S, \\sqcup, \\bot)\\) has finite height, the ascending sequence \\(\\{\\text{OUT}_v^i\\}\\) must stabilize at some \\(\\text{OUT}_v^*\\). Therefore, Algorithm 1 terminates.\n\n\nConfluent\nWe define the following Round-Robin (轮询) function: \\[\nF(X) = \\left(f_v\\left( \\bigsqcup_{(u, v) \\in E} X(u) \\right) \\right)_{v \\in V},\n\\] where \\(X = (X(v))_{v \\in V} \\in S^{|V|}\\) is a vector of dataflow values for all nodes in the CFG.\n\\(F\\) is monotone because it is composed of monotone functions (the transfer functions \\(f_v\\) and the join operation \\(\\sqcup\\)). By the Fixed Point Theorem, since \\((S, \\sqcup, \\bot)\\) has finite height, \\(F\\) has a least fixed point.\nNow let’s prove \\(F\\) and Algorithm 1 compute the same fixed point → This is called Confluent. That is, no matter how we select nodes for update in Algorithm 1, we always reach the same final dataflow values.\n\nThe main difference is that Algorithm 1 updates nodes one at a time, while \\(F\\) updates all nodes simultaneously.\n\nLet \\(X_i = (\\text{OUT}_v^i)_{v \\in V}\\) be the vector of dataflow values after the \\(i\\)-th update. \\(Y_i = F^i(\\text{OUT}_{\\text{entry}}, \\bot, \\ldots, \\bot)\\). And we want to prove that for all \\(i\\), \\(X_i \\sqsubseteq Y_i\\).\n\nUsing induction on \\(i\\).\nBase case: \\(i = 0\\), \\(X_0 = (\\text{OUT}_{\\text{entry}}, \\bot, \\ldots, \\bot) = Y_0\\).\nNow assume \\(X_k \\sqsubseteq Y_k\\) for some \\(k \\geq 0\\). Let’s consider the \\((k+1)\\)-th update.\n\nSuppose node \\(v\\) is selected for update. Then: \\[\n    \\text{OUT}_v^{k+1} = f_v\\left( \\bigsqcup_{(u, v) \\in E} \\text{OUT}_u^k \\right) = f_v\\left( \\bigsqcup_{(u, v) \\in E} X_k(u) \\right).\n\\] By the induction hypothesis, for all \\(u\\) with \\((u, v) \\in E\\), we have \\(X_k(u) \\sqsubseteq Y_k(u)\\). By monotonicity of \\(f_v\\) and \\(\\sqcup\\), we have: \\[\n    \\text{OUT}_v^{k+1} = f_v\\left( \\bigsqcup_{(u, v) \\in E} X_k(u) \\right) \\sqsubseteq f_v\\left( \\bigsqcup_{(u, v) \\in E} Y_k(u) \\right) = Y_{k+1}(v).\n\\]\nFor nodes not selected for update, \\(\\text{OUT}_w^{k+1} = \\text{OUT}_w^k \\sqsubseteq Y_k(w) \\sqsubseteq Y_{k+1}(w)\\).\nThus, in both cases, we have \\(X_{k+1} \\sqsubseteq Y_{k+1}\\).\n\nBy induction, we conclude that for all \\(i\\), \\(X_i \\sqsubseteq Y_i\\).\n\nSuppose Algorithm 1 terminates at iteration \\(N\\), then \\(X_N\\) is a fixed point of \\(F\\) (You can simply check and find \\(F(X_N) = X_N\\)). Since \\(X_N \\sqsubseteq Y_N\\) for all \\(N\\), and \\(Y_N\\) converges to the least fixed point of \\(F\\), we conclude that \\(X_N\\) is the least fixed point of \\(F\\).\nConclusively, Algorithm 1 computes the least fixed point of the Round-Robin function \\(F\\).\n\n\nSafety\nSafety. We will state the safety property using abstract interpretation. Let \\(C\\) be the concrete domain of program states, and let \\(\\alpha: C \\to S\\) be the abstraction function mapping concrete states to abstract states in the semilattice \\(S\\). We say that the dataflow analysis is safe if for every program point \\(v\\) and every concrete state \\(c\\) reachable at \\(v\\), the abstract value \\(\\text{OUT}_v\\) computed by the analysis satisfies:\n\\[\n    \\alpha(c) \\sqsubseteq \\text{OUT}_v.\n\\]\nThis means that the abstract value \\(\\text{OUT}_v\\) over-approximates all possible concrete states at that program point, ensuring that no concrete behavior is missed by the analysis.\nSince \\(f_v\\) are designed to be sound abstractions of the concrete semantics, and the join operation \\(\\sqcup\\) combines information from all predecessors, the dataflow analysis framework guarantees that the computed abstract values are safe with respect to the concrete program semantics."
  },
  {
    "objectID": "Blogs/DataflowAnalysis.html#examples-of-dataflow-analyses",
    "href": "Blogs/DataflowAnalysis.html#examples-of-dataflow-analyses",
    "title": "Dataflow Analysis",
    "section": "Examples of Dataflow Analyses",
    "text": "Examples of Dataflow Analyses\n\nSign Analysis\nWe define a lattice of signs: \\[\n  \\text{Sign} = \\{ \\bot, -, 0, +, \\top\\}.\n\\]\nLet \\(\\text{Var}\\) be the set of variables occurring in the given program. The semilattice for sign analysis is defined as: \\[\n    S = \\text{Var} \\to \\text{Sign},\n\\]\nThe abstract interpretation of this lattice is as follows:\n\nThe concrete domain \\(C\\) is \\(\\text{Var} \\to \\mathbb{Z}\\), mapping variables to integer values.\nThe abstraction function \\(\\alpha: C \\to S\\) is defined by: \\[\n  \\alpha(c)(x) = \\begin{cases}\n    - & \\text{if } c(x) &lt; 0 \\\\\n    0 & \\text{if } c(x) = 0 \\\\\n    + & \\text{if } c(x) &gt; 0\n  \\end{cases}\n\\]\nThe concretization function \\(\\gamma: S \\to 2^C\\) is defined by: \\[\n  \\gamma(s) = \\{ c \\in C \\mid \\forall x \\in \\text{Var}, c(x) \\text{ matches } s(x) \\}\n\\]\n\nThe transfer functions: \\[\n  f_v(s) = \\begin{cases}\n   x := e & \\text{update } s \\text{ based on the sign of } e \\\\\n   ...\n  \\end{cases}\n\\]\nThe join operation \\(\\sqcup\\) is defined pointwise: \\[\n    (s_1 \\sqcup s_2)(x) = \\text{join\\_sign}(s_1(x), s_2(x)),\n\\]\n\n\nReaching Definitions Analysis\nFor every program point, we want to determine which definitions may reach that point.\nExample:\n1. a = 100;     // [a -&gt; 1]\n2. if (c &gt; 0)   // [a -&gt; 1]\n3.   a = 200;   // [a -&gt; 3]\n4.   b = a;     // [b -&gt; 4]\n5. return a;    // [a -&gt; {1, 3}, b -&gt; 4]\nThe semilattice for reaching definitions analysis is defined as: \\[\n    S = \\text{Var} \\to 2^{\\text{Def}},\n\\] which is the mapping from variables to the set of definitions that may reach that variable.\nThe initial value for each variable is the empty set: \\[\n    \\bot(x) = \\varnothing,\n\\] and the initial value for the entry node is also the empty set for all variables.\nThe join operation \\(\\sqcup\\) is defined pointwise as the union of sets: \\[\n    (s_1 \\sqcup s_2)(x) = s_1(x) \\cup s_2(x).\n\\]\nThe transfer functions are defined as follows: \\[\n    f_v(s)(x) = (s(x) - \\text{KILL}_v(x)) \\cup \\text{GEN}_v(x),\n\\tag{1}\\]\n\nfor an assignment statement \\(x := e\\) at node \\(v\\):\n\n\\(\\text{KILL}_v(x)\\) is the set of all definitions of \\(x\\) in the program (since the new definition at \\(v\\) kills all previous definitions of \\(x\\)).\n\\(\\text{GEN}_v(x) = \\{ v \\}\\), representing the new definition of \\(x\\) at node \\(v\\).\n\nfor other statements, \\(\\text{KILL}_v(x) = \\varnothing\\) and \\(\\text{GEN}_v(x) = \\varnothing\\) for all variables \\(x\\).\n\nEquation 1 is the standard way to define transfer functions for dataflow analysis.\n\n\nAvailable Expressions Analysis\nFor every program point, we want to determine the expressions that have already been computed and whose values are still available. E.g., \\(a+b\\) is available at a program point if on every path from the entry to that point, \\(a+b\\) has been computed and neither \\(a\\) nor \\(b\\) has been modified since then.\nExample:\n1. a = c + (b + 10); // 1 end: {b + 10, c + (b + 10)}\n2. if (a &gt; b)        // 2 end: {b + 10, c + (b + 10), a &gt; b}\n3.   c = a + 10;     // 3 end: {b + 10, a + 10, a &gt; b}\n4. return a;         // 4 end: {b + 10, a &gt; b}\nThe semilattice for available expressions analysis is \\(2^\\text{Expr}\\), which is the set of all expressions in the program.\nThe initial value for each variable is the set of all expressions, and the initial value for the entry node is the empty set.\nAnd the join operation \\(\\sqcup\\) is defined as the intersection of sets: \\[\n    (s_1 \\sqcup s_2) = s_1 \\cap s_2.\n\\]\nThe transfer functions are defined as follows: \\[\n    f_v(s) = (s - \\text{KILL}_v) \\cup \\text{GEN}_v,\n\\]\n\nfor an assignment statement \\(x := e\\) at node \\(v\\):\n\n\\(\\text{KILL}_v\\) is the set of all expressions that contain the variable \\(x\\) (since assigning to \\(x\\) may change the value of these expressions).\n\\(\\text{GEN}_v = \\{ e \\}\\), representing the expression computed at node \\(v\\).\n\nfor other statements, \\(\\text{KILL}_v = \\varnothing\\) and \\(\\text{GEN}_v =\\) the expression computed at node \\(v\\).\n\n\n\nLiveness Analysis\nWe want to determine, for every program point, which variables may be used in the future before being redefined.\n\nThe semilattice: \\(S = 2^{\\text{Var}}\\).\nHere we must revert the control flow graph (CFG) edges, so that the analysis proceeds backward from the exit to the entry.\nThe initial value for each variable is the empty set, and the initial value for the exit node is also the empty set.\nThe join operation \\(\\sqcup\\) is defined as the union of sets.\nThe transfer functions:\n\n\\(\\text{GEN}_v\\) is the set of variables used in node \\(v\\).\n\\(\\text{KILL}_v\\) is the set of variables defined (or assigned) in node \\(v\\).\n\n\n\n\nVery Busy Expressions Analysis\nFor every program point, we want to determine the expressions that will be computed on every path from that point to the exit, before any of their operands are redefined.\nExample:\n1. if (a &gt; b)  // Here, {b - a, a + b, a &gt; b} are very busy\n2.   x = b - a\n3.   y = x - y + (a + b + b)\n4. else\n5.   y = b - a\n6.   x = x - y + (a + b)\n\nThe semilattice: \\(S = 2^{\\text{Expr}}\\).\nThe analysis proceeds backward from the exit to the entry.\nThe initial value for each variable is the emptyset, and the initial value for the exit node is also the emptyset.\nThe join operation \\(\\sqcup\\) is defined as the intersection of sets.\nThe transfer functions:\n\n\\(\\text{GEN}_v\\) is the set of expressions computed in node \\(v\\).\n\\(\\text{KILL}_v\\) is the set of expressions that contain any variable defined (or assigned) in node \\(v\\).\n\n\n\n\n\nThe Analysis Result of the Example\n\n\n\n\nConstant Propagation Analysis\nFor every program point, we want to determine the variables that have a constant value.\nExample:\nvar x, y, z;\nx = 27;\ny = input;\nz = 2 * x + y;\nif (x &lt; 0) { y = z - 3; } else { y = 12; }\noutput y;\n\nThe semilattice: \\(S = \\text{Var} \\to (\\mathbb{Z} \\cup \\{\\bot, \\top\\})\\). \\(\\bot\\) represents “not a constant” and \\(\\top\\) represents “undefined”.\nThe initial value for each variable is \\(\\bot\\), and the initial value for the entry node is also \\(\\bot\\) for all variables.\nThe join operation \\(\\sqcup\\) is defined as follows: \\[\n  (s_1 \\sqcup s_2)(x) = \\begin{cases}\n    \\bot & \\text{if } s_1(x) = \\bot \\text{ or } s_2(x) = \\bot \\\\\n    c & \\text{if } s_1(x) = s_2(x) = c \\in \\mathbb{Z} \\\\\n    \\bot & \\text{if } s_1(x) \\neq s_2(x) \\\\\n    s_1(x) & \\text{if } s_2(x) = \\top \\\\\n    s_2(x) & \\text{if } s_1(x) = \\top\n  \\end{cases}\n\\]\nThe transfer functions are defined based on the operations in the program, propagating constant values and updating variables accordingly."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hello, this is VectorPikachu, or Hangzhou Lyu (吕杭州, lǚ háng zhōu). Currently I’m a student majored in Software Engineering. And my research interest lies on Program Verification, including Dafny, Coq, Verus, et.al."
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "About",
    "section": "Education",
    "text": "Education\n\nPeking University | Beijing, China  B.Eng. in Software Engineering | Sept 2022 - June 2026  北京大学 | 中国北京  软件工程 | 2022 年 9 月 - 2026 年 6 月\nPeking University | Beijing, China  B.S. in Economics (Dual Degree Program in National School of Development, NSD) | Sept 2023 - June 2026  北京大学 | 中国北京  经济学 (国发院双学位) | 2023 年 9 月 - 2026 年 6 月"
  },
  {
    "objectID": "about.html#certificates",
    "href": "about.html#certificates",
    "title": "About",
    "section": "Certificates",
    "text": "Certificates\n\nCollege English Test Band4, CET4 | 671  大学英语四级考试 | 671\nCollege English Test Band6, CET6 | 650  大学英语六级考试 | 650"
  },
  {
    "objectID": "about.html#awards",
    "href": "about.html#awards",
    "title": "About",
    "section": "Awards",
    "text": "Awards\n\n2025 CCF ChinaSoft Theorem Proving Contest | Third Prize  2025中国软件大会定理证明竞赛 | 三等奖"
  },
  {
    "objectID": "Blogs/Dafny_two_quantifiers.html",
    "href": "Blogs/Dafny_two_quantifiers.html",
    "title": "Two quantifiers in a specification",
    "section": "",
    "text": "Let’s consider a Dafny lemma that involves two quantifiers in its specification. For example, we want to prove the following lemma:\nIn both test1 and test2, Dafny fails to prove the lemmas because it cannot find appropriate triggers for the quantifiers."
  },
  {
    "objectID": "Blogs/Dafny_two_quantifiers.html#and-what-is-a-trigger",
    "href": "Blogs/Dafny_two_quantifiers.html#and-what-is-a-trigger",
    "title": "Two quantifiers in a specification",
    "section": "And what is a trigger?",
    "text": "And what is a trigger?\nSee Dafny Reference Manual on {:trigger}.\n\nTrigger attributes are used on quantifiers and comprehensions.\nThe verifier instantiates the body of a quantified expression only when it can find an expression that matches the provided trigger.\n\npredicate P(i: int)\npredicate Q(i: int)\n\nlemma {:axiom} PHoldEvenly()\n  ensures  forall i {:trigger Q(i)} :: P(i) ==&gt; P(i + 2) && Q(i)\n\nlemma PHoldsForTwo()\n  ensures forall i :: P(i) ==&gt; P(i + 4)\n{\n  forall j: int\n    ensures P(j) ==&gt; P(j + 4)\n  {\n    if P(j) {\n      assert P(j); // Trivial assertion\n      \n      PHoldEvenly();\n      // Invoking the lemma assumes `forall i :: P(i) ==&gt; P(i + 4)`,\n      // but it's not instantiated yet\n      \n      // The verifier sees `Q(j)`, so it instantiates\n      // `forall i :: P(i) ==&gt; P(i + 4)` with `j`\n      // and we get the axiom `P(j) ==&gt; P(j + 2) && Q(j)`\n      assert Q(j);     // hence it can prove `Q(j)`\n      assert P(j + 2); //   and it can prove `P(j + 2)`\n      assert P(j + 4); // But it cannot prove this\n      // because it did not instantiate `forall i :: P(i) ==&gt; P(i + 4)` with `j+2`\n    }\n  }\n}\nHere are ways one can prove assert P(j + 4);:\n\nAdd assert Q(j + 2); just before assert P(j + 4);, so that the verifier sees the trigger.\nChange the trigger {:trigger Q(i)} to {:trigger P(i)} (replace the trigger).\nChange the trigger {:trigger Q(i)} to {:trigger Q(i)} {:trigger P(i)} (add a trigger).\nRemove {:trigger Q(i)} so that it will automatically determine all possible triggers thanks to the option /autoTriggers:1 which is the default."
  },
  {
    "objectID": "Blogs/Dafny_two_quantifiers.html#nested-loops",
    "href": "Blogs/Dafny_two_quantifiers.html#nested-loops",
    "title": "Two quantifiers in a specification",
    "section": "Nested loops",
    "text": "Nested loops\nSee Dafny Reference Manual on Nested loops.\nIn the case of nested loops, the verifier might timeout sometimes because of inadequate or too much available information. One way to mitigate this problem, when it happens, is to isolate the inner loop by refactoring it into a separate method, with suitable pre and postconditions that will usually assume and prove the invariant again. For example,\nwhile X\n  invariant Y\n{\n    while X'\n      invariant Y'\n    {\n\n    }\n}\ncould be refactored as this:\nwhile X\n   invariant Y\n {\n   innerLoop();\n }\n...\nmethod innerLoop()\n  require Y'\n  ensures Y'"
  },
  {
    "objectID": "Blogs/Dafny_two_quantifiers.html#my-findings",
    "href": "Blogs/Dafny_two_quantifiers.html#my-findings",
    "title": "Two quantifiers in a specification",
    "section": "My findings",
    "text": "My findings\nI think the main issue can be the Skolemization of the quantifiers.\nSkolemization: \\(\\forall x \\exists y R(x,y) \\Leftrightarrow \\forall x R(x,f(x))\\), here \\(f\\) is a Skolem function.\nIn test1, after Skolemization:\n\nthe requirement becomes: \\(\\forall x P(a, x, f(x))\\).\nthe ensures becomes: \\(\\forall x P(a, x, g(x))\\).\nDafny cannot find the relation between f and g, so it cannot prove the lemma.\n\nIn test2, after Skolemization:\n\nthe requirement becomes: \\(P(a, h, y)\\).\nthe ensures becomes: \\(P(a, k, y)\\).\nSimilarly, Dafny cannot find the relation between h and k, so it cannot prove the lemma.\n\nAnd based on this understanding, I tried to prove two quantifers of \\(\\forall x \\forall y\\) and \\(\\exists x \\exists y\\), and Dafny can prove them successfully.\nlemma test1(a: seq&lt;int&gt;)\n    requires forall x :: (forall y :: P(a, x, y))\n    ensures forall x :: (forall y :: P(a, x, y))\n{\n    // proved\n}\n\nlemma test2(a: seq&lt;int&gt;)\n    requires exists x :: (exists y :: P(a, x, y))\n    ensures exists x :: (exists y :: P(a, x, y))\n{\n    // proved\n}"
  },
  {
    "objectID": "Blogs/FSE20.html",
    "href": "Blogs/FSE20.html",
    "title": "Detecting numerical bugs in neural network architectures",
    "section": "",
    "text": "This paper makes the first attempt to conduct static analysis for detecting numerical bugs at the architecture level."
  },
  {
    "objectID": "Blogs/FSE20.html#introduction",
    "href": "Blogs/FSE20.html#introduction",
    "title": "Detecting numerical bugs in neural network architectures",
    "section": "Introduction",
    "text": "Introduction\nA neural architecture can contain numerical bugs that cause serious consequences. Numerical bugs in a neural architecture manifest themselves as numerical errors in the form of “NaN”, “INF”, or crashes during training or inference.\n# Input:\n# center: 2*100 - shape tensor whose elements in [-1, 1]\n# offset : 2*100 - shape tensor whose elements in [0, 2]\n\n# Create 100 rectangles .\nbottomLeft = center - offset\ntopRight = center + offset\nrectangle = tf.concat([bottomLeft, topRight], axis=1)\n\n# Calculate the reciprocal of their areas.\nbottom, left, top, right = tf.split(rectangle, num_or_size_splits=4, axis=1)\nwidth = right - left\nheight = top - bottom\narea = width * height\nscale = tf.reciprocal(area)\nThe key insight is that affine relations are common in neural network architectures.\n\nBasics of Abstract Interpretation\nConcrete properties are described in the concrete domain \\(\\mathbb{C}\\) with a partial order \\(\\subseteq\\), and abstract properties are described in the abstract domain \\(\\mathbb{A}\\) with a partial order \\(\\sqsubseteq\\).\n\nAbstraction function \\(\\alpha: \\mathbb{C} \\rightarrow \\mathbb{A}\\)\nConcretization function \\(\\gamma: \\mathbb{A} \\rightarrow \\mathbb{C}\\)\n\nGalois connection \\(\\langle\\mathbb{C},\\subseteq\\rangle \\overset{\\gamma}{\\underset{\\alpha}{\\leftrightarrows}} \\langle\\mathbb{A},\\sqsubseteq\\rangle\\): \\[\n\\forall c \\in \\mathbb{C}, a \\in \\mathbb{A}. \\alpha(c) \\sqsubseteq a \\Leftrightarrow c \\subseteq \\gamma(a)\n\\]\n\n\nAbstract Domain of Intervals\n\\[\n\\mathbb{A}_I \\triangleq \\{([l_1,u_1],...,[l_n,u_n] | l,u \\in \\mathbb{R}^n)\\}\n\\] Here \\(x \\in \\mathbb{A}_I \\Rightarrow l_i \\leq x_i \\leq u_i\\).\nAlso, we say \\(a_1 \\sqsubseteq a_2\\) iff \\(\\forall i. [l_i^1,u_i^1] \\subseteq [l_i^2,u_i^2]\\).\nAnd the abstraction functions are defined as: \\[\n\\alpha_I(c) = ([\\inf\\{x_i | x \\in c\\}, \\sup\\{x_i | x \\in c\\}])_{i=1}^n\n\\] That is, the abstraction function maps a concrete set to the smallest interval containing it.\nThe concretization function is defined as: \\[\n\\gamma_I(a) = \\{x \\in \\mathbb{R}^n | \\forall i. l_i^a \\leq x_i \\leq u_i^a\\}\n\\]\n\n\nAbstract Domain of Affine Relations\n\\[\n\\mathbb{A}_E \\triangleq \\{(\\mathbf{A},b)|\\mathbb{A} \\in \\mathbb{R}^{m \\times n}, b \\in \\mathbb{R}^m, m&gt;0\\}\n\\]\nHere \\(x \\in \\mathbb{A}_E \\Rightarrow \\mathbf{A}x = b\\).\nAnd the abstraction functions are defined as:\n\\[\n\\alpha_E(c) = \\begin{cases}\n(\\mathbf{A},b) & \\text{if } c \\subseteq \\{x | \\mathbf{A}x = b\\} \\text{ and } (\\mathbf{A},b) \\text{ is in reduced echelon form}\\\\\n\\top & \\text{if } c = \\mathbb{R}^n\\\\\n\\bot & \\text{otherwise}\n\\end{cases}\n\\]\nThe concretization function is defined as:\n\\[\n\\gamma_E(a) = \\{x \\in \\mathbb{R}^n | \\mathbf{A}x = b\\},\n\\] here \\(a = (\\mathbf{A},b)\\).\n\n\nAbstract Domain for Neural Architectures\nThe abstract domain for Tensor partitioning and Interval abstraction with affine Equality relation \\(\\mathbb{A}_{\\text{TIE}}\\) is defined as: \\[\n\\mathbb{A}_{\\text{TIE}} \\triangleq \\{(\\mathcal{P}, a^{\\sharp I}, a^{\\sharp E})|a^{\\sharp I} \\in \\mathbb{A}_I, a^{\\sharp E}\\in\\mathbb{A}_E\\},\n\\] where \\(\\mathcal{P} = \\{A_1,A_2,...,A_n\\}\\) is a tensor partitioning.\nThe concretization function \\(\\gamma_{\\text{TIE}}\\) of an element \\(a^\\sharp = (\\mathcal{P}, a^{\\sharp I}, a^{\\sharp E})\\) is defined as: \\[\n\\gamma_{\\text{TIE}}(a^\\sharp) = \\gamma_I(a^{\\sharp I}) \\cap \\gamma_E(a^{\\sharp E})\n\\]\nNotes for ReLU:\n\nCreate a new symbolic variable \\(b\\) for \\(a\\).\nAnd we have \\(b - a^{\\text{ReLU}} = 0\\).\n\\(a^{\\text{ReLU}} - a^{-\\text{ReLU}} - a =0\\)."
  },
  {
    "objectID": "Blogs/TPC-1.html",
    "href": "Blogs/TPC-1.html",
    "title": "第一届定理证明竞赛",
    "section": "",
    "text": "2025 年 11 月 29 日 下午 12:30 - 17:30, 中国软件大会会场 (武汉国际会议中心).\nCoq.8.20.1, with VST.2.15"
  },
  {
    "objectID": "Blogs/TPC-1.html#谓词与互归纳证明",
    "href": "Blogs/TPC-1.html#谓词与互归纳证明",
    "title": "第一届定理证明竞赛",
    "section": "1 谓词与互归纳证明",
    "text": "1 谓词与互归纳证明\n给定谓词 P、Q、R，以及如下互归纳定义的谓词A、B。\n\nCoq: Inductive A xxx with B xxx\na_ind, b_ind\n\n（50 分）试证明定理 neg_a，提示：根据 A 或 B 的互归纳原理。\nFrom Coq Require Import List Lia.\nImport ListNotations.\nSection ProblemA. \n          \nParameter P: nat -&gt; Prop.\nParameter Q: nat -&gt; Prop.\nParameter R: nat -&gt; nat -&gt; Prop. \n\nInductive A : nat -&gt; Prop :=\n  ca0: forall n, P n -&gt; A n\n| ca1: forall n1, (forall n2, R n1 n2 -&gt; B n2) -&gt; A n1\nwith B: nat -&gt; Prop :=\n  cb0: forall n, Q n -&gt; B n\n| cb1: forall n1 n2, R n1 n2 -&gt; A n2 -&gt; B n1. \n\nScheme a_ind := Induction for A Sort Prop \n  with b_ind := Induction for B Sort Prop.\n\nTheorem neg_a:\n  (forall n, ~P n /\\ ~Q n) -&gt;\n  (forall n1, exists n2, R n1 n2) -&gt; \n  (forall n, A n -&gt; False).\nProof.\nintros HnPQ HR.\napply a_ind with (fun (n : nat) (_ : B n) =&gt; False).\n- intros. specialize (HnPQ n). destruct HnPQ.\n  apply H; assumption.\n- intros. specialize (HR n1). destruct HR as [n2 HR].\n  specialize (H n2 HR). assumption.\n- intros. specialize (HnPQ n). destruct HnPQ.\n  apply H0; assumption.\n- intros. assumption.\nQed.\n\nEnd ProblemA."
  },
  {
    "objectID": "Course_Notes/数理逻辑/数理逻辑.html",
    "href": "Course_Notes/数理逻辑/数理逻辑.html",
    "title": "数理逻辑",
    "section": "",
    "text": "形式系统包括两部分: 表述命题的形式语言, 由形式语言表述的公理和推理规则."
  },
  {
    "objectID": "Course_Notes/数理逻辑/数理逻辑.html#命题逻辑",
    "href": "Course_Notes/数理逻辑/数理逻辑.html#命题逻辑",
    "title": "数理逻辑",
    "section": "",
    "text": "形式系统包括两部分: 表述命题的形式语言, 由形式语言表述的公理和推理规则."
  },
  {
    "objectID": "Course_Notes/数理逻辑/数理逻辑.html#一阶谓词演算",
    "href": "Course_Notes/数理逻辑/数理逻辑.html#一阶谓词演算",
    "title": "数理逻辑",
    "section": "2 一阶谓词演算",
    "text": "2 一阶谓词演算\n接下来我们要建立谓词演算的两个形式系统 \\(N_{\\mathcal{L}}\\) 和 \\(P_{\\mathcal{L}}\\), 它们分别对应于命题演算的形式系统 \\(N\\) 和 \\(P\\).\n要讨论形式系统, 就是要讨论:\n\n形式语言\n公理和推理规则\n\n\n2.1 一阶语言\n而谓词演算系统的形式语言即为一阶语言. 它包括:\n\n符号库\n\n非逻辑符号\n\n个体常元符号: \\(c, c_1,c_2,\\ldots\\)\n谓词符号: \\(F^n, G^n, \\ldots\\). \\(n\\) 为谓词符号的元数.\n函数符号: \\(f^n, g^n, \\ldots\\). \\(n\\) 为函数符号的元数.\n\n由一些非逻辑符号作为元素组成的集合通常记为 \\(\\mathcal{L}\\).  一阶语言与符号库指定的非逻辑符号 \\(\\mathcal{L}\\) 有关, 称为 \\(\\mathcal{L}\\) 生成的一阶语言.\n逻辑符号\n\n个体变元符号: \\(x_0, x_1, x_2, \\ldots\\)\n联结词符号: \\(\\neg, \\land, \\lor, \\to, \\leftrightarrow\\)\n量词符号: \\(\\forall, \\exists\\)\n辅助符号: \\(), , , (\\)\n\n\n谓词公式\n\n项: \\(\\mathcal{L}\\) 生成的一阶语言中的“项”归纳定义如下:\n\n个体变元符号和 \\(\\mathcal{L}\\) 中的个体常元符号都是 \\(\\mathcal{L}\\) 的项;\n若 \\(f^n\\) 是 \\(\\mathcal{L}\\) 中的一个 \\(n\\) 元函数符号, 且 \\(t_1, t_2, \\ldots, t_n\\) 都是 \\(\\mathcal{L}\\) 的项, 则 \\(f^n(t_1, t_2, \\ldots, t_n)\\) 也是 \\(\\mathcal{L}\\) 的项;\n\\(\\mathcal{L}\\) 中的每个项都是有限次应用上述两条所定义的构造规则得到的.\n\n公式: \\(\\mathcal{L}\\) 生成的一阶语言中的“公式”归纳定义如下:\n\n(原子公式) 若 \\(F^n\\) 是 \\(\\mathcal{L}\\) 中的一个 \\(n\\) 元谓词符号, 且 \\(t_1, t_2, \\ldots, t_n\\) 都是 \\(\\mathcal{L}\\) 的项, 则 \\(F^n(t_1, t_2, \\ldots, t_n)\\) 是 \\(\\mathcal{L}\\) 的一个公式;\n若 \\(\\alpha\\) 是 \\(\\mathcal{L}\\) 的一个公式, 则 \\(\\neg \\alpha\\) 也是 \\(\\mathcal{L}\\) 的一个公式;\n若 \\(\\alpha\\) 和 \\(\\beta\\) 都是 \\(\\mathcal{L}\\) 的公式, 则 \\((\\alpha \\land \\beta), (\\alpha \\lor \\beta), (\\alpha \\to \\beta), (\\alpha \\leftrightarrow \\beta)\\) 都是 \\(\\mathcal{L}\\) 的公式;\n若 \\(\\alpha\\) 是 \\(\\mathcal{L}\\) 的一个公式, 且 \\(x\\) 是个体变元符号, 则 \\((\\forall x) \\alpha\\) 和 \\((\\exists x) \\alpha\\) 都是 \\(\\mathcal{L}\\) 的公式;\n\\(\\mathcal{L}\\) 中的每个公式都是有限次应用上述四条所定义的构造规则得到的.\n\n\n\n\n\n\n\n\n\nNote辖域\n\n\n\n称公式 \\((\\forall x) \\alpha\\) 中的 \\(\\alpha\\) 为量词 \\((\\forall x)\\) 的辖域; 同理, 公式 \\((\\exists x) \\alpha\\) 中的 \\(\\alpha\\) 也为量词 \\((\\exists x)\\) 的辖域.\n\n\n\n\n\n\n\n\nNote约束出现与自由出现\n\n\n\n变元符号 \\(x\\) 在公式 \\(\\alpha\\) 中的某处出现被称为约束出现, 如果该变元出现在某个量词 \\((\\forall x)\\) 或 \\((\\exists x)\\) 的辖域内, 或者是 \\((\\forall x)\\) 中的 \\(x\\), 或者是 \\((\\exists x)\\) 中的 \\(x\\); 否则称为自由出现.\n\n\n\n\n\n\n\n\nNote约束变元与自由变元\n\n\n\n设个体变元 \\(x\\) 在公式 \\(\\alpha\\) 中所有出现都是约束出现, 则称 \\(x\\) 为 \\(\\alpha\\) 的约束变元; 反之, 若 \\(x\\) 在 \\(\\alpha\\) 中有自由出现, 则称 \\(x\\) 为 \\(\\alpha\\) 的自由变元.\n\n\n\n\n\n\n\n\nNote\\(t\\) 对 \\(x\\) 在 \\(\\alpha\\) 中可代入\n\n\n\n设 \\(\\alpha\\) 是 \\(\\mathcal{L}\\) 中的公式, \\(t\\) 是 \\(\\mathcal{L}\\) 中的项, 且 \\(x\\) 是 \\(\\mathcal{L}\\) 中的个体变元符号. 如果对 \\(t\\) 中每个出现的变元符号 \\(y\\), \\(\\alpha\\) 中每处自由出现的 \\(x\\) 都不在某个量词 \\((\\forall y)\\) 或 \\((\\exists y)\\) 的辖域内, 则称 \\(t\\) 对 \\(x\\) 在 \\(\\alpha\\) 中可代入 或 \\(t\\) 对 \\(x\\) 在 \\(\\alpha\\) 中自由.\nps: 这句话就是说, 把公式 \\(\\alpha\\) 中的 \\(x\\) 全部替换成项 \\(t\\) 后, 不会导致 \\(\\alpha\\) 的真假值改变.\n\n\n\\(\\alpha(x/t)\\) 是将 \\(\\alpha\\) 中的每个自由出现的 \\(x\\) 都替换成项 \\(t\\) 所得到的公式 (不论 \\(t\\) 是否对 \\(x\\) 在 \\(\\alpha\\) 中自由), 这称为 \\(\\alpha\\) 的一个例式.\n简单的性质:\n\n\\(x\\) 对 \\(x\\) 在任一公式 \\(\\alpha\\) 中自由.\n若 \\(x\\) 不在 \\(\\alpha\\) 中自由出现, 则 \\(t\\) 对 \\(x\\) 在 \\(\\alpha\\) 中自由.\n若 \\(t\\) 对 \\(x\\) 在 \\(\\alpha\\) 中自由, 则 \\(\\alpha\\) 与 \\(\\alpha(x/t)\\) 的“可满足性”差别不大.\n\n\n\n\n\n\n\nNote闭公式 (closed formula)\n\n\n\n\n若 \\(\\mathcal{L}\\) 的项 \\(t\\) 中不含任何个体变元符号, 则称 \\(t\\) 为 \\(\\mathcal{L}\\) 的一个闭项;\n若 \\(\\mathcal{L}\\) 的公式 \\(\\alpha\\) 中不含任何自由变元符号, 则称 \\(\\alpha\\) 为 \\(\\mathcal{L}\\) 的一个闭公式.\n\n\n\n\n\n2.2 一阶谓词演算自然推演系统 \\(N_{\\mathcal{L}}\\)\n现在给定了形式语言 (\\(\\mathcal{L}\\) 生成的一阶语言), \\(N_{\\mathcal{L}}\\) 的形式推理为:\n\n形式公理: \\(\\varnothing\\)\n形式规则: 15 条\n\n(1)-(10): 与命题演算自然推演系统 \\(N\\) 的规则相同.\n增加前提率: 若 \\(\\Gamma \\vdash \\alpha\\), 则 \\(\\Gamma, \\beta \\vdash \\alpha\\). \\((+)\\)\n\\(\\forall\\) 消去律: 若 \\(\\Gamma \\vdash \\forall x \\alpha\\), 且 \\(t\\) 对 \\(x\\) 在 \\(\\alpha\\) 中自由, 则 \\(\\Gamma \\vdash \\alpha(x/t)\\). \\((\\forall -)\\)\n\\(\\forall\\) 引入律: 若 \\(\\Gamma \\vdash \\alpha\\), 且 \\(x\\) 不在 \\(\\Gamma\\) 的任何公式中自由出现, 则 \\(\\Gamma \\vdash \\forall x \\alpha\\). \\((\\forall +)\\)\n\\(\\exists\\) 消去律: 若 \\(\\Gamma, \\alpha \\vdash \\beta\\), 且 \\(x\\) 不在 \\(\\Gamma \\cup \\{\\beta\\}\\) 的任何公式中自由出现, 则 \\(\\Gamma, \\exists x \\alpha \\vdash \\beta\\). \\((\\exists -)\\)\n\\(\\exists\\) 引入律: 若 \\(\\Gamma \\vdash \\alpha(x/t)\\), 且 \\(t\\) 对 \\(x\\) 在 \\(\\alpha\\) 中自由, 则 \\(\\Gamma \\vdash \\exists x \\alpha\\). \\((\\exists +)\\)\n\n\n两个特例: \\(\\alpha(x/x)=\\alpha\\), 且 \\(x\\) 对 \\(x\\) 在 \\(\\alpha\\) 中自由.\n\n若 \\(\\Gamma \\vdash \\forall x \\alpha\\), 则 \\(\\Gamma \\vdash \\alpha\\). \\((\\forall -)\\)\n若 \\(\\Gamma \\vdash \\alpha\\), 则 \\(\\Gamma \\vdash \\exists x \\alpha\\). \\((\\exists +)\\)\n\n\n\n\n\n\n\nNote\\(N_{\\mathcal{L}}\\) 的形式证明序列\n\n\n\n若有限序列 \\[\n\\Gamma_1 \\vdash \\alpha_1, \\quad \\Gamma_2 \\vdash \\alpha_2, \\quad \\ldots,  \\quad \\Gamma_n \\vdash \\alpha_n\n\\] 满足:\n\n每个 \\(\\Gamma_i (1 \\leq i \\leq n)\\) 都是 \\(N_{\\mathcal{L}}\\) 的有限公式集;\n每个 \\(\\Gamma_i (1 \\leq i \\leq n)\\) 都是对此序列中它之前的若干 \\(\\Gamma_j \\vdash \\alpha_j (1 \\leq j &lt; i)\\) 应用 \\(N_{\\mathcal{L}}\\) 的形式推理规则得到的.\n\n则称此序列为 \\(N_{\\mathcal{L}}\\) 的一个(形式) 证明序列.\n也称 \\(\\alpha_n\\) 可由 \\(\\Gamma_n\\) 在 \\(N_{\\mathcal{L}}\\) 中形式推出, 记为 \\(\\Gamma_n \\vdash_{N_{\\mathcal{L}}} \\alpha_n\\), 或 \\(\\Gamma_n \\vdash \\alpha_n\\).\n\n\n\\(N\\) 的定理也是 \\(N_{\\mathcal{L}}\\) 的定理.\n\\(N_{\\mathcal{L}}\\) 中的一些可证式子:\n\\[\\begin{aligned}\n&\\begin{cases}\n\\alpha \\to \\forall x \\beta \\vdash\\dashv \\forall x (\\alpha \\to \\beta) \\\\\n\\alpha \\to \\exists x \\beta \\vdash\\dashv \\exists x (\\alpha \\to \\beta) \\\\\n\\end{cases} \\quad \\text{若 } x \\text{ 不在 } \\alpha \\text{ 中自由出现.} \\\\\n\n&\\begin{cases}\n\\forall x \\alpha \\to \\beta \\vdash\\dashv \\exists x (\\alpha \\to \\beta) \\\\\n\\exists x \\alpha \\to \\beta \\vdash\\dashv \\forall x (\\alpha \\to \\beta) \\\\\n\\end{cases} \\quad \\text{若 } x \\text{ 不在 } \\beta \\text{ 中自由出现.} \\\\\n\n&\\begin{cases}\n\\alpha \\land \\forall x \\beta \\vdash\\dashv \\forall x (\\alpha \\land \\beta) \\\\\n\\alpha \\land \\exists x \\beta \\vdash\\dashv \\exists x (\\alpha \\land \\beta) \\\\\n\\alpha \\lor \\forall x \\beta \\vdash\\dashv \\forall x (\\alpha \\lor \\beta) \\\\\n\\alpha \\lor \\exists x \\beta \\vdash\\dashv \\exists x (\\alpha \\lor \\beta) \\\\\n\\end{cases} \\quad \\text{若 } x \\text{ 不在 } \\alpha \\text{ 中自由出现.} \\\\\n\n&\\begin{cases}\n\\neg \\forall x \\alpha \\vdash\\dashv \\exists x \\neg \\alpha \\\\\n\\neg \\exists x \\alpha \\vdash\\dashv \\forall x \\neg \\alpha \\\\\n\\end{cases} \\\\\n\n&\\begin{cases}\n\\forall x \\alpha \\vdash\\dashv \\forall y \\alpha(x/y) \\\\\n\\exists x \\alpha \\vdash\\dashv \\exists y \\alpha(x/y) \\\\\n\\end{cases} \\quad \\text{若 } y \\text{ 不在 } \\alpha \\text{ 中自由出现.}\n\n\\end{aligned}\\]\n\n\n\n\n\n\nNote前束范式\n\n\n\n\\(\\mathcal{L}\\) 的一个公式 \\(\\alpha\\) 如果具有如下形状: \\[\nQ_1 v_1 Q_2 v_2 \\ldots Q_n v_n \\beta\n\\] 其中:\n\n\\(Q_i\\) 为量词 \\(\\forall\\) 或 \\(\\exists\\) (\\(1 \\leq i \\leq n\\));\n\\(v_i\\) 为个体变元符号 (\\(1 \\leq i \\leq n\\));\n\\(\\beta\\) 为不含量词的公式.\n\n则称 \\(\\alpha\\) 为\\(\\mathcal{L}\\) 的一个前束范式.\n\n\n范式定理: 对 \\(\\mathcal{L}\\) 中任一个公式 \\(\\alpha\\), 存在 \\(\\mathcal{L}\\) 的一个前束范式 \\(\\alpha'\\), 使得 \\(\\alpha\\vdash\\dashv\\alpha'\\). 也称此 \\(\\alpha'\\) 为 \\(\\alpha\\) 的一个前束范式.\nProof. 对于 \\(\\alpha\\) 中所含的联结词与量词的个数 \\(d\\) 进行归纳证明.\n\n\n\n\n\n\nNote谓词公式按前束范式的分类\n\n\n\n设 \\(n\\) 是一个非零的自然数.\n\n若前束范式 \\(\\alpha\\) 的量词以全称量词开始, 并且全称量词组与存在量词组有 \\(n-1\\) 次交替, 则称 \\(\\alpha\\) 为\\(\\Pi_n\\) 型前束范式, 简称\\(\\Pi_n\\) 型公式.\n若前束范式 \\(\\alpha\\) 的量词以存在量词开始, 并且存在量词组与全称量词组有 \\(n-1\\) 次交替, 则称 \\(\\alpha\\) 为\\(\\Sigma_n\\) 型前束范式, 简称\\(\\Sigma_n\\) 型公式.\n\n例如: \\(\\forall x_1 \\forall x_2 (F^1(x_1)\\to F^1(x_2))\\) 是 \\(\\Pi_1\\) 型公式; \\(\\exists x_1 \\forall x_2 \\exists x_3 (F^2(x_1,x_2)\\lor F^1(x_3))\\) 是 \\(\\Sigma_3\\) 型公式.\n\n\n\n\n2.3 一阶谓词演算的形式系统 \\(K_{\\mathcal{L}}\\)\n\\(K_{\\mathcal{L}}\\) 与 \\(P\\) 相对应. 给定非逻辑符号集 \\(\\mathcal{L}\\), \\(K_{\\mathcal{L}}\\) 的构成如下:\n\n形式语言: \\(\\mathcal{L}\\) 生成的一阶语言的一个子语言.\n形式推理:\n\n形式公理: 命题演算系统 \\(P\\) 的所有公理 (3 条), 加上下列公理模式:\n\n(K4): \\(\\forall x \\alpha \\to \\alpha(x/t)\\), 其中 \\(t\\) 对 \\(x\\) 在 \\(\\alpha\\) 中自由.\n(K5): \\(\\alpha \\to \\forall x \\alpha\\), 若 \\(x\\) 不在 \\(\\alpha\\) 中自由出现.\n(K6): \\(\\forall x (\\alpha\\to\\beta) \\to (\\forall x \\alpha \\to \\forall x \\beta)\\).\n(K7): 若 \\(\\alpha\\) 是 \\(K_{\\mathcal{L}}\\) 的一个公理, 则 \\(\\forall x \\alpha\\) 也是 \\(K_{\\mathcal{L}}\\) 的一个公理.\n\n形式规则: 与命题演算系统 \\(P\\) 的规则相同, 即 分离规则 (M).\n\n\n\n\n\n\n\n\nNote\\(K_{\\mathcal{L}}\\) 公式的简写\n\n\n\n\n\\(\\alpha \\lor \\beta\\) 为 \\(\\neg \\alpha \\to \\beta\\) 的简写.\n\\(\\alpha \\land \\beta\\) 为 \\(\\neg (\\alpha \\to \\neg \\beta)\\) 的简写.\n\\(\\alpha \\leftrightarrow \\beta\\) 为 \\(\\neg((\\alpha\\to\\beta)\\to\\neg(\\beta\\to\\alpha))\\) 的简写.\n\\(\\exists x \\alpha\\) 为 \\(\\neg \\forall x \\neg \\alpha\\) 的简写."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "VectorPikachu’s Website",
    "section": "",
    "text": "Here is the homepage of VectorPikachu. You can navigate to the About page to learn more about me. You can also check out my Course Notes for various courses I’ve taken in PKU. Blogs are the places where I share my thoughts and notes on various topics.\n\nAbout Me\nCourse Notes\nBlogs"
  }
]