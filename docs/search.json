[
  {
    "objectID": "PDF/OOP/期末复习.html",
    "href": "PDF/OOP/期末复习.html",
    "title": "面向对象技术引论期末复习",
    "section": "",
    "text": "对象：客观存在的事物\\(\\rightarrow\\)​对象，对象作为基本构成单位。\n属性与操作：属性表示性质，操作表示行为。\n对象的封装：对象的属性与操作结合为一体，成为一个独立的、不可分的实体，对外屏蔽其内部细节。公开静态的、不变的操作，而把动态的、易变的操作隐藏起来。\n\n分类：相同属性和相同操作分为一类。\n聚合：复杂的对象可以用简单的对象作为其构成部分。\n\n继承：特殊类继承一般类。\n消息：对象之间通过消息进行通讯，以实现对象之间的动态联系。\n\n关联：表示对象之间的静态关系。\n\n\n\n\n从程序设计方法的角度看，面向对象是一种程序设计范型(paradigm)。使用对象、类、继承、封装、聚合、关联、消息、多态性等基本概念来进行程序设计。\n从软件方法学的角度看，面向对象方法是一种运用对象、类、继承、封装、聚合、关联、消息、多态性等概念来构造系统的软件开发方法。\n程序=&lt;对象, 关系&gt; 对象=算法+数据结构\n\n\n\n\n需求工作：起始活动（可行性分析）\\(\\rightarrow\\) 需求获取活动（得到软件需求陈述，通过自然语言、用况图、用户故事等）\\(\\rightarrow\\) 需求分析活动（一个精确的需求模型）\\(\\rightarrow\\) 需求规约活动（软件需求规约，采用标准的模板） \\(\\rightarrow\\) 需求验证活动 \\(\\rightarrow\\) 需求管理活动\n\n\n一个需求是一个陈述，描述了待开发产品／系统（或项）功能上的能力、性能参数或者其它性质。\n\n\n\nIEEE标准830-1998要求单一需求必须具有5个基本性质:\n\n必要的(Necessary)。缺少了这个需求是不是还可以？\n无歧义的(Unambiguous)。只能用一种方式解释吗？\n\n可测试的(Testable)。可以对它进行测试吗？\n可跟踪的(Traceable)。可以从一个开发阶段到另一个阶段对它进行跟踪吗？不可能开发过程中需求就消失了。\n可测量的(Measurable)。可以对它进行测量吗？应该有一个方法可以衡量需求是否被满足了。\n\n注:确定一个需求是否满足以上五个性质是复杂耗时的过程。\n\n\n\n功能；性能；外部接口；设计约束；质量属性\n功能的需求是最重要的，所有别的需求都必须依附在功能这个需求之上。\n\n\n功能需求规约了系统或系统构件必须执行的功能。\n\n对该功能输入的假定，或者为了验证该功能输入，有关检测的假定。（类似于OI竞赛中给定的\\(n\\leq 100\\)这样）\n功能内的任一次序，这一次序是与外部有关的。（应该先干啥）\n对异常条件的响应，包括所有内外部所产生的错误。\n需求的时序或优先程度。\n功能之间的互斥规则。\n系统内部状态的假定。\n为了该功能的执行，所需要的输入和输出次序。\n用于转换或内部计算所需要的公式。\n\n\n\n\n系统或系统构件必须具有的性能特性。\n注：性能需求隐含了一些满足功能需求的设计方案，经常对设计产生一些关键的影响。例如：排序，关于花费时间的规约将确定哪种算法是可行的。\n\n\n\n应当为外部提供什么样的接口，应当使用哪些外部接口，进而必须可以处理这样的格式的数据。\n\n系统接口：与系统的其他应用进行交互。\n用户接口：规约对给用户所显示的数据，对用户所要求的数据以及用户如何控制该用户接口。\n硬件接口\n软件接口：和其他软件产品交互。比如和数据库管理系统交互，和操作系统交互。（问：和操作系统交互的接口到底是软件接口还是系统接口？）\n通讯接口：比如必须使用的网络类型。\n内存约束：描述易失性存储和永久性存储的特性和限制，特别应描述它们是否被用于与一个系统中其它处理的通讯。（问：为什么内存约束要被使用在外部接口需求这里？）\n操作：规约用户如何使系统进入正常和异常的运行以及在系统正常和异常运行下如何与系统进行交互。应该描述在用户组织中的操作模式，包括交互模式和非交互模式；描述每一模式的数据处理支持功能；描述有关系统备份、恢复和升级功能方面的需求。（问：没有理解）\n地点需求：如何安装以及调整一个地点，来适应新的系统。\n\n\n\n\n设计约束限制了系统或系统构件的设计方案。就约束的本身而言，对其进行权衡或调整是相当困难的，甚至是不可能的。它们必须予以满足。\n任取10秒，一个特定应用所消耗的可用计算能力平均不超过50%。（问：为什么不属于性能需求？）\n系统必须用C++或其他面向对象语言编写。系统用户接口需要菜单。（问：这里为什么不属于外部接口需求？）\n必须在对话窗口的中间显示错误警告，其中使用红色的、14点加粗Arial字体。（问：这里为什么不属于功能需求？）\n\n法规限制\n硬件限制\n与其他应用的接口\n并发操作\n审计功能\n控制功能\n高级语言需求\n握手协议\n应用的关键程序\n安全考虑\n\n\n\n\n可靠性、可维护性、易用性（用户友好性）、安全性、可移植性、规模、速度\n\n\n\n\n\n\n需求人员把自己作为系统的最终用户，审视该系统并提出问题：“如果是我使用这一系统，则我需要…”\n\n\n\n在交谈期间需求可能不断增长，或是以前没有认识到的合理需求的一种表现，说是“完美蠕行”(Creeping elegance)病症的体现，以至于很难予以控制，可能导致超出项目成本和进度的限制。\n解决方法：项目管理人员和客户管理人员应该定期地对交谈过程的结果进行复审。\n\n\n\n尽管了解的这些信息可以通过交谈获取，但 “第一手材料”一般总是能够比较好地“符合现实”。\n客户可能抵触这一观察。\n客户还可能认为开发者在签约之前，就已经熟悉了他们的业务。（问：这句话想表达什么？）\n\n\n\n举行客户和开发人员的联席会议，与客户组织的一些代表共同开发需求。\n\n\n\n复审技术文档。\n提炼方法是针对已经有了部分需求文档的情况。依据产品的本来情况，可能有很多文档需要复审，以确定其中是否包含相关联的信息。在有的情况，也可能只有少数文档需要复审。\n\n\n\n\n\n\n把系统看作一个黑箱，看它对外部的客观世界发挥什么作用，描述它外部可见的行为。\n\n我们可以有很多参与者在这里面。\n优势：易于探讨和理解、易于对需求规范化、有利于进行OOA、有助于发现主动对象、对系统测试来说，产生测试用例、有助于人机界面设计、etc\n系统边界、操作者、用况、关联、包含、扩展、泛化\n\n\n某些事物可能既有一个对象作为其抽象描述，而本身（作为现实世界中的事物）又是在系统边界以外与系统进行交互的操作者。如超市中的收款员，他本身是现实中的人，作为操作者；在系统边界内，又有一个相应的“收款员”对象来模拟其行为或管理其信息，作为系统成分。\n某些事物即使属于问题域，也与系统责任没有什么关系。如超市中的保安员，在现实中与超市有关系，但与所开发的系统超市商品管理系统无关系。这样的事物既不位于系统边界内，也不作为系统的操作者。\n\n\n\n尽管在模型中使用操作者，但操作者实际上并不是系统的一部分。它们存在于系统之外。\n\n我们可能的操作者。\n\n\n\n从使用视角看：用况是对操作者使用系统的一项功能时所进行的交互过程的描述。\n\n\n\n用况和操作者之间的唯一的关系，但是用况之间还有别的其他的关系。\n\n\n\n从基用况到扩展用况的扩展关系表明：按基用况中指定的扩展条件，把扩展用况的行为插入到由基用况中的扩展点定义的位置。\n\n扩展的适用条件：(1) 异常情况；(2) 正常的变形描述时，而且希望采用更多的控制方式时，采用扩展。即在一个变化点上一个附加多个变体的场合下使用；(3) 用扩展关系来区分可实现系统的可配置部分（问：什么意思？）。\n\n\n\n从基用况到供应者用况的包含关系表明：基用况在它内部说明的某一（些）位置上显式地使用供应者用况的行为的结果。\n（问：包含和扩展有什么区别呢？我的理解是一个是显式地使用包含用况，一个是隐式地使用扩展用况？）\n\n\n\n\n\n\n\n\n\n识别操作者、捕获用况（从操作者的角度来看、从系统功能的角度来看、从场景技术的角度来看）、系统的需求建模、审查\n\n\n\n\n用户+事件。其中用户表现为对主要用户的描述，事件则是场景或系统/任务价值\n用户故事相当于用况图正文的描述说明。UML实际推崇的是用况图，但在敏捷开发中使用面向对象方法时也会将用户故事作为系统的需求描述\n\n\n\n\n\n\nUML是系统分析和设计的工具\n\n\n\n\n参与者、信号、实用程序都是类。\n\n为什么对象没有操作栏？这是因为它的操作已经在它的类里面被定义了，而属性栏之所以存在是因为我们在构造这个对象的时候，必须为它填入初始的属性。\n抽象类使用斜体字。\n类可以有所在的包名。\n\n属性的默认语法：[可见性]属性名[:类型][多重性][=初始值][{特性串}]，比如+name: String[0..1] = \"Hello\"{readonly}。\n\n可见性：为什么引入可见性？为了支持信息隐蔽这一软件设计原则。信息隐蔽是指在每个模块中所包含的信息（包括表达信息的数据以及表达信息处理的过程）不允许其它不需要这些信息的模块访问。信息隐蔽是实现模块低耦合的一种有效途径。\n属性名：小写字母开头\n类型名\n多重性：省略的时候默认为[1..1]\n初始值\n性质串：a : integer = 10 {frozen}，这就表示属性是不可改变的\n\n所有的共同的属性，加上下划线，defaultSize这样子的。\n\n\n\n可见性\n符号表示\n关键字表示\n描述\n\n\n\n\n公有的\n+\npublic\n所有其他的类/类目都可以使用\n\n\n受保护的\n#\nprotected\n仅其子类/类目才能使用\n\n\n私有的\n-\nprivate\n仅本类的操作才能使用\n\n\n包内的\n~\npackage\n仅同一包中声名的类/类目才能使用\n\n\n\n操作的默认语法：[可见性] 操作名 [(参数表)] [: 返回类型] [{性质串}]，例：+ set(id : Integer, name : String) : Boolean {...}。\n参数表里的每个参数还可以如下：[方向] 参数名 : 类型 [= 默认值]，比如in name: String = \"Hello\"。\nin输入参数，inout输入参数可修改，out输出参数。\n衍型：类型的类型，用双尖括号包裹起来。&lt;&lt;datatype&gt;&gt;。\n\n\n\n\n\n\n\n\n\n\n协作是一个交互，涉及交互三要素：交互各方、交互方式以及交互内容 。\n使机器人沿着一条路径移动所涉及的类 \\(\\rightarrow\\) 一个协作\n\n\n\n一个用况描述了系统的一个完整的功能需求。\n用况是通过协作予以细化的。\n\n\n\n进程和线程都是主动类。\n主动类对象的行为通常与其他元素的行为是并发的。\n至少具有一个进程或线程的类，能够启动系统的控制活动。\n\n\n\n在遵循并提供了一组外部接口的实现的同时，隐藏内部实现。构件是描述比特世界的软件制品的系统单位。\n应用、文档、库、页和表都是构件。\n\n\n\n\n系统中包含物理信息的、可替代的物理部件。\n这里说部件是“物理的”，指软件未运行时也存在的部分，主要指文件，如源代码、可执行程序、脚本等；软件系统中可能会存在不同类型的部署制品；制品通常代表对源代码/运行时信息的物理打包。\n\n\n\n\n在运行时存在的物理元素，通常它表示一种具有记忆能力和处理能力的计算机资源（比如服务器、数据库管理系统等）\n这里的“物理的”指实际机器设备；一个构件可以驻留在一个节点中，也可以从一个节点移到另一个节点。\n\n\n\n\n\n\n\n它指明一个类的对象与另一个类的对象间的联系。如果类的对象之间通过属性有连接关系，那么这些类之间的语义关系就是关联。链是关联的实例，是对象间的语义连接，是对象引用的元组（列表）。 在最常见的情况下，它是一对对象引用。\n关联表示对象之间的静态联系。\n\n这里的多重性是一个教师可以指导0到多个学生的论文，而一个学生只能被一个教师指导论文。\n\n还可以用关联导航来解决。\n\n角色和关联端名：\n\n限定符：\n\n\n\n一种特殊形式的关联，表达一种“整体 /部分”关系。即一个类表示了一个大的事物，它是由一些小的事物（部分）组成的。\n\n\n\n\n组合是一种特殊的聚合。组合中的对象具有相同的生命周期。\n组合的末端的多重性不能超过1。因为一个对象最多组合成另一个对象。\n在一个组合中，由一个链所连接的对象而构成的任何元组，必须都属 于同一个整体类的对象（问：没有理解这句话）\n\n\n\n\n\n关联类：具有关联和类特性的模型元素，可以被看作是关联，但还有类 的特性；或被看作是一个类，但有关联的特性。\n\n比如我们能认为大学和教师之间的关联是通过任务来获得的。\n\n\n\n“is-a-kind-of” 继承关系又称为一 般一特殊关系，在UML中把继承关系称为泛化关系。\n\n\n\n\n在两个地方会使用实现的关系：接口与实现它们的类和构件之间；用况与实现它们的协作之间。\n\n\n\n\n依赖是一种使用关系，用于描述一个类目使用另一类目的信息和服务。\n\n\n\n\n\n\n使用“关联”，模型化系统中存在的大量静态结构和动态结构。\n\n以数据驱动：一个对象需要导航到另外一个对象\n以行为驱动：一个对象需要与另一个对象交互\n\n\n\n使用“泛化”，对系统中存在的一般/特殊关系规约。\n\n\n\n使用“实现”，对系统中存在的精化关系规约\n该术语用于表达不同抽象层之间的精化，体现“自顶向下，逐步求精” 的思想。如系统需求层的用况，可通过协作实现。这两者即可用 “实现”规约。\n\n\n\n使用“依赖”，对不是结构、继承、精化的关系规约。\n某类只作为另一类的操作参数，则可将它们之间的关系抽象为依赖\n\n\n\n\n\n\n\n\n可以在小矩形里写包名，大矩形中表示内容。\n也可以这样画：\n\n引入依赖和访问依赖。\n\n这样表示Controller可以访问Components和Subcomponents。\n\n\n\n注解可以是简单文字，也可以内嵌URL或文档链接，用虚线连接到所解释说明的模型元素上。\n\n\n\n\n\n\n\n类图显示了类（及其接口）、类的内部结构以及与其他类的联系。是面向对象分析与设计所得到的最重要的模型。\n\n\n\n用对象图说明在类图中所发现的事物的实例的数据结构和静态快照。\n\n\n\n就是用来表示构件之间的关系的图。\n\n\n\n\n\n\n\n\n\n\n外扩图是在UML2.5的基础上定义新建模元素的图，用以增加新的建模能力\n\n\n\n\n所以这个图可以和构件图结合在一起。\n\n\n\n\n\n\n通常都是对反应型对象（reactive object）的行为进行建模。\n\n状态机图是描述一个对象或其他实体在其生命周期中所经历的各种状态以及状态变迁的图.\n一个状态机图，规约了一个对象在其生存期内因响应事件所经历的状态序列以及对这些事件所作出的响应。\n状态之间的转化是即时的。\n延迟事件：延迟事件是指在当前状态下暂不处理，但将推迟到该对象的另一个状态下排队处理的事件。比如我现在想要识别出某一个事件，但是我现在不处理。activity/defer\n事件：事件就是状态转移的实心线上面标记的东西。activity(parameter1: Type1, ...)。\n\n信号（Signal）事件：信号是一种Type，所以它的原类型是signal。这里是衍型。\n调用（Call）事件：一个调用事件表示对象接收到一个操作调用的请求。\n时间事件：时间事件后跟有计算时间量的表达式。after (2 seconds)。\n变化事件：指定条件变为真了，譬如at (xxx)/selfTest(), when (altitude &lt; 1000)。\n\nactivityName[(Parameter list)][Guard][/Action]。比如：right-mouse-down(location)[location in window]/object:=pick_object(location)。\nUML内置关键字：\n\nentry：进入状态时首先执行该动作。它不能有参数或监护条件。\nexit：在退出状态时最后执行该动作。它不能有参数或监护条件。\ndo：在状态的进入动作表达式（如果有）执行后，开始执行do活动，并且do活动可与其他的动作或者活动并行。\n\n状态间的转移 vs. 状态内的转移 ： 如果源状态和目标状态都是自身，那么会先触发该状态的退出动作，再执行该状态的进入动作，和状态内的转移有区别。\n\n\n\n顺序子状态机（非正交）和并发子状态机（正交）\n非正交状态机：最多有一个子初态和一个子终态。\n\n转移到该组合状态：这个被嵌套的子状态机一定有一个初态，以便在进入该组合状态并执行其进入动作后，将控制传送给这一初态。\n转移到该组合状态的一个子状态：在执行完该组合状态的进入动作（如有的话）和该子状态的进入动作后，将控制传送给这一子状态。\n\n\n离开的时候：首先离开被嵌套的状态，即执行被嵌套状态的退出动作（如有的话）；然后离开该组合状态，即执行该组合状态的退出动作（如有的话）。\n正交状态机：控制流分岔，分成了并发流。\n\n\n\n\n动作是原子的和即时的。\n对象是方的矩形，而动作是圆角的矩形。\n\n\n\n\n一种详细表示 对象之间以及对象与参与者实例之间交互的图，它由一组协作的对象（或参与者实例）以及它们之间可发送的消息组成，它强调消息之间的顺序。\n对象：[ObjectName]: ClassName。\n参与者：一个小人\n对象生命线：一个垂直虚线，用X表示被析构。\n执行规约：窄长的矩形。\n消息：同步消息：实心的箭头，返回虚线箭头 异步消息：实现，空心的箭头\n\n消息分支：把分支画成从一个点出发的多个箭头，每个箭头由监护条件标示\n消息循环：*Message[Guard]，表示按照给定的表达式一直发送信息。\n回调机制：申请对象在服务对象处事先登记所关心的事件，然后继续从事自己的工作；当服务对象监控到这样的事件发生时，再通知申请对象，由申请对象进行处理。这是一个异步的。\n\n\n选择（opt,为真才执行）、条件（alt,有两种选择）、并发（par,同时做）、迭代（loop guard,循环）\n\n\n\n\n\n为表示一个消息的时间顺序，给消息加一个数字前缀（从1号消息开始），在控制流中，每个新的消息的顺序号单调增加（如2，3等等）。为了显示嵌套，可使用带小数点的号码（1表示第一个消息；1.1表示嵌套在消息1中的第一个消息；1.2表示嵌套在消息1中的第二个消息；等等）。\n通信图和顺序图两者语义上是等价的。\n\n\n\n\n用于描述系统的宏观行为，是活动图和顺序图的混合物。\n\n\n\n用于表示交互，它展现了消息跨越不同对象或角色的实际时间，而不仅仅关心消息的相对顺序。\n\n\n\n\n\n运用面向对象方法，对问题域（被开发系统的应用领域）和系统责任（所开发系统应具备的职能）进行分析和理解 。\n\n\n\n\n\n\n\n\n发现对象，定义他们的类。\n识别对象的内部特征：定义属性、定义操作。\n识别对象的外部关系：分类关系（继承）、构成关系、静态联系、使用关系\n给出系统的相关顺序图、状态图和活动图等，以建立系统的动态模型\n划分包，建立系统的包图\n建立系统的详细说明\n\n\n\n\na） 信息组织的复杂性：\n抽象:从许多事物中舍弃个别的、非本质的特征，抽取共同的、本质性 的特征：系统中的对象是对现实世界中事物的抽象； 类是对象的抽象；一般类是对特殊类的抽象； 属性是事物静态特征的抽象； 操作是事物动态特征的抽象。\n分类机制:把具有相同属性和操作的对象划分为一类，用类作为这些对象 的抽象描述。\n继承:特殊类的对象拥有其一般类的全部属性和服务（一般-特殊结构）；\n聚合:把一个复杂的事物看成若干比较简单的事物的组装体，从而简化对 复杂事物的描述。（整体-部分结构）\n消息通讯：要求对象之间只能通过消息进行通讯，而不允许在对象之外 直接地存取对象内部的属性。\n多个视图：从多个角度认识系统\nb） 文档组织的复杂性—控制机制\n包：使模型具有大小不同的粒度层次，以利于控制复杂性\n\n\n\n\n瀑布模型和喷泉模型\n\n\n\n\n\n\n\n不强调次序，逐个设计每个部分。\n\n\n它是在OOA模型基础上按实现条件进行必要的修改、调整和细节补充而得到的。\n实现条件：\n\n编程语言：对问题域的影响最大。选定的编程语言不支持某些面向对象的概念与原则；OOA阶段可能将某些与编程语言有关的对象细节推迟到OOD阶段来定义。如对象的创建、删除、复制、转存、初始化等系统行为、属性的数据类型等。\n\n为复用设计与编程的类而增加新的结构\n增加一般类以建立共同协议（比如：提供创建、删除、复制等操作，Java里面的object就可以体现这个问题，它是所有的类的父类，所有的类都要继承它）object{复用}\n按编程语言调整继承和多态：如果编程语言不支持多继承怎么办？（方法1：采用聚合，把多继承转换为单继承，方法2：重新定义对象类，方法3：压平）如果编程语言不支持继承怎么办？（方法1：把继承结构展平，所有需要的信息都放到展平后的类里面去；方法2：再加上聚合，每个类不存在信息冗余）如果编程语言不支持多态怎么办？重新命名函数。\n提高性能：调整对象分布，合并通讯频繁的类\n为实现对象永久存储做的修改\n为编程方便增加底层成分\n对复杂关联的转化并决定关联的实现方式：多对多关联转化为一对一关联\n调整与完善属性\n构造和优化算法\n决定对象间的可访问性\n定义对象实例：当系统需要通过从外存读取数据来创建一个对象时 ，先创建该对象，再从外存中读取这个对象数据，把数据赋值给对象的相应属性。\n\n硬件、操作系统及网络设施\n\n复用支持\n数据管理系统\n界面支持系统\n\n\n（道理：尽管继承和聚合反映了现实世界中两种不同的关系，但是从最终效果来看却存在共性－都是使一个类的对象能够拥有另一个（一些）类的属性和操作。）\n\n（重新审视原来用多继承结构表达的实际事物及它们之间的关系。例如，上述例子换一个角度看问题：形成这种分类的原因使什么？从而增加“身份”类，构成单继承。）\n\n（缺点：损失了信息）\n为什么要这么做：使反映问题域本质的总体框架和组织结构长期稳定，而细节可变；稳定部分与可变部分分开，使系统从容地适应变化；有利于同一个分析用于不同的设计与实现；支持系统族和相似系统的分析设计及编程结果复用；使一个成功的系统具有超出其生存期的可扩展性\n\n\n\nOOD要设计人机交互的细节，而OOA用人机交互来反映需求\n\n分析与系统交互的人：设计时重点考虑比例最大的人员情况，并适当地兼顾其他人。\n从use case分析人机交互\n\n人机交互界面的设计准则：使用简便、一致性、启发性、减少人脑记忆的负担、减少重复的输入、容错性、及时反馈、防止灾难性的错误\n\n\n\n控制流驱动部分，用于定义和表示并发系统中的每个控制流。用主动对象表示每个控制流(进程、线程) ，所有的主动类构成控制驱动部分\n如何设计控制驱动部分：用包括主动类的类图捕捉控制流的静态结构；用包括主动对象的顺序图或通信图捕捉控制流的动态行为。\n\n\n\n数据管理部分是负责在特定的数据管理系统中存储和检索持久对象的组成部分\n其目的是，存储问题域的持久对象、封装这些对象的查找和存储机制，以及为了隔离数据管理方案的影响\n文件系统、R-DBMS（关系数据库系统）、OO-DBMS（面向对象数据库系统）\n\n\n\n面向对象\n实体-联系\n关系数据库\n\n\n\n\n类\n实体类型\n表\n\n\n对象\n实体实例\n行\n\n\n属性\n属性\n列\n\n\n关系\n关系\n表\n\n\n\n\n这个关联的表是右下角，应该是一种 link1 : {EmployeeNumber , Location}这样的一行。\n如果是1对多，可以为比如公司职员记录公司ID这个属性。或者是公司ID和职员ID建立一个关联表。\n如果是多对多呢：\n\n还有对父类和子类的关系的存储可以有下面的三种情况：\n\n（下推）：为每一个子类定义一张单独的表。当增加新的父类或者子类的时候对数据库的维护和修改是很大的麻烦。\n（上拉）去掉继承的网络结构。对实例要存储大量的冗余。\n（分割表）将父类和子类的状态存储在不同的表中。这种方法很好地反映了继承网格，但它的缺点是访问数据时需要许多跨表连接。\n\n对象存储器。\n\n\n\n构件具有端口和接口。\n接口是一个圆圆的或者半圆的，端口是一个方形的那个。\n\n\n\n\n\n\n\n\n\n\n语言元素可以支持\n\n类的定义\n对象的静态声明或者动态创建\n属性和操作的定义\n继承、聚合、关联和消息的表示\n\n语言机制有：\n\n类机制\n封装机制\n继承机制\n\n高级特性：多态、多继承的表示和支持机制\n\n\n\n纯面向对象语言：Smalltalk、Eiffel、Java\n较为全面的支持OO，强调严格的封装\n混合型：C++、Objective-C、Objective-Pascal、Python\n在一种非OO语言的基础上扩充OO成分、对封装采取灵活的态度\n\n问：为什么说对象指针实现了关联?\n\n\n\n\n\n\n\n\n在高层定义接口，隐藏复杂性。可以理解为UI界面。\n或者类似于一个APP的页面。\n\n隐藏复杂性\n可以用来包装遗产系统\n用来检测某项的访问量\n\n\n\n\n将抽象部分与它的实现部分分离，使它们都可以独立地变化\n识别出一个类所具有的两个独立变化的维度，将它们设计为两个继承等级结构，并建立抽象和实现的聚合关系\n\n\n\n\n一个类只有一个实例，并提供全局的访问点。\n全局变量无法阻止多次的实例化，而单例把实例化的方法私有了，这样就只能在一开始创建的时候实例化一次了。\n先判断单例是否已经实例化，没有实例化的话再对实例化函数加锁。\n\n\n\n类似于一个存档。\n\n\n\n\n优势：低耦合！策略可以自由切换，系统扩展性、灵活性更高\n\n\n\n\n\n让所有的实例化都通过工厂来完成。\n可以减少构造对象的时候的复杂性。\n\n\n\n用来创建对象族的。\n\n\n\n\n\n代理还可以再加入一点自己的操作。\n\n\n\n提供访问数据结构的方法\n\n\n\n访问复杂的数据结构\n\n\n\n\n\n\n\n将一个请求封装成一个对象，使得发出请求的责任和执行请求的责任分开。\n\n命令模式降低了耦合，命令的使用者不再需要了解系统底层的逻辑，只需要使用包装好的命令。\n\n\n\n定义一个算法的骨架，把一些操作延迟到子类中进行。\n\n\n\n\n一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。\n\n\n\n还不太理解\n\n\n\n定义一个转换器，将一个类的接口转换成用户需要的另一个接口\n比如要修改数据格式。\n\n\n\n\n对象声明自己的依赖，而该依赖由外部注入的形式为其提供\n可以降低耦合度（如果自己里面再声明一个类，耦合度太高了）\n\n\n\n\n防御式编程 ：数组越界、空指针、函数参数、返回值、外部接口。\n考虑到输入的不确定性，在程序代码的主要逻辑之外增加了大量的检查，包括对所有外来数据的检查、对所有输入参数的检查等，并最终决定如何处理不符合预期的输入。\n理解构成良好代码风格的主要因素：\n\n命名—符合语义（是什么、做什么、易于识别）\n注释—合理使用序言式注释与功能性注释\n视觉组织—清晰的缩进、空格与换行\n语句构造—避免太长的子程序、嵌套、语句，避免一行多语句\n输入输出—检查输入输出、简化输入输出步骤、合理的输入输出提示、为输出添加注释\n避免“魔法”—何为魔法串/数字\n\n\n\n\n\n\n\n单元测试：集中于每个独立的模块。该测试以详细设计文档为指导，测试模块内的重要控制路径。（往往采用白盒测试技术）\n集成测试：集中于模块的组装。其目标是发现与接口有关的错误，将经过单元测试的模块构成一个满足设计要求的软件结构。\n确认测试（有效性测试）：目标是发现软件实现的功能与需求规格说明书不一致的错误。（通常采用黑盒测试技术）\n系统测试：集中检验系统所有元素（包括硬件、软件）之间协作是否合适，整个系统的性能、功能是否达到。\n\n\n\n\n\n主要依据详细设计说明书和源代码清单\n主要测试模块的I/O条件和模块的逻辑结构\n主要采用白盒测试方法设计测试用例，辅以黑盒测试的测试用例，使之对任何合理的和不合理的输入都要鉴别和响应\n要对所有的局部和全局数据结构、外部接口和程序代码的关键部分进行代码审查\n\n\n\n\n\n\n\n把各个模块连接起来的时候，穿越模块接口的数据是否丢失\n\n一个模块的功能是否对另一个模块的功能产生不利的影响\n\n各个子功能组合起来，能否达到预期要求的父功能\n\n全局数据结构是否有问题\n\n单个模块的误差累加起来，是否达到不可接受的程度\n\n集成测试的方法：一次性组装方法、增量式组装方法\n\n\n\n有效性测试，即验证软件的功能和性能及其他特性是否与用户的要求一致\n有效性测试是在模拟的环境（可能是开发环境）下，运用黑盒测试的方法，验证被测软件是否满足需求规格说明书列出的需求。\n软件配置审查是保证软件配置的所有成分齐全，各方面的质量符合要求，具有维护阶段所必须的细节，并且已编排好分类的目录。\n\n\n\n\n集中检验系统所有元素（包括硬件、信息等）之间协作是否合适，整个系统的性能、功能是否达到。\n系统测试实际上是一系列不同的测试，以下是用于系统测试的几种典型软件系统测试：\n\n功能测试：在规定的时间内运行软件系统的所有功能，以验证这个软件系统有无严重错误。\n恢复测试：是一种系统测试，它指采取各种人工干预方式强制性地使软件出错，使其不能正常工作，进而检验系统的恢复能力\n安全性测试：就是试图去验证建立在系统内的预防机制，以防止来自非正常的侵入\n强度测试：是在非正常数量、频率或容量资源方式下运行一个系统 （已经不正常了）\n压力测试：系统正常运行的最低限度\n性能测试：测试软件在被组装进系统的环境下运行时的性能 （还是正常的）\n可用性测试：从使用的合理性、方便性等角度对软件系统进行检验，以发现人为因素或使用上的问题\n部署测试（配置测试）：软件必须在多种平台及操作系统环境中运行。有时将部署测试称为配置测试，是在软件将要在其中运行的每一种环境中测试软件。另外，部署测试检查客户将要使用的所有安装程序及专业安装软件，并检查用于向最终用户介绍软件的所有文档。\n\n\n\n\n\n\n\n也就是类测试。面向对象软件的类测试相当于传统软件中的单元测试，类包含的操作是最小的可测试单元\n功能性测试：以类的规格说明为基础，主要检查类是否符合规格说明的要求。功能性测试包括两个层次：类的规格说明和方法的规格说明\n结构性测试：从程序出发，对类中的方法进行测试，需要考虑其中的代码是否正确。测试分为两层 ：第一层考虑类中各独立的方法，即方法要做单独测试；第二层考虑方法之间的相互作用，即方法需要进行综合测试\n基于状态的测试：基于状态的测试是通过检查对象的状态在执行某个方法后是否会转移到预期状态的一种测试技术；跟踪监视对象数据成员的值的变化。\n\n\n\n基于线程的测试（thread-based testing）：对响应系统的一个输入或一组类进行集成，每个线程单独地集成和测试事件所需的，应用回归测试以确保没有产生副作用\n基于使用的测试(use-based testing)：通过测试很少使用服务类的那些类（称之为独立类）开始构造系统，独立类测试完后，利用独立类测试下一层次的类（称之为依赖类）。继续依赖类的测试直到完成整个系统\n簇测试（cluster testing）是面向对象软件集成测试中的一步 ：利用试图发现协作中的错误的测试用例来测试协作的类簇\n\n\n\n功能测试、强度测试、性能测试、安全测试、回复测试、可用性测试、安装/卸载测试\n\n\n\n\n\n\n\n对认定的对象的测试：\n\n测试认定的对象是否全面，是否问题空间中所有涉及的实例都反映在认定的抽象对象中\n\n测试认定的对象是否具有多个属性，只有一个属性的对象通常应看成其他对象的属性，而不是抽象为独立的对象\n\n测试被认定为同一对象的实例是否具有区别于其他实例的共同属性\n\n测试被认定为同一对象的实例是否提供或者需要相同的服务。如果服务随着不同的实例而变化，那么认定的对象就需要进行分解或者继承来分类表示\n\n认定的对象的名称应该尽量准确、适用\n\n结构分为两类：分类结构（一般-特殊）和组装结构（整体-部分）\n对认定的分类结构的测试。\n对认定的组装结构的测试。\n对定义的属性和实例关联的测试\n对定义的服务和消息关联的测试\n\n\n\n对认定的类的测试\n对构造的类层次结构的测试\n对类库支持的测试\n\n\n\n数据成员是否满足数据封装的要求\n类是否实现了要求的功能"
  },
  {
    "objectID": "PDF/OOP/期末复习.html#第一章-面向对象方法概论",
    "href": "PDF/OOP/期末复习.html#第一章-面向对象方法概论",
    "title": "面向对象技术引论期末复习",
    "section": "",
    "text": "对象：客观存在的事物\\(\\rightarrow\\)​对象，对象作为基本构成单位。\n属性与操作：属性表示性质，操作表示行为。\n对象的封装：对象的属性与操作结合为一体，成为一个独立的、不可分的实体，对外屏蔽其内部细节。公开静态的、不变的操作，而把动态的、易变的操作隐藏起来。\n\n分类：相同属性和相同操作分为一类。\n聚合：复杂的对象可以用简单的对象作为其构成部分。\n\n继承：特殊类继承一般类。\n消息：对象之间通过消息进行通讯，以实现对象之间的动态联系。\n\n关联：表示对象之间的静态关系。\n\n\n\n\n从程序设计方法的角度看，面向对象是一种程序设计范型(paradigm)。使用对象、类、继承、封装、聚合、关联、消息、多态性等基本概念来进行程序设计。\n从软件方法学的角度看，面向对象方法是一种运用对象、类、继承、封装、聚合、关联、消息、多态性等概念来构造系统的软件开发方法。\n程序=&lt;对象, 关系&gt; 对象=算法+数据结构"
  },
  {
    "objectID": "PDF/OOP/期末复习.html#第二章-需求获取与分析",
    "href": "PDF/OOP/期末复习.html#第二章-需求获取与分析",
    "title": "面向对象技术引论期末复习",
    "section": "",
    "text": "需求工作：起始活动（可行性分析）\\(\\rightarrow\\) 需求获取活动（得到软件需求陈述，通过自然语言、用况图、用户故事等）\\(\\rightarrow\\) 需求分析活动（一个精确的需求模型）\\(\\rightarrow\\) 需求规约活动（软件需求规约，采用标准的模板） \\(\\rightarrow\\) 需求验证活动 \\(\\rightarrow\\) 需求管理活动\n\n\n一个需求是一个陈述，描述了待开发产品／系统（或项）功能上的能力、性能参数或者其它性质。\n\n\n\nIEEE标准830-1998要求单一需求必须具有5个基本性质:\n\n必要的(Necessary)。缺少了这个需求是不是还可以？\n无歧义的(Unambiguous)。只能用一种方式解释吗？\n\n可测试的(Testable)。可以对它进行测试吗？\n可跟踪的(Traceable)。可以从一个开发阶段到另一个阶段对它进行跟踪吗？不可能开发过程中需求就消失了。\n可测量的(Measurable)。可以对它进行测量吗？应该有一个方法可以衡量需求是否被满足了。\n\n注:确定一个需求是否满足以上五个性质是复杂耗时的过程。\n\n\n\n功能；性能；外部接口；设计约束；质量属性\n功能的需求是最重要的，所有别的需求都必须依附在功能这个需求之上。\n\n\n功能需求规约了系统或系统构件必须执行的功能。\n\n对该功能输入的假定，或者为了验证该功能输入，有关检测的假定。（类似于OI竞赛中给定的\\(n\\leq 100\\)这样）\n功能内的任一次序，这一次序是与外部有关的。（应该先干啥）\n对异常条件的响应，包括所有内外部所产生的错误。\n需求的时序或优先程度。\n功能之间的互斥规则。\n系统内部状态的假定。\n为了该功能的执行，所需要的输入和输出次序。\n用于转换或内部计算所需要的公式。\n\n\n\n\n系统或系统构件必须具有的性能特性。\n注：性能需求隐含了一些满足功能需求的设计方案，经常对设计产生一些关键的影响。例如：排序，关于花费时间的规约将确定哪种算法是可行的。\n\n\n\n应当为外部提供什么样的接口，应当使用哪些外部接口，进而必须可以处理这样的格式的数据。\n\n系统接口：与系统的其他应用进行交互。\n用户接口：规约对给用户所显示的数据，对用户所要求的数据以及用户如何控制该用户接口。\n硬件接口\n软件接口：和其他软件产品交互。比如和数据库管理系统交互，和操作系统交互。（问：和操作系统交互的接口到底是软件接口还是系统接口？）\n通讯接口：比如必须使用的网络类型。\n内存约束：描述易失性存储和永久性存储的特性和限制，特别应描述它们是否被用于与一个系统中其它处理的通讯。（问：为什么内存约束要被使用在外部接口需求这里？）\n操作：规约用户如何使系统进入正常和异常的运行以及在系统正常和异常运行下如何与系统进行交互。应该描述在用户组织中的操作模式，包括交互模式和非交互模式；描述每一模式的数据处理支持功能；描述有关系统备份、恢复和升级功能方面的需求。（问：没有理解）\n地点需求：如何安装以及调整一个地点，来适应新的系统。\n\n\n\n\n设计约束限制了系统或系统构件的设计方案。就约束的本身而言，对其进行权衡或调整是相当困难的，甚至是不可能的。它们必须予以满足。\n任取10秒，一个特定应用所消耗的可用计算能力平均不超过50%。（问：为什么不属于性能需求？）\n系统必须用C++或其他面向对象语言编写。系统用户接口需要菜单。（问：这里为什么不属于外部接口需求？）\n必须在对话窗口的中间显示错误警告，其中使用红色的、14点加粗Arial字体。（问：这里为什么不属于功能需求？）\n\n法规限制\n硬件限制\n与其他应用的接口\n并发操作\n审计功能\n控制功能\n高级语言需求\n握手协议\n应用的关键程序\n安全考虑\n\n\n\n\n可靠性、可维护性、易用性（用户友好性）、安全性、可移植性、规模、速度\n\n\n\n\n\n\n需求人员把自己作为系统的最终用户，审视该系统并提出问题：“如果是我使用这一系统，则我需要…”\n\n\n\n在交谈期间需求可能不断增长，或是以前没有认识到的合理需求的一种表现，说是“完美蠕行”(Creeping elegance)病症的体现，以至于很难予以控制，可能导致超出项目成本和进度的限制。\n解决方法：项目管理人员和客户管理人员应该定期地对交谈过程的结果进行复审。\n\n\n\n尽管了解的这些信息可以通过交谈获取，但 “第一手材料”一般总是能够比较好地“符合现实”。\n客户可能抵触这一观察。\n客户还可能认为开发者在签约之前，就已经熟悉了他们的业务。（问：这句话想表达什么？）\n\n\n\n举行客户和开发人员的联席会议，与客户组织的一些代表共同开发需求。\n\n\n\n复审技术文档。\n提炼方法是针对已经有了部分需求文档的情况。依据产品的本来情况，可能有很多文档需要复审，以确定其中是否包含相关联的信息。在有的情况，也可能只有少数文档需要复审。\n\n\n\n\n\n\n把系统看作一个黑箱，看它对外部的客观世界发挥什么作用，描述它外部可见的行为。\n\n我们可以有很多参与者在这里面。\n优势：易于探讨和理解、易于对需求规范化、有利于进行OOA、有助于发现主动对象、对系统测试来说，产生测试用例、有助于人机界面设计、etc\n系统边界、操作者、用况、关联、包含、扩展、泛化\n\n\n某些事物可能既有一个对象作为其抽象描述，而本身（作为现实世界中的事物）又是在系统边界以外与系统进行交互的操作者。如超市中的收款员，他本身是现实中的人，作为操作者；在系统边界内，又有一个相应的“收款员”对象来模拟其行为或管理其信息，作为系统成分。\n某些事物即使属于问题域，也与系统责任没有什么关系。如超市中的保安员，在现实中与超市有关系，但与所开发的系统超市商品管理系统无关系。这样的事物既不位于系统边界内，也不作为系统的操作者。\n\n\n\n尽管在模型中使用操作者，但操作者实际上并不是系统的一部分。它们存在于系统之外。\n\n我们可能的操作者。\n\n\n\n从使用视角看：用况是对操作者使用系统的一项功能时所进行的交互过程的描述。\n\n\n\n用况和操作者之间的唯一的关系，但是用况之间还有别的其他的关系。\n\n\n\n从基用况到扩展用况的扩展关系表明：按基用况中指定的扩展条件，把扩展用况的行为插入到由基用况中的扩展点定义的位置。\n\n扩展的适用条件：(1) 异常情况；(2) 正常的变形描述时，而且希望采用更多的控制方式时，采用扩展。即在一个变化点上一个附加多个变体的场合下使用；(3) 用扩展关系来区分可实现系统的可配置部分（问：什么意思？）。\n\n\n\n从基用况到供应者用况的包含关系表明：基用况在它内部说明的某一（些）位置上显式地使用供应者用况的行为的结果。\n（问：包含和扩展有什么区别呢？我的理解是一个是显式地使用包含用况，一个是隐式地使用扩展用况？）\n\n\n\n\n\n\n\n\n\n识别操作者、捕获用况（从操作者的角度来看、从系统功能的角度来看、从场景技术的角度来看）、系统的需求建模、审查\n\n\n\n\n用户+事件。其中用户表现为对主要用户的描述，事件则是场景或系统/任务价值\n用户故事相当于用况图正文的描述说明。UML实际推崇的是用况图，但在敏捷开发中使用面向对象方法时也会将用户故事作为系统的需求描述"
  },
  {
    "objectID": "PDF/OOP/期末复习.html#第三章-uml",
    "href": "PDF/OOP/期末复习.html#第三章-uml",
    "title": "面向对象技术引论期末复习",
    "section": "",
    "text": "UML是系统分析和设计的工具\n\n\n\n\n参与者、信号、实用程序都是类。\n\n为什么对象没有操作栏？这是因为它的操作已经在它的类里面被定义了，而属性栏之所以存在是因为我们在构造这个对象的时候，必须为它填入初始的属性。\n抽象类使用斜体字。\n类可以有所在的包名。\n\n属性的默认语法：[可见性]属性名[:类型][多重性][=初始值][{特性串}]，比如+name: String[0..1] = \"Hello\"{readonly}。\n\n可见性：为什么引入可见性？为了支持信息隐蔽这一软件设计原则。信息隐蔽是指在每个模块中所包含的信息（包括表达信息的数据以及表达信息处理的过程）不允许其它不需要这些信息的模块访问。信息隐蔽是实现模块低耦合的一种有效途径。\n属性名：小写字母开头\n类型名\n多重性：省略的时候默认为[1..1]\n初始值\n性质串：a : integer = 10 {frozen}，这就表示属性是不可改变的\n\n所有的共同的属性，加上下划线，defaultSize这样子的。\n\n\n\n可见性\n符号表示\n关键字表示\n描述\n\n\n\n\n公有的\n+\npublic\n所有其他的类/类目都可以使用\n\n\n受保护的\n#\nprotected\n仅其子类/类目才能使用\n\n\n私有的\n-\nprivate\n仅本类的操作才能使用\n\n\n包内的\n~\npackage\n仅同一包中声名的类/类目才能使用\n\n\n\n操作的默认语法：[可见性] 操作名 [(参数表)] [: 返回类型] [{性质串}]，例：+ set(id : Integer, name : String) : Boolean {...}。\n参数表里的每个参数还可以如下：[方向] 参数名 : 类型 [= 默认值]，比如in name: String = \"Hello\"。\nin输入参数，inout输入参数可修改，out输出参数。\n衍型：类型的类型，用双尖括号包裹起来。&lt;&lt;datatype&gt;&gt;。\n\n\n\n\n\n\n\n\n\n\n协作是一个交互，涉及交互三要素：交互各方、交互方式以及交互内容 。\n使机器人沿着一条路径移动所涉及的类 \\(\\rightarrow\\) 一个协作\n\n\n\n一个用况描述了系统的一个完整的功能需求。\n用况是通过协作予以细化的。\n\n\n\n进程和线程都是主动类。\n主动类对象的行为通常与其他元素的行为是并发的。\n至少具有一个进程或线程的类，能够启动系统的控制活动。\n\n\n\n在遵循并提供了一组外部接口的实现的同时，隐藏内部实现。构件是描述比特世界的软件制品的系统单位。\n应用、文档、库、页和表都是构件。\n\n\n\n\n系统中包含物理信息的、可替代的物理部件。\n这里说部件是“物理的”，指软件未运行时也存在的部分，主要指文件，如源代码、可执行程序、脚本等；软件系统中可能会存在不同类型的部署制品；制品通常代表对源代码/运行时信息的物理打包。\n\n\n\n\n在运行时存在的物理元素，通常它表示一种具有记忆能力和处理能力的计算机资源（比如服务器、数据库管理系统等）\n这里的“物理的”指实际机器设备；一个构件可以驻留在一个节点中，也可以从一个节点移到另一个节点。\n\n\n\n\n\n\n\n它指明一个类的对象与另一个类的对象间的联系。如果类的对象之间通过属性有连接关系，那么这些类之间的语义关系就是关联。链是关联的实例，是对象间的语义连接，是对象引用的元组（列表）。 在最常见的情况下，它是一对对象引用。\n关联表示对象之间的静态联系。\n\n这里的多重性是一个教师可以指导0到多个学生的论文，而一个学生只能被一个教师指导论文。\n\n还可以用关联导航来解决。\n\n角色和关联端名：\n\n限定符：\n\n\n\n一种特殊形式的关联，表达一种“整体 /部分”关系。即一个类表示了一个大的事物，它是由一些小的事物（部分）组成的。\n\n\n\n\n组合是一种特殊的聚合。组合中的对象具有相同的生命周期。\n组合的末端的多重性不能超过1。因为一个对象最多组合成另一个对象。\n在一个组合中，由一个链所连接的对象而构成的任何元组，必须都属 于同一个整体类的对象（问：没有理解这句话）\n\n\n\n\n\n关联类：具有关联和类特性的模型元素，可以被看作是关联，但还有类 的特性；或被看作是一个类，但有关联的特性。\n\n比如我们能认为大学和教师之间的关联是通过任务来获得的。\n\n\n\n“is-a-kind-of” 继承关系又称为一 般一特殊关系，在UML中把继承关系称为泛化关系。\n\n\n\n\n在两个地方会使用实现的关系：接口与实现它们的类和构件之间；用况与实现它们的协作之间。\n\n\n\n\n依赖是一种使用关系，用于描述一个类目使用另一类目的信息和服务。\n\n\n\n\n\n\n使用“关联”，模型化系统中存在的大量静态结构和动态结构。\n\n以数据驱动：一个对象需要导航到另外一个对象\n以行为驱动：一个对象需要与另一个对象交互\n\n\n\n使用“泛化”，对系统中存在的一般/特殊关系规约。\n\n\n\n使用“实现”，对系统中存在的精化关系规约\n该术语用于表达不同抽象层之间的精化，体现“自顶向下，逐步求精” 的思想。如系统需求层的用况，可通过协作实现。这两者即可用 “实现”规约。\n\n\n\n使用“依赖”，对不是结构、继承、精化的关系规约。\n某类只作为另一类的操作参数，则可将它们之间的关系抽象为依赖\n\n\n\n\n\n\n\n\n可以在小矩形里写包名，大矩形中表示内容。\n也可以这样画：\n\n引入依赖和访问依赖。\n\n这样表示Controller可以访问Components和Subcomponents。\n\n\n\n注解可以是简单文字，也可以内嵌URL或文档链接，用虚线连接到所解释说明的模型元素上。\n\n\n\n\n\n\n\n类图显示了类（及其接口）、类的内部结构以及与其他类的联系。是面向对象分析与设计所得到的最重要的模型。\n\n\n\n用对象图说明在类图中所发现的事物的实例的数据结构和静态快照。\n\n\n\n就是用来表示构件之间的关系的图。\n\n\n\n\n\n\n\n\n\n\n外扩图是在UML2.5的基础上定义新建模元素的图，用以增加新的建模能力\n\n\n\n\n所以这个图可以和构件图结合在一起。\n\n\n\n\n\n\n通常都是对反应型对象（reactive object）的行为进行建模。\n\n状态机图是描述一个对象或其他实体在其生命周期中所经历的各种状态以及状态变迁的图.\n一个状态机图，规约了一个对象在其生存期内因响应事件所经历的状态序列以及对这些事件所作出的响应。\n状态之间的转化是即时的。\n延迟事件：延迟事件是指在当前状态下暂不处理，但将推迟到该对象的另一个状态下排队处理的事件。比如我现在想要识别出某一个事件，但是我现在不处理。activity/defer\n事件：事件就是状态转移的实心线上面标记的东西。activity(parameter1: Type1, ...)。\n\n信号（Signal）事件：信号是一种Type，所以它的原类型是signal。这里是衍型。\n调用（Call）事件：一个调用事件表示对象接收到一个操作调用的请求。\n时间事件：时间事件后跟有计算时间量的表达式。after (2 seconds)。\n变化事件：指定条件变为真了，譬如at (xxx)/selfTest(), when (altitude &lt; 1000)。\n\nactivityName[(Parameter list)][Guard][/Action]。比如：right-mouse-down(location)[location in window]/object:=pick_object(location)。\nUML内置关键字：\n\nentry：进入状态时首先执行该动作。它不能有参数或监护条件。\nexit：在退出状态时最后执行该动作。它不能有参数或监护条件。\ndo：在状态的进入动作表达式（如果有）执行后，开始执行do活动，并且do活动可与其他的动作或者活动并行。\n\n状态间的转移 vs. 状态内的转移 ： 如果源状态和目标状态都是自身，那么会先触发该状态的退出动作，再执行该状态的进入动作，和状态内的转移有区别。\n\n\n\n顺序子状态机（非正交）和并发子状态机（正交）\n非正交状态机：最多有一个子初态和一个子终态。\n\n转移到该组合状态：这个被嵌套的子状态机一定有一个初态，以便在进入该组合状态并执行其进入动作后，将控制传送给这一初态。\n转移到该组合状态的一个子状态：在执行完该组合状态的进入动作（如有的话）和该子状态的进入动作后，将控制传送给这一子状态。\n\n\n离开的时候：首先离开被嵌套的状态，即执行被嵌套状态的退出动作（如有的话）；然后离开该组合状态，即执行该组合状态的退出动作（如有的话）。\n正交状态机：控制流分岔，分成了并发流。\n\n\n\n\n动作是原子的和即时的。\n对象是方的矩形，而动作是圆角的矩形。\n\n\n\n\n一种详细表示 对象之间以及对象与参与者实例之间交互的图，它由一组协作的对象（或参与者实例）以及它们之间可发送的消息组成，它强调消息之间的顺序。\n对象：[ObjectName]: ClassName。\n参与者：一个小人\n对象生命线：一个垂直虚线，用X表示被析构。\n执行规约：窄长的矩形。\n消息：同步消息：实心的箭头，返回虚线箭头 异步消息：实现，空心的箭头\n\n消息分支：把分支画成从一个点出发的多个箭头，每个箭头由监护条件标示\n消息循环：*Message[Guard]，表示按照给定的表达式一直发送信息。\n回调机制：申请对象在服务对象处事先登记所关心的事件，然后继续从事自己的工作；当服务对象监控到这样的事件发生时，再通知申请对象，由申请对象进行处理。这是一个异步的。\n\n\n选择（opt,为真才执行）、条件（alt,有两种选择）、并发（par,同时做）、迭代（loop guard,循环）\n\n\n\n\n\n为表示一个消息的时间顺序，给消息加一个数字前缀（从1号消息开始），在控制流中，每个新的消息的顺序号单调增加（如2，3等等）。为了显示嵌套，可使用带小数点的号码（1表示第一个消息；1.1表示嵌套在消息1中的第一个消息；1.2表示嵌套在消息1中的第二个消息；等等）。\n通信图和顺序图两者语义上是等价的。\n\n\n\n\n用于描述系统的宏观行为，是活动图和顺序图的混合物。\n\n\n\n用于表示交互，它展现了消息跨越不同对象或角色的实际时间，而不仅仅关心消息的相对顺序。"
  },
  {
    "objectID": "PDF/OOP/期末复习.html#第四章-ooa",
    "href": "PDF/OOP/期末复习.html#第四章-ooa",
    "title": "面向对象技术引论期末复习",
    "section": "",
    "text": "运用面向对象方法，对问题域（被开发系统的应用领域）和系统责任（所开发系统应具备的职能）进行分析和理解 。\n\n\n\n\n\n\n\n\n发现对象，定义他们的类。\n识别对象的内部特征：定义属性、定义操作。\n识别对象的外部关系：分类关系（继承）、构成关系、静态联系、使用关系\n给出系统的相关顺序图、状态图和活动图等，以建立系统的动态模型\n划分包，建立系统的包图\n建立系统的详细说明\n\n\n\n\na） 信息组织的复杂性：\n抽象:从许多事物中舍弃个别的、非本质的特征，抽取共同的、本质性 的特征：系统中的对象是对现实世界中事物的抽象； 类是对象的抽象；一般类是对特殊类的抽象； 属性是事物静态特征的抽象； 操作是事物动态特征的抽象。\n分类机制:把具有相同属性和操作的对象划分为一类，用类作为这些对象 的抽象描述。\n继承:特殊类的对象拥有其一般类的全部属性和服务（一般-特殊结构）；\n聚合:把一个复杂的事物看成若干比较简单的事物的组装体，从而简化对 复杂事物的描述。（整体-部分结构）\n消息通讯：要求对象之间只能通过消息进行通讯，而不允许在对象之外 直接地存取对象内部的属性。\n多个视图：从多个角度认识系统\nb） 文档组织的复杂性—控制机制\n包：使模型具有大小不同的粒度层次，以利于控制复杂性"
  },
  {
    "objectID": "PDF/OOP/期末复习.html#第五章-ood",
    "href": "PDF/OOP/期末复习.html#第五章-ood",
    "title": "面向对象技术引论期末复习",
    "section": "",
    "text": "瀑布模型和喷泉模型\n\n\n\n\n\n\n\n不强调次序，逐个设计每个部分。\n\n\n它是在OOA模型基础上按实现条件进行必要的修改、调整和细节补充而得到的。\n实现条件：\n\n编程语言：对问题域的影响最大。选定的编程语言不支持某些面向对象的概念与原则；OOA阶段可能将某些与编程语言有关的对象细节推迟到OOD阶段来定义。如对象的创建、删除、复制、转存、初始化等系统行为、属性的数据类型等。\n\n为复用设计与编程的类而增加新的结构\n增加一般类以建立共同协议（比如：提供创建、删除、复制等操作，Java里面的object就可以体现这个问题，它是所有的类的父类，所有的类都要继承它）object{复用}\n按编程语言调整继承和多态：如果编程语言不支持多继承怎么办？（方法1：采用聚合，把多继承转换为单继承，方法2：重新定义对象类，方法3：压平）如果编程语言不支持继承怎么办？（方法1：把继承结构展平，所有需要的信息都放到展平后的类里面去；方法2：再加上聚合，每个类不存在信息冗余）如果编程语言不支持多态怎么办？重新命名函数。\n提高性能：调整对象分布，合并通讯频繁的类\n为实现对象永久存储做的修改\n为编程方便增加底层成分\n对复杂关联的转化并决定关联的实现方式：多对多关联转化为一对一关联\n调整与完善属性\n构造和优化算法\n决定对象间的可访问性\n定义对象实例：当系统需要通过从外存读取数据来创建一个对象时 ，先创建该对象，再从外存中读取这个对象数据，把数据赋值给对象的相应属性。\n\n硬件、操作系统及网络设施\n\n复用支持\n数据管理系统\n界面支持系统\n\n\n（道理：尽管继承和聚合反映了现实世界中两种不同的关系，但是从最终效果来看却存在共性－都是使一个类的对象能够拥有另一个（一些）类的属性和操作。）\n\n（重新审视原来用多继承结构表达的实际事物及它们之间的关系。例如，上述例子换一个角度看问题：形成这种分类的原因使什么？从而增加“身份”类，构成单继承。）\n\n（缺点：损失了信息）\n为什么要这么做：使反映问题域本质的总体框架和组织结构长期稳定，而细节可变；稳定部分与可变部分分开，使系统从容地适应变化；有利于同一个分析用于不同的设计与实现；支持系统族和相似系统的分析设计及编程结果复用；使一个成功的系统具有超出其生存期的可扩展性\n\n\n\nOOD要设计人机交互的细节，而OOA用人机交互来反映需求\n\n分析与系统交互的人：设计时重点考虑比例最大的人员情况，并适当地兼顾其他人。\n从use case分析人机交互\n\n人机交互界面的设计准则：使用简便、一致性、启发性、减少人脑记忆的负担、减少重复的输入、容错性、及时反馈、防止灾难性的错误\n\n\n\n控制流驱动部分，用于定义和表示并发系统中的每个控制流。用主动对象表示每个控制流(进程、线程) ，所有的主动类构成控制驱动部分\n如何设计控制驱动部分：用包括主动类的类图捕捉控制流的静态结构；用包括主动对象的顺序图或通信图捕捉控制流的动态行为。\n\n\n\n数据管理部分是负责在特定的数据管理系统中存储和检索持久对象的组成部分\n其目的是，存储问题域的持久对象、封装这些对象的查找和存储机制，以及为了隔离数据管理方案的影响\n文件系统、R-DBMS（关系数据库系统）、OO-DBMS（面向对象数据库系统）\n\n\n\n面向对象\n实体-联系\n关系数据库\n\n\n\n\n类\n实体类型\n表\n\n\n对象\n实体实例\n行\n\n\n属性\n属性\n列\n\n\n关系\n关系\n表\n\n\n\n\n这个关联的表是右下角，应该是一种 link1 : {EmployeeNumber , Location}这样的一行。\n如果是1对多，可以为比如公司职员记录公司ID这个属性。或者是公司ID和职员ID建立一个关联表。\n如果是多对多呢：\n\n还有对父类和子类的关系的存储可以有下面的三种情况：\n\n（下推）：为每一个子类定义一张单独的表。当增加新的父类或者子类的时候对数据库的维护和修改是很大的麻烦。\n（上拉）去掉继承的网络结构。对实例要存储大量的冗余。\n（分割表）将父类和子类的状态存储在不同的表中。这种方法很好地反映了继承网格，但它的缺点是访问数据时需要许多跨表连接。\n\n对象存储器。\n\n\n\n构件具有端口和接口。\n接口是一个圆圆的或者半圆的，端口是一个方形的那个。"
  },
  {
    "objectID": "PDF/OOP/期末复习.html#第六章oopoopl",
    "href": "PDF/OOP/期末复习.html#第六章oopoopl",
    "title": "面向对象技术引论期末复习",
    "section": "",
    "text": "语言元素可以支持\n\n类的定义\n对象的静态声明或者动态创建\n属性和操作的定义\n继承、聚合、关联和消息的表示\n\n语言机制有：\n\n类机制\n封装机制\n继承机制\n\n高级特性：多态、多继承的表示和支持机制\n\n\n\n纯面向对象语言：Smalltalk、Eiffel、Java\n较为全面的支持OO，强调严格的封装\n混合型：C++、Objective-C、Objective-Pascal、Python\n在一种非OO语言的基础上扩充OO成分、对封装采取灵活的态度\n\n问：为什么说对象指针实现了关联?"
  },
  {
    "objectID": "PDF/OOP/期末复习.html#第七章-设计模式",
    "href": "PDF/OOP/期末复习.html#第七章-设计模式",
    "title": "面向对象技术引论期末复习",
    "section": "",
    "text": "在高层定义接口，隐藏复杂性。可以理解为UI界面。\n或者类似于一个APP的页面。\n\n隐藏复杂性\n可以用来包装遗产系统\n用来检测某项的访问量\n\n\n\n\n将抽象部分与它的实现部分分离，使它们都可以独立地变化\n识别出一个类所具有的两个独立变化的维度，将它们设计为两个继承等级结构，并建立抽象和实现的聚合关系\n\n\n\n\n一个类只有一个实例，并提供全局的访问点。\n全局变量无法阻止多次的实例化，而单例把实例化的方法私有了，这样就只能在一开始创建的时候实例化一次了。\n先判断单例是否已经实例化，没有实例化的话再对实例化函数加锁。\n\n\n\n类似于一个存档。\n\n\n\n\n优势：低耦合！策略可以自由切换，系统扩展性、灵活性更高\n\n\n\n\n\n让所有的实例化都通过工厂来完成。\n可以减少构造对象的时候的复杂性。\n\n\n\n用来创建对象族的。\n\n\n\n\n\n代理还可以再加入一点自己的操作。\n\n\n\n提供访问数据结构的方法\n\n\n\n访问复杂的数据结构\n\n\n\n\n\n\n\n将一个请求封装成一个对象，使得发出请求的责任和执行请求的责任分开。\n\n命令模式降低了耦合，命令的使用者不再需要了解系统底层的逻辑，只需要使用包装好的命令。\n\n\n\n定义一个算法的骨架，把一些操作延迟到子类中进行。\n\n\n\n\n一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。\n\n\n\n还不太理解\n\n\n\n定义一个转换器，将一个类的接口转换成用户需要的另一个接口\n比如要修改数据格式。\n\n\n\n\n对象声明自己的依赖，而该依赖由外部注入的形式为其提供\n可以降低耦合度（如果自己里面再声明一个类，耦合度太高了）"
  },
  {
    "objectID": "PDF/OOP/期末复习.html#第八章-代码风格和编码规范",
    "href": "PDF/OOP/期末复习.html#第八章-代码风格和编码规范",
    "title": "面向对象技术引论期末复习",
    "section": "",
    "text": "防御式编程 ：数组越界、空指针、函数参数、返回值、外部接口。\n考虑到输入的不确定性，在程序代码的主要逻辑之外增加了大量的检查，包括对所有外来数据的检查、对所有输入参数的检查等，并最终决定如何处理不符合预期的输入。\n理解构成良好代码风格的主要因素：\n\n命名—符合语义（是什么、做什么、易于识别）\n注释—合理使用序言式注释与功能性注释\n视觉组织—清晰的缩进、空格与换行\n语句构造—避免太长的子程序、嵌套、语句，避免一行多语句\n输入输出—检查输入输出、简化输入输出步骤、合理的输入输出提示、为输出添加注释\n避免“魔法”—何为魔法串/数字"
  },
  {
    "objectID": "PDF/OOP/期末复习.html#第九章-面向对象测试",
    "href": "PDF/OOP/期末复习.html#第九章-面向对象测试",
    "title": "面向对象技术引论期末复习",
    "section": "",
    "text": "单元测试：集中于每个独立的模块。该测试以详细设计文档为指导，测试模块内的重要控制路径。（往往采用白盒测试技术）\n集成测试：集中于模块的组装。其目标是发现与接口有关的错误，将经过单元测试的模块构成一个满足设计要求的软件结构。\n确认测试（有效性测试）：目标是发现软件实现的功能与需求规格说明书不一致的错误。（通常采用黑盒测试技术）\n系统测试：集中检验系统所有元素（包括硬件、软件）之间协作是否合适，整个系统的性能、功能是否达到。\n\n\n\n\n\n主要依据详细设计说明书和源代码清单\n主要测试模块的I/O条件和模块的逻辑结构\n主要采用白盒测试方法设计测试用例，辅以黑盒测试的测试用例，使之对任何合理的和不合理的输入都要鉴别和响应\n要对所有的局部和全局数据结构、外部接口和程序代码的关键部分进行代码审查\n\n\n\n\n\n\n\n把各个模块连接起来的时候，穿越模块接口的数据是否丢失\n\n一个模块的功能是否对另一个模块的功能产生不利的影响\n\n各个子功能组合起来，能否达到预期要求的父功能\n\n全局数据结构是否有问题\n\n单个模块的误差累加起来，是否达到不可接受的程度\n\n集成测试的方法：一次性组装方法、增量式组装方法\n\n\n\n有效性测试，即验证软件的功能和性能及其他特性是否与用户的要求一致\n有效性测试是在模拟的环境（可能是开发环境）下，运用黑盒测试的方法，验证被测软件是否满足需求规格说明书列出的需求。\n软件配置审查是保证软件配置的所有成分齐全，各方面的质量符合要求，具有维护阶段所必须的细节，并且已编排好分类的目录。\n\n\n\n\n集中检验系统所有元素（包括硬件、信息等）之间协作是否合适，整个系统的性能、功能是否达到。\n系统测试实际上是一系列不同的测试，以下是用于系统测试的几种典型软件系统测试：\n\n功能测试：在规定的时间内运行软件系统的所有功能，以验证这个软件系统有无严重错误。\n恢复测试：是一种系统测试，它指采取各种人工干预方式强制性地使软件出错，使其不能正常工作，进而检验系统的恢复能力\n安全性测试：就是试图去验证建立在系统内的预防机制，以防止来自非正常的侵入\n强度测试：是在非正常数量、频率或容量资源方式下运行一个系统 （已经不正常了）\n压力测试：系统正常运行的最低限度\n性能测试：测试软件在被组装进系统的环境下运行时的性能 （还是正常的）\n可用性测试：从使用的合理性、方便性等角度对软件系统进行检验，以发现人为因素或使用上的问题\n部署测试（配置测试）：软件必须在多种平台及操作系统环境中运行。有时将部署测试称为配置测试，是在软件将要在其中运行的每一种环境中测试软件。另外，部署测试检查客户将要使用的所有安装程序及专业安装软件，并检查用于向最终用户介绍软件的所有文档。\n\n\n\n\n\n\n\n也就是类测试。面向对象软件的类测试相当于传统软件中的单元测试，类包含的操作是最小的可测试单元\n功能性测试：以类的规格说明为基础，主要检查类是否符合规格说明的要求。功能性测试包括两个层次：类的规格说明和方法的规格说明\n结构性测试：从程序出发，对类中的方法进行测试，需要考虑其中的代码是否正确。测试分为两层 ：第一层考虑类中各独立的方法，即方法要做单独测试；第二层考虑方法之间的相互作用，即方法需要进行综合测试\n基于状态的测试：基于状态的测试是通过检查对象的状态在执行某个方法后是否会转移到预期状态的一种测试技术；跟踪监视对象数据成员的值的变化。\n\n\n\n基于线程的测试（thread-based testing）：对响应系统的一个输入或一组类进行集成，每个线程单独地集成和测试事件所需的，应用回归测试以确保没有产生副作用\n基于使用的测试(use-based testing)：通过测试很少使用服务类的那些类（称之为独立类）开始构造系统，独立类测试完后，利用独立类测试下一层次的类（称之为依赖类）。继续依赖类的测试直到完成整个系统\n簇测试（cluster testing）是面向对象软件集成测试中的一步 ：利用试图发现协作中的错误的测试用例来测试协作的类簇\n\n\n\n功能测试、强度测试、性能测试、安全测试、回复测试、可用性测试、安装/卸载测试\n\n\n\n\n\n\n\n对认定的对象的测试：\n\n测试认定的对象是否全面，是否问题空间中所有涉及的实例都反映在认定的抽象对象中\n\n测试认定的对象是否具有多个属性，只有一个属性的对象通常应看成其他对象的属性，而不是抽象为独立的对象\n\n测试被认定为同一对象的实例是否具有区别于其他实例的共同属性\n\n测试被认定为同一对象的实例是否提供或者需要相同的服务。如果服务随着不同的实例而变化，那么认定的对象就需要进行分解或者继承来分类表示\n\n认定的对象的名称应该尽量准确、适用\n\n结构分为两类：分类结构（一般-特殊）和组装结构（整体-部分）\n对认定的分类结构的测试。\n对认定的组装结构的测试。\n对定义的属性和实例关联的测试\n对定义的服务和消息关联的测试\n\n\n\n对认定的类的测试\n对构造的类层次结构的测试\n对类库支持的测试\n\n\n\n数据成员是否满足数据封装的要求\n类是否实现了要求的功能"
  },
  {
    "objectID": "course_notes.html",
    "href": "course_notes.html",
    "title": "Course Notes",
    "section": "",
    "text": "Here are the course notes written by myself. I’ve taken 67 courses (170 points) in PKU.\n\n25-26-1\n9 courses, 23 points in total.\n\nMathmatical Logic | Click here to view the notes.  数理逻辑 | 点击此处查看笔记.\nSet Theory and Graph Theory | Click here to view the notes.  集合论与图论 | 点击此处查看笔记.\nShadowboxing  太极拳\nFrontiers of Economics Research and Practice  经济学学术与实践前沿\nMoney and Banking  货币银行学\nInternational Finance | Click here to view the notes.  国际金融 | 点击此处查看笔记.\nBehavioral Economics | Click here to view the notes.  行为经济学 | 点击此处查看笔记.\nInvestment  投资学\nThe Economics of Artificial Intelligence  人工智能经济学\n\n\n\n24-25-3\n2 courses, 4 points in total.\n\nTopics in Quantitative Finance | Click here to view the website.  量化金融专题 | 点击此处访问网站.\nInter-cultural Communication  跨文化交流学\n\n\n\n24-25-2\n8 courses, 20 points in total.\n\nIntroduction to Database Systems | Click here to view the PDF.  数据库概论 | 点击此处查看PDF.\nPublic Intermediate German  公共中级德语\n\nThe notes. 课程笔记.\nThe tests. 课程小测.\nThe words. 课程单词.\nHere are two passages full of grammer mistakes: Ein Programmierer and Meine Ferien.\n\nSpecial Topics in China Economic Research | Click here to view the PDF.  中国经济专题 | 点击此处查看PDF.\nIntermediate Microeconomics  中级微观经济学\nProgramming in Rust  Rust程序设计\nOrienteering and Hiking  定向与徒步运动\nOperating Systems (Honor Track)  操作系统 (实验班)\nModern Astronomy  现代天文学\n\n\n\n24-25-1\n7 courses, 21 points in total.\n\nPublic Junior German | Click here to view the PDF.  公共初级德语 | 点击此处查看PDF.\nEconometrics | Click here to view the PDF.  计量经济学 | 点击此处查看PDF.\nSoftware Engineering  软件工程\n\nThe notes. 课程笔记.\nThe Assignments. 课程作业.\n\nHomework 1\nHomework 2\nHomework 3\n\n\nA Survey of Mao Tsetung Thoughts and Theory of Socialism with Chinese Charateristics  毛泽东思想和中国特色社会主义理论体系概论\nSoftware Analysis | Check Prof. Xiong’s Course Website  软件分析技术 | 查看课程网站\nCompiler Principles  编译原理\nLabor Practice for Electronics Engineering and Computer Science  信息科学技术劳动实践\n\n\n\n23-24-3\n2 courses, 3 points in total.\n\nPhysical and Aesthetic course  体美\nAural Culture and World Civilization  听觉文化与世界文明\n\n\n\n23-24-2\n9 courses, 24 points in total.\n\nIntroduction to Object Oriented Technology | Click here to view the final-term notes.  面向对象技术引论 | 查看期末复习笔记\nComparative Constitutional Law  外国宪法\nAcademic English Listening and Speaking  学术英语听说\nAlgorithm Design and Analysis  算法设计与分析\nInformation Theory  信息论\nHistory of Rome | Click here to view the PDF.  罗马史 | 点击此处查看PDF.\nSoftware Foundations | Check Prof. Xiong’s Course Website  软件科学基础 | 查看课程网站\nProbability theory and statistics in Information science  信息学中的概率统计\nIntermediate Macroeconomics  中级宏观经济学\n\n\n\n23-24-1\n8 courses, 24 points in total.\n\nHuman Sex, Reproduction and Health | 【三宝课X47小组期中作业】  人类的性、生育与健康 | 【三宝课X47小组期中作业】\nMusic and Mathematics | Click here to view the PDF.  音乐与数学 | 点击此处查看PDF.\nData Structure and Algorithm (A)  数据结构与算法 (A)\nAn Introduction to Marxist Basic Theory  马克思主义基本原理概论\nIntroduction to Discrete Mathmatics  离散数学基础\nPrinciples of Economics  经济学原理\nIntroduction to Computer Systems  计算机系统导论\nLabor Theory  新时代劳动理论\n\n\n\n22-23-2\n8 courses, 24 points in total.\n\nText and Meaning: British and American Short Stories  英美短篇小说文本分析与鉴赏\nIntroduction to Artificial Intelligence  人工智能引论\nPractice of Programming in C&C++  程序设计实习\nOutline of Chinese Modern History  中国近现代史纲要\nIntroduction to Xi Jinping Thought on Socialism with Chinese Characteristics for a New Era  习近平新时代中国特色社会主义思想概论\nLinear Algebra A (II)  线性代数A (II)\nAdvanced Mathematics A (no.2)  高等数学A (二)\nSocial practice and service learning, Part II  思想政治实践（下）\n\n\n\n22-23-1\n11 courses, 27 points in total.\n\nIntroduction to Seismology  地震概论\nIntroduction to Computation (A)  计算概论A\nAdvanced Mathematics A (no.1)  高等数学A (一)\nFootball  足球\nPhysics for Information Sciences (1)  信息科学中的物理学 (上)\nLinear Algebra A (I)  线性代数A (I)\nIntroduction to Information Science and Technique  信息科学技术概论\nAn Introduction to Ideological & Moral Culture and Laws  思想道德修养与法律基础\nEvents and Policies  形势与政策\nMilitary Theory  军事理论\nSocial practice and service learning, Part I  思想政治实践（上）\n\nTO BE CONTINUED …"
  },
  {
    "objectID": "Course_Notes/国际金融/国际金融.html",
    "href": "Course_Notes/国际金融/国际金融.html",
    "title": "《国际金融》复习笔记",
    "section": "",
    "text": "金本位制是1870年至1913年间逐渐成为主导的国际货币体系。\n\n核心原则：该体系建立在自由兑换原则之上。各国中央银行承诺以固定的铸币平价随时买卖黄金以兑换纸币，并且黄金的进出口不受限制。\n运作机制：各国将本国货币的价值与黄金挂钩（即固定每单位本国货币的黄金价格），而非直接与其他货币挂钩。这创造了一个对称的系统，没有单一的“中心国”。通过黄金套利，汇率被固定在由两国黄金价格之比决定的平价汇率附近小幅波动（即黄金输送点内）。\n自动调节：体系通过价格-铸币流动机制自动纠正贸易失衡。例如，贸易顺差国将流入黄金，导致国内货币供应增加和物价上涨（通货膨胀），进而使实际汇率升值，最终减少贸易顺差。\n兴衰原因：\n\n兴起（1914年前）：全球化进程和技术发展促进了贸易一体化，采用固定汇率（金本位）的收益增加，且对丧失政策自主性（稳定成本）的政治关切有限。\n衰落（1920-1930年代）：国家特定冲击增加、对货币政策自主性的追求增强等因素，导致各国为追求政策自主性而放弃了金本位制。\n\n\n\n\n\n金本位制的不可能三角\n\n\n\n\n\n布雷顿森林体系是第二次世界大战后建立、从1946年运行至1973年的国际货币体系。\n\n核心设计：该体系保留了固定汇率原则，但放弃了金本位下的资本自由流动。它通过实施资本管制来解决“三元悖论”。\n结构：体系以美元为中心。其他成员国将本国货币与美元挂钩，维持固定汇率。而美元自身则按固定价格与黄金挂钩（每盎司35美元）。因此，美国成为体系的中心国家。\n目标与崩溃：\n\n该体系旨在通过维持汇率稳定来鼓励战后贸易重建。\n到了1960年代，体系变得不可持续。主要原因包括：资本流动性无法被有效遏制；以及各国（尤其是越南战争时期美国通胀后）越来越不愿意将本国货币钉住美元。\n最终，主要发达国家转向了浮动汇率制（允许资本流动和货币政策自主性），而布雷顿森林体系在1973年正式终结。\n\n\n\n\n\n布雷顿森林体系的不可能三角\n\n\n总结对比：金本位制是一种以黄金为共同锚的对称性固定汇率体系，依赖自由兑换和资本自由流动。布雷顿森林体系则是一种以美元为锚的非对称性固定汇率体系，通过资本管制来维持汇率稳定，直至其因内外矛盾而解体。"
  },
  {
    "objectID": "Course_Notes/国际金融/国际金融.html#国际货币政策经验",
    "href": "Course_Notes/国际金融/国际金融.html#国际货币政策经验",
    "title": "《国际金融》复习笔记",
    "section": "",
    "text": "金本位制是1870年至1913年间逐渐成为主导的国际货币体系。\n\n核心原则：该体系建立在自由兑换原则之上。各国中央银行承诺以固定的铸币平价随时买卖黄金以兑换纸币，并且黄金的进出口不受限制。\n运作机制：各国将本国货币的价值与黄金挂钩（即固定每单位本国货币的黄金价格），而非直接与其他货币挂钩。这创造了一个对称的系统，没有单一的“中心国”。通过黄金套利，汇率被固定在由两国黄金价格之比决定的平价汇率附近小幅波动（即黄金输送点内）。\n自动调节：体系通过价格-铸币流动机制自动纠正贸易失衡。例如，贸易顺差国将流入黄金，导致国内货币供应增加和物价上涨（通货膨胀），进而使实际汇率升值，最终减少贸易顺差。\n兴衰原因：\n\n兴起（1914年前）：全球化进程和技术发展促进了贸易一体化，采用固定汇率（金本位）的收益增加，且对丧失政策自主性（稳定成本）的政治关切有限。\n衰落（1920-1930年代）：国家特定冲击增加、对货币政策自主性的追求增强等因素，导致各国为追求政策自主性而放弃了金本位制。\n\n\n\n\n\n金本位制的不可能三角\n\n\n\n\n\n布雷顿森林体系是第二次世界大战后建立、从1946年运行至1973年的国际货币体系。\n\n核心设计：该体系保留了固定汇率原则，但放弃了金本位下的资本自由流动。它通过实施资本管制来解决“三元悖论”。\n结构：体系以美元为中心。其他成员国将本国货币与美元挂钩，维持固定汇率。而美元自身则按固定价格与黄金挂钩（每盎司35美元）。因此，美国成为体系的中心国家。\n目标与崩溃：\n\n该体系旨在通过维持汇率稳定来鼓励战后贸易重建。\n到了1960年代，体系变得不可持续。主要原因包括：资本流动性无法被有效遏制；以及各国（尤其是越南战争时期美国通胀后）越来越不愿意将本国货币钉住美元。\n最终，主要发达国家转向了浮动汇率制（允许资本流动和货币政策自主性），而布雷顿森林体系在1973年正式终结。\n\n\n\n\n\n布雷顿森林体系的不可能三角\n\n\n总结对比：金本位制是一种以黄金为共同锚的对称性固定汇率体系，依赖自由兑换和资本自由流动。布雷顿森林体系则是一种以美元为锚的非对称性固定汇率体系，通过资本管制来维持汇率稳定，直至其因内外矛盾而解体。"
  },
  {
    "objectID": "Course_Notes/国际金融/国际金融.html#固定汇率",
    "href": "Course_Notes/国际金融/国际金融.html#固定汇率",
    "title": "《国际金融》复习笔记",
    "section": "固定汇率",
    "text": "固定汇率\n\n一、固定汇率如何运作\n固定汇率制度的核心是中央银行通过干预外汇市场，将本币与一种外币（如美元）或一篮子货币的汇率维持在一个固定的水平（即“钉住”）。\n\n中央银行的资产负债表操作\n\n中央银行通过其资产负债表来管理汇率。其货币负债（货币供给 \\(M\\)）由两类资产支持：国内信贷（\\(B\\)，如持有的本国政府债券） 和外汇储备（\\(R\\)，如持有的美元资产）。即：\\(M = B + R\\)。\n维持汇率稳定的关键在于外汇储备。当市场出现对本币的抛售压力时（即本币有贬值压力），央行会动用外汇储备买入本币，以支撑其价格；反之，当本币有升值压力时，央行会卖出本币、购入外汇以增加储备。\n\n维持钉住的机制\n\n应对货币需求冲击：如果本国货币需求下降（例如，由于产出下降或外国利率上升），为了维持固定汇率和利率平价（\\(i = i^*\\)），央行必须减少货币供给（\\(M\\)）。在国内信贷（\\(B\\)）不变的情况下，央行通过出售外汇储备（\\(R\\) 减少） 来回笼本币，从而抵消货币需求的下滑，使货币市场在固定利率下出清。\n应对国内信贷扩张：如果央行扩张国内信贷（\\(B\\) 增加，例如为政府赤字融资），为了防止货币供给（\\(M\\)）过度增加导致利率下降和本币贬值压力，央行必须同步出售等额的外汇储备（\\(R\\) 减少） 进行“冲销操作”，以保持 \\(M\\) 不变。此时，货币供给的构成（\\(B\\)与 \\(R\\) 的比例）发生变化，但总量不变。\n支持比率：储备与货币供给的比率（\\(R/M\\)）是衡量钉住汇率韧性的关键指标。比率越高，央行应对冲击的能力越强。货币局制度（Currency Board）要求100%的储备支持，被视为“硬钉住”。\n\n\n\n\n\n央行资产负债表\n\n\n\n\n\n央行资产负债表示意图\n\n\n\n\n\n复杂版央行资产负债表\n\n\n\\(M = (\\text{Foreign Assets}-\\text{Foreign Liabilities})+(\\text{Domestic Assets}-\\text{Domestic Liabilities})\\)\n\n\n二、固定汇率如何失败（汇率危机）\n当上述维持机制无法持续时，固定汇率制度就会崩溃，通常伴随本币的大幅贬值。文档主要阐述了两种经典的危机模型：\n\n第一代危机模型：不一致的财政政策（Inconsistent fiscal policies, 基本面危机）\n\n根源：政府持续通过中央银行货币化其财政赤字（即不断扩张国内信贷 \\(B\\)），同时承诺维持固定汇率。\n过程：为对冲国内信贷扩张以维持货币总量不变，外汇储备（\\(R\\)）会持续流失。即使初始储备充足，这种不一致的政策组合（扩张性财政/货币政策 + 固定汇率）最终也会导致储备耗尽。\n崩溃时点：\n\n投资者缺乏远见：储备会逐渐耗尽至零，届时央行无力干预，汇率被迫浮动并立即大幅贬值。 在 \\(t=4\\) 的时刻，此时通货膨胀一下子变为 \\(\\mu\\)（国内信贷的增长率），那么：\\(i = r^* + \\pi = r^*+\\mu\\)，一下子跃变。 同时，\\(M/P=L(i)Y\\)，那么 \\(P\\) 必须立刻变大。\n\n\n\n投资者缺乏远见\n\n\n投资者有远见（投机攻击）：市场会预见到储备必将耗尽和未来的贬值。为了规避资本损失，投资者会提前发起投机攻击，一次性将本币兑换为央行的外汇储备。这会导致储备在耗尽前突然、瞬间枯竭，迫使汇率制度提前崩溃。崩溃发生时，汇率是平滑过渡的，没有跳跃式贬值。 发起投机性攻击的时刻：使得汇率平滑过渡的时刻。 此时货币需求的下降恰好等于储备的流失量。\\(M^d = L(i)YP\\)，只要：\\(\\Delta M^d = \\Delta R = R_c\\) 即可。\n\n\n\n投资者有远见\n\n\n\n\n第二代危机模型：不可信的承诺（contingent commitment, 自我实现的危机）\n\n根源：即使没有持续恶化的基本面（如财政赤字），政府的汇率承诺也可能是有条件（或然）的。当维持钉住的成本超过其收益时，政府可能会选择放弃。\n过程：成本可能来自为维持高利率（例如为匹配锚货币国的紧缩政策）而导致的国内经济衰退（产出缺口）。如果市场参与者预期政府会因为成本过高而放弃钉住，他们就会要求更高的风险溢价（导致本国利率上升），这反过来会进一步加大经济衰退和维持钉住的成本，从而使放弃钉住的预期自我实现。\n关键点：这种危机源于多重均衡和预期的转变。在“好”的均衡中，市场相信钉住会维持，成本低，政府也确实会维持；在“坏”的均衡中，市场怀疑钉住，导致成本升高，政府最终真的放弃了钉住。1992年英国因德国统一后利率上升而被迫退出欧洲汇率机制（ERM）就是一个典型案例。\n\n\n\n不可信的承诺\n\n\n\n\n总结而言，固定汇率通过央行动用外汇储备来对冲内外冲击以维持币值稳定。其失败要么源于根本性的政策不一致导致储备被消耗殆尽（第一代危机），要么源于市场信心崩溃引发的自我实现式投机攻击（第二代危机）。这两种机制都突显了在资本自由流动下，维持固定汇率对政策纪律和可信度的极高要求。"
  },
  {
    "objectID": "Course_Notes/国际金融/国际金融.html#欧元",
    "href": "Course_Notes/国际金融/国际金融.html#欧元",
    "title": "《国际金融》复习笔记",
    "section": "欧元",
    "text": "欧元\n\n一、最优货币区（OCA）理论\n该理论由罗伯特·蒙代尔提出，探讨形成一个共同货币区（如欧元区）在经济上是否最优。其核心标准包括：\n\n市场整合：区域间贸易和资本流动程度高，使用共同货币可降低交易成本与不确定性。\n经济对称性：成员国的经济周期相似，便于共同的货币政策应对冲击。\n劳动力流动性：劳动力能自由跨区域流动，以应对非对称冲击带来的失业问题。\n财政联邦主义：存在中央财政转移机制，可帮助受冲击地区进行调节。\n\n文档指出，与美国相比，欧元区在市场整合度、劳动力流动性和财政转移机制方面较弱，因此许多经济学家认为欧元区并非一个理想的最优货币区。 ### 二、欧洲中央银行（ECB）的主要特征\n\n核心目标：高度专注于维持价格稳定（将通胀率控制在接近但低于2%）。\n强独立性：在货币政策制定上具有高度的工具独立性和目标独立性，免受政治干预。\n禁止性规定：不得为成员国政府财政赤字融资（禁止货币融资），原则上也不充当最后贷款人（此规定在后续危机中有调整）。\n决策机制：由成员国央行行长及执行董事会成员通过共识决策，但透明度较低（不公布会议纪要）。\n\n\n\n三、欧元区的形成与规则\n\n历史背景：1992年《马斯特里赫特条约》确立了建立经济与货币联盟（EMU） 的目标，并于1999年由11个创始国率先启用欧元。\n准入条件（马斯特里赫特标准）：欲加入欧元区的国家需满足：\n\n名义收敛：汇率需在欧盟汇率机制（ERM）内保持稳定至少两年；通胀率和长期利率不得高于三个表现最佳成员国平均值过多（分别不超过1.5和2个百分点）。\n财政纪律：政府赤字不超过GDP的3%；政府债务不超过GDP的60%。\n\n现状：截至讲稿撰写时，欧元区已扩大至20个成员国。\n\n\n\n四、固定汇率与货币联盟的区别\n文档强调，加入货币联盟（如欧元区）比单纯的固定汇率制度（如丹麦加入ERM但保留克朗）要求更高、退出成本也更大。一旦加入欧元区，将永久丧失独立的货币政策和汇率调整工具。\n\n\n五、欧元区的挑战与争议\n\nOCA标准的内生性：有观点认为，加入货币联盟本身可能通过促进贸易一体化而事后满足OCA标准，但也可能因专业化加深而加剧经济不对称。\n政治动机：一些国家（如东欧国家）加入欧元区可能出于政治、安全或战略考量，而非纯粹的经济合理性。\n危机暴露的结构缺陷：2008年全球金融危机后，欧元区暴露出以下根本性弱点：\n\n缺乏真正的财政联盟和中央预算稳定机制。\n缺乏银行业联盟，银行监管和救助责任仍在成员国层面，容易形成“主权-银行恶性循环”。\nECB作为最后贷款人的角色最初受限，加剧了危机应对的难度。\n劳动力流动性不足，加剧了成员国间调整的困难。\n\n\n总结：第17讲系统阐述了欧元区的经济理论基础（OCA）、核心机构（ECB）的设计与职权、历史形成过程以及其内在的结构性矛盾。它指出，尽管欧元区在平稳时期实现了低通胀目标，但其在市场整合、劳动力流动、财政与银行业联盟等方面的不足，使其在应对非对称经济冲击时面临严峻挑战，这些矛盾在2008年后的危机中充分显现。\n\n\n\nSymmetry-Integration Diagram"
  },
  {
    "objectID": "Course_Notes/国际金融/国际金融.html#宏观经济的问题",
    "href": "Course_Notes/国际金融/国际金融.html#宏观经济的问题",
    "title": "《国际金融》复习笔记",
    "section": "宏观经济的问题",
    "text": "宏观经济的问题\n\n一、核心内容概述\n本讲聚焦于解释两个长期存在的国际宏观经济学经验谜题：\n\n购买力平价（PPP）谜题：为何现实中汇率并不总是等于两国价格水平之比（即绝对PPP不成立）？\n无抛补利率平价（UIP）谜题：为何现实中高利率货币并未如理论预测那样发生贬值以抵消利差（即UIP不成立）？\n\n\n\n二、对购买力平价（PPP）谜题的解释\n文档从两个角度解释了长期汇率对PPP的偏离：\n\n套利限制（交易成本）：\n\n由于运输成本、关税、监管壁垒等交易成本的存在，商品套利并非完全无摩擦。\n这导致实际汇率 \\(q = EP^*/P\\) 可以在一个 “无套利区间” \\(\\left[ \\frac{1}{1+c}, 1+c \\right]\\) 内波动，而不会引发套利行为，其中 \\(c\\) 为交易成本率。\n因此，PPP在长期也可能不成立，交易成本越高，偏离越大。\n\n\n\n交易成本\n\n\n\n非贸易品与巴拉萨-萨缪尔森效应：\n\n经济体中存在非贸易品（如理发、住房服务），其价格无法通过国际套利均等化。\n巴拉萨-萨缪尔森模型指出，贸易品部门的生产率增长会推高整体工资水平，进而抬升非贸易品的价格。\n因此，生产率增长更快的国家，其整体价格水平会上升，导致实际汇率升值（\\(q\\)下降）。这解释了为何富国（高生产率）的物价水平通常高于穷国，以及为何经济增长伴随本币实际升值。\\(A\\) 是 productivity。 \\[\n\\frac{\\Delta q}{q} = n \\times \\left(\\frac{\\Delta A^*}{A^*}-\\frac{\\Delta A}{A}\\right).\n\\]\n\n\n\n\n三、对无抛补利率平价（UIP）谜题的解释\n文档从风险和收益的角度进行解释：\n\n套利交易与风险：\n\nUIP谜题表现为：投资者借入低利率货币、投资高利率货币的套利交易，在现实中往往能获得持续的正收益，而非UIP预测的零收益。\n这揭示了外汇市场存在套利限制，主要原因是风险。汇率变动具有不可预测的波动性，可能侵蚀利差收益甚至造成亏损。\n\n夏普比率与风险调整后收益：\n\n文档引入夏普比率（超额收益与标准差之比）来衡量风险调整后的回报。 \\[\n\\text{Sharpe Ratio}=\\frac{\\mathbb{E}[R_A-R_F]}{\\sigma_A}.\n\\]\n实证表明，尽管套利交易可能提供正的平均超额收益，但其收益波动（风险）极大，导致其夏普比率并不高，甚至低于美国股票市场。\n因此，看似违背UIP的获利机会，实际上并未提供足够高的风险调整后回报来吸引无限套利，从而“谜题”在考虑风险后得以部分化解。\n文档也提及了“比索问题”，即对低概率大幅贬值事件的担忧，可能导致高利率持续存在。\n\n\n\n\n四、关于市场效率的附带观点\n在讨论UIP谜题的最后，文档引用了一段观点指出：主动管理基金的频繁交易活动有助于市场保持信息效率和价格发现功能，这使得普通投资者采取被动指数化投资（如将70%资金投入全市场指数基金，30%投入国际指数基金）成为一种合理且“寄生性”的明智选择。\n总结：第18讲系统性地阐述了PPP和UIP两大经典理论在实证中失效的原因。PPP的偏离主要源于实际摩擦（交易成本）和结构性差异（非贸易品与生产率）；而UIP的偏离则主要源于金融市场的风险，使得套利行为受限，风险调整后的收益并不异常。最后，提到了主动投资与被动投资的关系。"
  },
  {
    "objectID": "Course_Notes/国际金融/国际金融.html#宏观经济问题-ii",
    "href": "Course_Notes/国际金融/国际金融.html#宏观经济问题-ii",
    "title": "《国际金融》复习笔记",
    "section": "宏观经济问题 II",
    "text": "宏观经济问题 II\n\n一、主权债务与违约\n\n主权债务的特征与违约历史：主权债务是一种或有债权（contingent claim），违约历史悠久（最早可追溯至公元前四世纪）。违约在新兴市场和发展中国家是反复出现的问题。\n违约的动机与成本：\n\n违约收益：国家可以停止偿还债务，保留资金。\n违约成本（惩罚）：\n\n金融市场惩罚：违约后一段时间内被排除在信贷市场之外，信用评级下调，风险溢价上升，且难以用本币借款。\n更广泛的宏观经济成本：可能引发“双重危机”（违约与汇率危机）或“三重危机”（违约、汇率危机与银行危机），导致投资损失、贸易萎缩和经济衰退。数据显示，三重危机的平均成本高达GDP的21.7%，且持续时间更长。\n\n\n违约概率模型：通过一个理论模型说明，当一国产出（\\(Y\\)）低于某个阈值（\\(Y_T\\)）时，政府会选择违约（因为违约后的消费 \\((1-c)Y\\) 高于还款后的消费 \\(Y - (1+r_L)L\\)）。违约概率随债务水平（\\(L\\)）和产出波动性（\\(V\\)）的增加而上升。贷款人则会根据违约风险提高贷款利率（\\(r_L\\)）以平衡预期收益。\n\n\n\n违约概率模型\n\n\n图中浅色的部分是还款的概率，深色的部分是违约的\n应用与案例：\n\n新兴市场债务的回报：从历史数据看（1970-2000年），新兴市场债务的事后（ex post）回报率（约9.1%）在考虑其高风险后，表现并不优于美国国债或公司债，表明贷款人仅能盈亏平衡。\n阿根廷危机（2001-02年）：作为一个案例，说明了基本面恶化（如高额财政赤字、外部债务攀升、联系汇率制僵化）如何使经济体更容易发生自我实现的危机。\n\n\n\n\n二、全球失衡与2007-09年全球金融危机\n\n危机背景：全球失衡：\n\n危机前，新兴市场国家（EM）持续积累经常账户盈余（“储蓄过剩”），并将大量资本（以官方外汇储备形式）流向发达国家（DM），尤其是美国。\n这压低了全球利率，刺激了发达国家（特别是美国）的信贷过度扩张和资产价格泡沫。\n\n加剧危机的政策与扭曲：\n\n发达国家过于宽松的货币政策（如美联储长期维持低利率）。\n监管与监督的失败：金融监管放松（如美国1999年废除《格拉斯-斯蒂格尔法案》），金融创新过度，导致“大而不能倒”的机构产生巨大风险。\n政府失灵：对“大而不能倒”机构的隐性担保引发道德风险。\n市场失灵：非理性投资者行为、羊群效应、信息不对称等。\n\n危机的爆发与传导：\n\n美国房地产市场下滑和次级抵押贷款问题引发连锁反应，通过金融加速器机制（如财富效应、信贷紧缩）严重抑制了实体经济需求，导致“大衰退”。\n恐慌情绪推高了风险利差（如TED利差），并使美元作为避险资产升值。\n\n教训与政策启示：\n\n需要将宏观经济结果与金融状况更紧密地联系起来。\n政策目标应同时兼顾价格稳定、就业和金融稳定。\n利率政策应与宏观审慎政策相结合，以维护金融体系稳定。\n\n\n总结：第19讲深入探讨了国际宏观经济学中的两个重要现实问题：主权违约的成因与高昂成本，以及全球金融危机的根源与深刻教训。核心结论是，金融市场的惩罚和更广泛的经济危机风险是约束主权债务偿还的重要机制；而金融体系的脆弱性与宏观经济失衡的相互作用，是导致全球金融危机并使其影响深化的关键。"
  },
  {
    "objectID": "Blogs/TPC-1.html",
    "href": "Blogs/TPC-1.html",
    "title": "第一届定理证明竞赛",
    "section": "",
    "text": "2025 年 11 月 29 日 下午 12:30 - 17:30, 中国软件大会会场 (武汉国际会议中心).\nCoq.8.20.1, with VST.2.15"
  },
  {
    "objectID": "Blogs/TPC-1.html#谓词与互归纳证明50-分",
    "href": "Blogs/TPC-1.html#谓词与互归纳证明50-分",
    "title": "第一届定理证明竞赛",
    "section": "1 谓词与互归纳证明（50 分）",
    "text": "1 谓词与互归纳证明（50 分）\n\n1.1 题目\n给定谓词 P、Q、R，以及如下互归纳定义的谓词A、B。\n\nCoq: Inductive A xxx with B xxx\na_ind, b_ind\n\n（50 分）试证明定理 neg_a，提示：根据 A 或 B 的互归纳原理。\n\n\n1.2 定理\nFrom Coq Require Import List Lia.\nImport ListNotations.\nSection ProblemA. \n          \nParameter P: nat -&gt; Prop.\nParameter Q: nat -&gt; Prop.\nParameter R: nat -&gt; nat -&gt; Prop. \n\nInductive A : nat -&gt; Prop :=\n  ca0: forall n, P n -&gt; A n\n| ca1: forall n1, (forall n2, R n1 n2 -&gt; B n2) -&gt; A n1\nwith B: nat -&gt; Prop :=\n  cb0: forall n, Q n -&gt; B n\n| cb1: forall n1 n2, R n1 n2 -&gt; A n2 -&gt; B n1. \n\nScheme a_ind := Induction for A Sort Prop \n  with b_ind := Induction for B Sort Prop.\n\nTheorem neg_a:\n  (forall n, ~P n /\\ ~Q n) -&gt;\n  (forall n1, exists n2, R n1 n2) -&gt; \n  (forall n, A n -&gt; False).\nProof.\nintros HnPQ HR.\napply a_ind with (fun (n : nat) (_ : B n) =&gt; False).\n- intros. specialize (HnPQ n). destruct HnPQ.\n  apply H; assumption.\n- intros. specialize (HR n1). destruct HR as [n2 HR].\n  specialize (H n2 HR). assumption.\n- intros. specialize (HnPQ n). destruct HnPQ.\n  apply H0; assumption.\n- intros. assumption.\nQed.\n\nEnd ProblemA."
  },
  {
    "objectID": "Blogs/TPC-1.html#列表前缀和列表连续段证明100-分",
    "href": "Blogs/TPC-1.html#列表前缀和列表连续段证明100-分",
    "title": "第一届定理证明竞赛",
    "section": "2 列表前缀和列表连续段证明（100 分）",
    "text": "2 列表前缀和列表连续段证明（100 分）\n\n2.1 题目\nprefixes 函数计算了一个列表的所有前缀。例如：\nprefixes [1; 2] = [ []      ;\n                    [1]     ;\n                    [1; 2]  ]\nprefixes [0; 1; 2] =  [] ::\n                      map (cons 0 (prefixes [1; 2]))\n                   = [] ::\n                     [ 0 :: []      ;\n                       0 :: [1]     ;\n                       0 :: [1; 2]  ]\n                   = [ []           ;\n                       [0]          ;\n                       [0; 1]       ;\n                       [0; 1; 2]    ]\n接下去，请证明，prefixes l 中的确实是 l 的全部前缀。\n\n（20 分）in_prefixes\n（20 分）in_prefixes_inv\n\nsublists 定义了列表中的所有连续段。请证明 sublists l 的元素确实是 l 中的所有连续段。提示：必要时可以添加并证明一些前置引理帮助完成证明。\n\n（30 分）in_sublists\n（30 分）in_sublists_inv\n\n\n\n2.2 定理\nFrom Coq Require Import ZArith List.\nImport ListNotations.\nLocal Open Scope Z.\nLocal Open Scope list.\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 下面定义的_[prefixes]_函数计算了一个列表的所有前缀。*)\n\nFixpoint prefixes {A: Type} (l: list A): list (list A) :=\n  match l with\n  | nil =&gt; [nil]\n  | a :: l0 =&gt; nil :: (map (cons a) (prefixes l0))\n  end.\n\n(** 例如：\n   \n        prefixes [1; 2]    = [ []     ;\n                               [1]    ;\n                               [1; 2] ] \n   \n        prefixes [0; 1; 2] = [] ::\n                             map (cons 0 (prefixes [1; 2]))\n                           = [] ::\n                             [ 0 :: []     ;\n                               0 :: [1]    ;\n                               0 :: [1; 2] ]\n                           = [ []        ;\n                               [0]       ;\n                               [0; 1]    ;\n                               [0; 1; 2] ]\n      \n    接下去，请分三步证明，_[prefixes l]_中的确实是_[l]_的全部前缀。*)\n\nTheorem in_prefixes:\n  forall A (l1 l2: list A),\n    In l1 (prefixes (l1 ++ l2)).\n(* 请在此处填入你的证明，以_[Qed]_结束。 *)\nProof.\nintros A l1.\ninduction l1; intros.\n- rewrite app_nil_l. destruct l2.\n  + unfold prefixes. simpl. left. reflexivity.\n  + unfold prefixes. simpl. left. reflexivity.\n- rewrite &lt;- app_comm_cons.\n  unfold prefixes. simpl.\n  right. fold (prefixes (l1 ++ l2)).\n  apply in_map.\n  apply IHl1.\nQed.\n\nTheorem in_prefixes_inv:\n  forall A (l1 l: list A),\n    In l1 (prefixes l) -&gt;\n    exists l2, l1 ++ l2 = l.\n(* 请在此处填入你的证明，以_[Qed]_结束。 *)\nProof.\nintros A l1.\ninduction l1; intros.\n- exists l. simpl. reflexivity.\n- destruct l.\n  + unfold prefixes in H. simpl in H. destruct H.\n    * discriminate H.\n    * inversion H.\n  + unfold prefixes in H. simpl in H. destruct H.\n    * discriminate H.\n    * fold (prefixes l) in H.\n      rewrite in_map_iff in H.\n      destruct H. destruct H.\n      inversion H; subst.\n      specialize (IHl1 l H0).\n      destruct IHl1.\n      exists x.\n      rewrite &lt;- app_comm_cons.\n      rewrite &lt;- H1.\n      reflexivity.\nQed.\n\n(************)\n(** 习题：  *)\n(************)\n\n(** 下面的_[sublists]_定义了列表中的所有连续段。*)\n\nFixpoint sublists {A: Type} (l: list A): list (list A) :=\n  match l with\n  | nil =&gt; [nil]\n  | a :: l0 =&gt; map (cons a) (prefixes l0) ++ sublists l0\n  end.\n\n(** 请证明_[sublists l]_的元素确实是_[l]_中的所有连续段。提示：必要时可以添加并证明一\n    些前置引理帮助完成证明。*)\n\nLemma nil_in_sublists: \n  forall A (l : list A),\n    In [] (sublists l).\nProof.\ninduction l.\n- simpl. left. reflexivity.\n- unfold sublists. fold (sublists l).\n  rewrite in_app_iff. right. assumption.\nQed.\n\nLemma app_left_in_sublists:\n  forall A (l1 l2 : list A),\n    In l1 (sublists (l1 ++ l2)).\nProof.\nintros A l1.\ninduction l1; intros.\n- simpl. apply nil_in_sublists.\n- simpl. rewrite in_app_iff. left.\n  rewrite in_map_iff.\n  exists l1.\n  split; try reflexivity; try (apply in_prefixes).\nQed.\n\n\nTheorem in_sublists:\n  forall A (l1 l2 l3: list A),\n    In l2 (sublists (l1 ++ l2 ++ l3)).\n(* 请在此处填入你的证明，以_[Qed]_结束。 *)\nProof.\nintros A l1.\ninduction l1; intros.\n- rewrite app_nil_l.\n  apply app_left_in_sublists.\n- unfold sublists.\n  simpl.\n  fold (sublists (l1 ++ l2 ++ l3)).\n  rewrite in_app_iff. right.\n  apply IHl1.\nQed.\n\nTheorem in_sublists_inv:\n  forall A (l2 l: list A),\n    In l2 (sublists l) -&gt;\n    exists l1 l3, l1 ++ l2 ++ l3 = l.\nProof.\nintros A l2.\ninduction l2.\n- intros. simpl. exists []. exists l. simpl. reflexivity.\n- induction l.\n  + intros. unfold sublists in H. simpl in H.\n    destruct H; inversion H.\n  + unfold sublists. simpl. fold (sublists l).\n    intros. rewrite in_app_iff in H.\n    destruct H.\n    * rewrite in_map_iff in H. destruct H.\n      destruct H. inversion H; subst.\n      exists [].\n      simpl.\n      pose proof (in_prefixes_inv A l2 l H0).\n      destruct H1.\n      exists x.\n      rewrite H1.\n      reflexivity.\n    * specialize (IHl H). destruct IHl.\n      destruct H0. exists (a0 :: x).\n      exists x0.\n      simpl.\n      rewrite &lt;- H0.\n      simpl.\n      reflexivity.\nQed."
  },
  {
    "objectID": "Blogs/TPC-1.html#二叉树镜像证明100-分",
    "href": "Blogs/TPC-1.html#二叉树镜像证明100-分",
    "title": "第一届定理证明竞赛",
    "section": "3 二叉树镜像证明（100 分）",
    "text": "3 二叉树镜像证明（100 分）\n\n3.1 题目\n基于以下定义：\n\n二叉树 tree\n二叉树的镜像 mirror\n一个二叉树是对称的（symmetric）如果它等于自身的镜像 symmetric\n\n如果直接使用对称性的定义来检查一个二叉树是否对称，需要首先计算二叉树的镜像，然后做相等性比较，效率不高。我们可以通过以下方式定义更高效的对称性检查。其中，check_mirror 检查两个二叉树是否互为镜像，check_symmetric 则检查两个子树是否互为镜像。 证明 check_mirror 和 check_symmetric 的正确性：\n-（50 分）定理 check_mirror_correct -（50 分）定理 check_symmetric_correct\n\n\n3.2 定理\nFrom Coq Require Import List Lia.\nImport ListNotations.\n\nInductive tree (A : Type) : Type :=\n| Leaf : tree A\n| Node : A -&gt; tree A -&gt; tree A -&gt; tree A.\n\nArguments Leaf {A}.\nArguments Node {A} _ _ _.\n\nFixpoint mirror {A : Type} (t : tree A) : tree A :=\n  match t with\n  | Leaf =&gt; Leaf\n  | Node x l r =&gt; Node x (mirror r) (mirror l)\n  end.\n\nDefinition is_symmetric {A : Type} (t : tree A) : Prop :=\n  t = mirror t.\n\nFixpoint check_mirror {A : Type} (t1 t2 : tree A) : Prop :=\n  match t1, t2 with\n  | Leaf, Leaf =&gt; True\n  | Node x1 l1 r1, Node x2 l2 r2 =&gt;\n    (x1 = x2) /\\ (check_mirror l1 r2) /\\ (check_mirror r1 l2)\n  | _, _ =&gt; False\n  end.\n\nDefinition check_symmetric {A : Type} (t : tree A) : Prop :=\n  match t with\n  | Leaf =&gt; True\n  | Node x l r =&gt; check_mirror l r\n  end.\n\nLemma check_mirror_correct : forall {A : Type} (t1 t2 : tree A),\n  check_mirror t1 t2 &lt;-&gt; t1 = mirror t2.\nProof.\nsplit.\n- revert t2. induction t1; intros.\n  + destruct t2.\n    * simpl. reflexivity.\n    * unfold check_mirror in H. inversion H.\n  + destruct t2.\n    * inversion H.\n    * inversion H; subst.\n      destruct H1.\n      unfold mirror.\n      fold (mirror t2_2).\n      fold (mirror t2_1).\n      specialize (IHt1_1 t2_2 H0).\n      specialize (IHt1_2 t2_1 H1).\n      rewrite &lt;- IHt1_1.\n      rewrite IHt1_2.\n      reflexivity.\n- revert t2. induction t1; intros.\n  + destruct t2.\n    * simpl. simpl in H. lia.\n    * inversion H.\n  + destruct t2.\n    * inversion H.\n    * unfold mirror in H.\n      fold (mirror t2_2) in H.\n      fold (mirror t2_1) in H.\n      inversion H; subst.\n      unfold check_mirror.\n      split; try reflexivity.\n      fold (check_mirror (mirror t2_2) t2_2).\n      fold (check_mirror (mirror t2_1) t2_1).\n      split.\n      -- apply IHt1_1. reflexivity.\n      -- apply IHt1_2. reflexivity.\nQed.\n\nLemma mirror_mirror: forall {A : Type} (t: tree A),\n  mirror (mirror t) = t.\nProof.\ninduction t; intros.\n- simpl. reflexivity.\n- unfold mirror.\n  fold (mirror t1).\n  fold (mirror t2).\n  fold (mirror (mirror t1)).\n  fold (mirror (mirror t2)).\n  rewrite IHt1. rewrite IHt2.\n  reflexivity.\nQed.\n\nTheorem check_symmetric_correct: forall {A : Type} (t: tree A),\n  check_symmetric t &lt;-&gt; is_symmetric t.\nProof.\nsplit.\n- induction t. \n  + intros. unfold is_symmetric. unfold mirror. reflexivity.\n  + intros.\n    unfold check_symmetric in H.\n    unfold is_symmetric.\n    rewrite check_mirror_correct in H.\n    subst t1.\n    remember (mirror t2) as m2.\n    unfold mirror.\n    fold (mirror t2).\n    fold (mirror m2).\n    subst m2.\n    rewrite mirror_mirror.\n    reflexivity.\n- induction t; intros.\n  + unfold check_symmetric. constructor.\n  + unfold is_symmetric in H.\n    unfold check_symmetric.\n    unfold mirror in H.\n    fold (mirror t1) in H.\n    fold (mirror t2) in H.\n    inversion H; subst.\n    repeat (rewrite mirror_mirror).\n    apply check_mirror_correct.\n    reflexivity.\nQed."
  },
  {
    "objectID": "Blogs/TPC-1.html#二分搜索极小点证明200-分",
    "href": "Blogs/TPC-1.html#二分搜索极小点证明200-分",
    "title": "第一届定理证明竞赛",
    "section": "4 二分搜索极小点证明（200 分）",
    "text": "4 二分搜索极小点证明（200 分）\n\n4.1 题目\n我们考虑一个自然数的数组，满足数组中任何两个相邻的元素不相等 neighbor_nonequal\n一个索引是数组中的极小点，如果这个索引上的值小于两边的值（如果这个索引在边界上，则对应边的条件自动满足）。is_local_min 定义索引 \\(i\\) 是数组 xs 的极小点\n可以证明总是存在一个极小点。实际上，二分搜索方法 local_min 可以保证返回一个极小点\n这个算法的正确性证明遵循以下步骤。\n首先，将 is_local_min 的定义扩展到区间的情况 is_local_min_part\n其次，函数 local_min 的归纳性质如下：假设 a 和 b 分别小于左侧/右侧的值，则 local_min xs a b 返回一个满足 is_local_min_part 条件的索引。该证明首先根据 local_min 的定义做归纳，对 local_min 的几种情况分类讨论，试给出定理 local_min_correct_induct 中相应分类讨论的证明步骤（四类情况的分数设置依次为20 分 +20 分 +60 分 +60 分）。\n最后，使用 local_min_correct_induct 验证正确性结论 local_min_correct （40 分）\n\n\n4.2 定理\nFrom Coq Require Import Arith List Lia.\n\nDefinition neighbor_nonequal (xs : list nat) : Prop :=\n  forall i, i &lt; length xs - 1 -&gt; nth i xs 0 &lt;&gt; nth (i + 1) xs 0.\n\nDefinition is_local_min (xs : list nat) (i : nat) : Prop :=\n  i &lt; length xs /\\\n  (i = 0 \\/ nth i xs 0 &lt; nth (i - 1) xs 0) /\\\n  (i = length xs - 1 \\/ nth i xs 0 &lt; nth (i + 1) xs 0).\n\nLemma ge_exists:\n forall  right left (g : right &gt; left)\n  (n : left + 1 &lt;&gt; right),\n  exists n0 : nat, right = n0 + left /\\ n0 &gt; 1.\nProof.\n  induction right; simpl; intros.\n  - inversion g.\n  - destruct left.\n    + exists (S right).\n      lia.\n    + specialize (IHright left).\n      apply Arith_base.gt_S_n_stt in g.\n      rewrite plus_Sn_m in n.\n      rewrite Nat.succ_inj_wd_neg in n.\n      specialize (IHright g n).\n      destruct IHright as (k & Hk1 & Hk2).\n      exists k.\n      lia.\nQed.\n\nLemma div2_plus_2n: forall n k, Nat.div2 (k + (n + n)) = Nat.div2 k + n.\nProof.\n  induction n; simpl; intros.\n  - rewrite ! Nat.add_0_r.\n    lia.\n  - specialize (IHn (S (S k))).\n    replace (S (S k) + (n + n)) with (k + S (n + S n))  in IHn by lia.\n    rewrite IHn.\n    simpl.\n    lia.\nQed.\n\nLemma div2_le: forall n k,\n  n &lt;= k -&gt; Nat.div2 n &lt;= Nat.div2 k.\nProof.\n  intros.\n  pose proof (Nat.Div0.div_le_mono n k 2) as Heq.\n  rewrite ! Nat.div2_div.\n  apply Heq.\n  lia.\nQed.\n\nInductive local_min : forall (xs : list nat) (l r i: nat), Prop :=\n  | case_le_right_left : forall xs l r,\n      r &lt;= l -&gt; \n      local_min xs l r l\n  | case_left_plus_1_eq_right_l: forall xs l r,\n      l &lt; r -&gt; \n      r = l+1 -&gt;\n      nth l xs 0 &lt; nth r xs 0 -&gt;\n      local_min xs l r l\n  | case_left_plus_1_eq_right_r: forall xs l r,\n      l &lt; r -&gt; \n      r = l+1 -&gt;\n      nth r xs 0 &lt;= nth l xs 0 -&gt;\n      local_min xs l r r\n  | case_mid_1: forall xs l r mid i,\n      l &lt; r -&gt; \n      l+1 &lt;&gt; r -&gt;\n      mid = Nat.div2 (l + r) -&gt;\n      nth (mid - 1) xs 0 &lt; nth mid xs 0 -&gt;\n      local_min xs l (mid - 1) i -&gt;\n      local_min xs l r i\n  | case_mid_r: forall xs l r mid i,\n      l &lt; r -&gt; \n      l+1 &lt;&gt; r -&gt;\n      mid = Nat.div2 (l + r) -&gt;\n      nth mid xs 0 &lt;= nth (mid - 1) xs 0 -&gt;\n      local_min xs mid r i -&gt;\n      local_min xs l r i\n.\n\nDefinition is_local_min_part (ls : list nat) (l r i: nat) : Prop :=\n  i &gt;= l /\\ i &lt;= r /\\\n  (i = 0 \\/ (i &lt; length ls /\\ (i-1) &lt; length ls /\\ nth i ls 0 &lt; nth (i-1) ls 0)) /\\\n  (i = length ls - 1 \\/ (i &lt; length ls /\\ (i+1) &lt; length ls /\\ nth i ls 0 &lt; nth (i+1) ls 0)).\n\nPrint nth.\n\nLemma local_min_correct_induct :\n  forall xs a b i,\n    neighbor_nonequal xs -&gt;\n    0 &lt;= a -&gt; a &lt;= b -&gt; b &lt; length xs -&gt;\n    (a = 0 \\/ (a &lt; length xs /\\ (a-1) &lt; length xs /\\ nth a xs 0 &lt; nth (a-1) xs 0)) -&gt;\n    (b = length xs - 1 \\/ (b &lt; length xs /\\ (b+1) &lt; length xs /\\ nth b xs 0 &lt; nth (b+1) xs 0)) -&gt;\n    local_min xs a b i -&gt;\n    is_local_min_part xs a b i.\nProof.\n  intros xs l r i H_neighbor H_a_lower H_ab H_b_upper H_a_cond H_b_cond Hi.\n  unfold is_local_min_part.\n  induction Hi; try lia.\n  - assert (Heq: l = r) by lia.\n    subst l.\n    lia.\n\n  - subst r. lia.\n\n  - subst r. assert (l + 1 - 1 = l) by lia.\n    replace (l + 1 - 1).\n    unfold neighbor_nonequal in H_neighbor.\n    specialize (H_neighbor l).\n    lia.\n  \n  - assert (l &lt;= r - 2) by lia.\n  \n  assert (H_l_mid: l &lt;= mid - 1). { \n    rewrite H1.\n     pose proof (Nat.div2_le_mono (2 * (l + 1)) (l + r)).\n     rewrite Nat.div2_double in H4.\n     assert (r &gt;= 2) by lia.\n     lia.\n    } \n  assert (H_mid_r: mid - 1 &lt;= r). { \n    rewrite H1.\n    pose proof (Nat.div2_le_mono (l + r) (2 * (r + 1))).\n    rewrite Nat.div2_double in H4.\n    lia.\n   }\n  assert (H_mid_length: mid - 1 &lt; length xs). { lia. } \n  assert (H_mid_cond: mid - 1 = length xs - 1 \\/ mid - 1 &lt; length xs /\\ mid - 1 + 1 &lt; length xs /\\ nth (mid - 1) xs 0 &lt; nth (mid - 1 + 1) xs 0). {\n    assert (mid &gt;= l+1). { pose proof (Nat.div2_le_mono (2 * (l + 1)) (l + r)). rewrite Nat.div2_double in H4. assert (l + 1 &lt;= r) by lia. lia. }\n    remember (mid - 1) as m.\n    Search (_ &lt; _ -&gt; _ \\/ _).\n    assert (m + 0 &lt; length xs - 1 + 1) by lia.\n    assert (m + 1 = mid) by lia.\n    rewrite H6.\n    lia.\n   }\n  specialize (IHHi H_neighbor H_a_lower H_l_mid H_mid_length H_a_cond H_mid_cond).\n  destruct IHHi.\n  destruct H5.\n  assert (i &lt;= r) by lia.\n  lia.\n  \n\n  - assert (H_l_mid: l+1 &lt;= mid ). {\n    pose proof (Nat.div2_le_mono (2 * (l + 1)) (l + r)). rewrite Nat.div2_double in H3. assert (l + 1 &lt;= r) by lia. lia.\n  }\n    assert (H_mid_r: mid &lt;= r-1). {\n      pose proof (Nat.div2_le_mono (l+r) (2*(r-1))). rewrite Nat.div2_double in H3. assert (l &lt;= r-1) by lia. lia.\n    }\n    assert (H_0_mid: 0 &lt;= mid) by lia.\n    assert (H_mid_r_r: mid &lt;= r) by lia.\n    assert (H_mid_cond: mid = 0 \\/\n      mid &lt; length xs /\\\n      mid - 1 &lt; length xs /\\\n      nth mid xs 0 &lt; nth (mid - 1) xs 0). {\n        assert (mid &gt; 0) by lia.\n        right.\n        split. lia. split. lia.\n        assert (mid - 1 + 1 = mid) by lia.\n        unfold neighbor_nonequal in H_neighbor.\n        assert (nth (mid - 1) xs 0 &lt;&gt; nth mid xs 0). {\n          remember (mid - 1) as m.\n          rewrite &lt;- H4.\n          apply H_neighbor.\n          lia.\n        }\n        lia.\n      }\n    specialize (IHHi H_neighbor H_0_mid H_mid_r_r H_b_upper H_mid_cond H_b_cond).\n    destruct IHHi.\n    destruct H4.\n    assert (i &gt;= l) by lia.\n    lia.\nQed.\n\nTheorem local_min_correct:\n  forall xs i,\n    neighbor_nonequal xs -&gt;\n    length xs &gt; 0 -&gt;\n    local_min xs 0 (length xs - 1) i -&gt;\n    is_local_min xs i.\nProof.\n  intros.\nassert (H_a_lower: 0 &lt;= 0) by lia.\nassert (H_a_b: 0 &lt;= length xs - 1) by lia.\nassert (H_b_upper: length xs - 1 &lt; length xs) by lia.\nassert (H_a_cond: 0 = 0 \\/ 0 &lt; length xs /\\ 0 - 1 &lt; length xs /\\ nth 0 xs 0 &lt; nth (0 - 1) xs 0) by lia.\nassert (H_b_cond: length xs - 1 = length xs - 1 \\/ length xs - 1 &lt; length xs /\\ length xs - 1 + 1 &lt; length xs /\\ nth (length xs - 1) xs 0 &lt; nth (length xs - 1 + 1) xs 0) by lia.\npose proof (local_min_correct_induct xs 0 (length xs - 1) i H H_a_lower H_a_b H_b_upper H_a_cond H_b_cond H1).\nunfold is_local_min_part in H2.\nunfold is_local_min.\nlia.\nQed."
  },
  {
    "objectID": "Blogs/Mogan_stem.html",
    "href": "Blogs/Mogan_stem.html",
    "title": "如何在 Mogan STEM 中修改字体",
    "section": "",
    "text": "使用宏命令来完成字体修改.\n\n打开导言区. 可以如下图所示, 也可以直接按 Ctrl + Shift + P.\n\n\n\n\n打开导言区\n\n\n\n先点击 Assign, 出现下面的 &lt;assign||&gt;.\n\n\n\n\n点击 Assign\n\n\n\n最后输入成下面这样:\n\n\n\n\n输入内容\n\n\n总体流程如下, 请注意: Macro 增加参数一定是 Alt+-&gt;.\n\n\n\n总体流程"
  },
  {
    "objectID": "Blogs/FSE20.html",
    "href": "Blogs/FSE20.html",
    "title": "Detecting numerical bugs in neural network architectures",
    "section": "",
    "text": "This paper makes the first attempt to conduct static analysis for detecting numerical bugs at the architecture level."
  },
  {
    "objectID": "Blogs/FSE20.html#introduction",
    "href": "Blogs/FSE20.html#introduction",
    "title": "Detecting numerical bugs in neural network architectures",
    "section": "Introduction",
    "text": "Introduction\nA neural architecture can contain numerical bugs that cause serious consequences. Numerical bugs in a neural architecture manifest themselves as numerical errors in the form of “NaN”, “INF”, or crashes during training or inference.\n# Input:\n# center: 2*100 - shape tensor whose elements in [-1, 1]\n# offset : 2*100 - shape tensor whose elements in [0, 2]\n\n# Create 100 rectangles .\nbottomLeft = center - offset\ntopRight = center + offset\nrectangle = tf.concat([bottomLeft, topRight], axis=1)\n\n# Calculate the reciprocal of their areas.\nbottom, left, top, right = tf.split(rectangle, num_or_size_splits=4, axis=1)\nwidth = right - left\nheight = top - bottom\narea = width * height\nscale = tf.reciprocal(area)\nThe key insight is that affine relations are common in neural network architectures.\n\nBasics of Abstract Interpretation\nConcrete properties are described in the concrete domain \\(\\mathbb{C}\\) with a partial order \\(\\subseteq\\), and abstract properties are described in the abstract domain \\(\\mathbb{A}\\) with a partial order \\(\\sqsubseteq\\).\n\nAbstraction function \\(\\alpha: \\mathbb{C} \\rightarrow \\mathbb{A}\\)\nConcretization function \\(\\gamma: \\mathbb{A} \\rightarrow \\mathbb{C}\\)\n\nGalois connection \\(\\langle\\mathbb{C},\\subseteq\\rangle \\overset{\\gamma}{\\underset{\\alpha}{\\leftrightarrows}} \\langle\\mathbb{A},\\sqsubseteq\\rangle\\): \\[\n\\forall c \\in \\mathbb{C}, a \\in \\mathbb{A}. \\alpha(c) \\sqsubseteq a \\Leftrightarrow c \\subseteq \\gamma(a)\n\\]\n\n\nAbstract Domain of Intervals\n\\[\n\\mathbb{A}_I \\triangleq \\{([l_1,u_1],...,[l_n,u_n] | l,u \\in \\mathbb{R}^n)\\}\n\\] Here \\(x \\in \\mathbb{A}_I \\Rightarrow l_i \\leq x_i \\leq u_i\\).\nAlso, we say \\(a_1 \\sqsubseteq a_2\\) iff \\(\\forall i. [l_i^1,u_i^1] \\subseteq [l_i^2,u_i^2]\\).\nAnd the abstraction functions are defined as: \\[\n\\alpha_I(c) = ([\\inf\\{x_i | x \\in c\\}, \\sup\\{x_i | x \\in c\\}])_{i=1}^n\n\\] That is, the abstraction function maps a concrete set to the smallest interval containing it.\nThe concretization function is defined as: \\[\n\\gamma_I(a) = \\{x \\in \\mathbb{R}^n | \\forall i. l_i^a \\leq x_i \\leq u_i^a\\}\n\\]\n\n\nAbstract Domain of Affine Relations\n\\[\n\\mathbb{A}_E \\triangleq \\{(\\mathbf{A},b)|\\mathbb{A} \\in \\mathbb{R}^{m \\times n}, b \\in \\mathbb{R}^m, m&gt;0\\}\n\\]\nHere \\(x \\in \\mathbb{A}_E \\Rightarrow \\mathbf{A}x = b\\).\nAnd the abstraction functions are defined as:\n\\[\n\\alpha_E(c) = \\begin{cases}\n(\\mathbf{A},b) & \\text{if } c \\subseteq \\{x | \\mathbf{A}x = b\\} \\text{ and } (\\mathbf{A},b) \\text{ is in reduced echelon form}\\\\\n\\top & \\text{if } c = \\mathbb{R}^n\\\\\n\\bot & \\text{otherwise}\n\\end{cases}\n\\]\nThe concretization function is defined as:\n\\[\n\\gamma_E(a) = \\{x \\in \\mathbb{R}^n | \\mathbf{A}x = b\\},\n\\] here \\(a = (\\mathbf{A},b)\\).\n\n\nAbstract Domain for Neural Architectures\nThe abstract domain for Tensor partitioning and Interval abstraction with affine Equality relation \\(\\mathbb{A}_{\\text{TIE}}\\) is defined as: \\[\n\\mathbb{A}_{\\text{TIE}} \\triangleq \\{(\\mathcal{P}, a^{\\sharp I}, a^{\\sharp E})|a^{\\sharp I} \\in \\mathbb{A}_I, a^{\\sharp E}\\in\\mathbb{A}_E\\},\n\\] where \\(\\mathcal{P} = \\{A_1,A_2,...,A_n\\}\\) is a tensor partitioning.\nThe concretization function \\(\\gamma_{\\text{TIE}}\\) of an element \\(a^\\sharp = (\\mathcal{P}, a^{\\sharp I}, a^{\\sharp E})\\) is defined as: \\[\n\\gamma_{\\text{TIE}}(a^\\sharp) = \\gamma_I(a^{\\sharp I}) \\cap \\gamma_E(a^{\\sharp E})\n\\]\nNotes for ReLU:\n\nCreate a new symbolic variable \\(b\\) for \\(a\\).\nAnd we have \\(b - a^{\\text{ReLU}} = 0\\).\n\\(a^{\\text{ReLU}} - a^{-\\text{ReLU}} - a =0\\)."
  },
  {
    "objectID": "Blogs/Dafny_two_quantifiers.html",
    "href": "Blogs/Dafny_two_quantifiers.html",
    "title": "Two quantifiers in a specification",
    "section": "",
    "text": "Let’s consider a Dafny lemma that involves two quantifiers in its specification. For example, we want to prove the following lemma:\nIn both test1 and test2, Dafny fails to prove the lemmas because it cannot find appropriate triggers for the quantifiers."
  },
  {
    "objectID": "Blogs/Dafny_two_quantifiers.html#and-what-is-a-trigger",
    "href": "Blogs/Dafny_two_quantifiers.html#and-what-is-a-trigger",
    "title": "Two quantifiers in a specification",
    "section": "And what is a trigger?",
    "text": "And what is a trigger?\nSee Dafny Reference Manual on {:trigger}.\n\nTrigger attributes are used on quantifiers and comprehensions.\nThe verifier instantiates the body of a quantified expression only when it can find an expression that matches the provided trigger.\n\npredicate P(i: int)\npredicate Q(i: int)\n\nlemma {:axiom} PHoldEvenly()\n  ensures  forall i {:trigger Q(i)} :: P(i) ==&gt; P(i + 2) && Q(i)\n\nlemma PHoldsForTwo()\n  ensures forall i :: P(i) ==&gt; P(i + 4)\n{\n  forall j: int\n    ensures P(j) ==&gt; P(j + 4)\n  {\n    if P(j) {\n      assert P(j); // Trivial assertion\n      \n      PHoldEvenly();\n      // Invoking the lemma assumes `forall i :: P(i) ==&gt; P(i + 4)`,\n      // but it's not instantiated yet\n      \n      // The verifier sees `Q(j)`, so it instantiates\n      // `forall i :: P(i) ==&gt; P(i + 4)` with `j`\n      // and we get the axiom `P(j) ==&gt; P(j + 2) && Q(j)`\n      assert Q(j);     // hence it can prove `Q(j)`\n      assert P(j + 2); //   and it can prove `P(j + 2)`\n      assert P(j + 4); // But it cannot prove this\n      // because it did not instantiate `forall i :: P(i) ==&gt; P(i + 4)` with `j+2`\n    }\n  }\n}\nHere are ways one can prove assert P(j + 4);:\n\nAdd assert Q(j + 2); just before assert P(j + 4);, so that the verifier sees the trigger.\nChange the trigger {:trigger Q(i)} to {:trigger P(i)} (replace the trigger).\nChange the trigger {:trigger Q(i)} to {:trigger Q(i)} {:trigger P(i)} (add a trigger).\nRemove {:trigger Q(i)} so that it will automatically determine all possible triggers thanks to the option /autoTriggers:1 which is the default."
  },
  {
    "objectID": "Blogs/Dafny_two_quantifiers.html#nested-loops",
    "href": "Blogs/Dafny_two_quantifiers.html#nested-loops",
    "title": "Two quantifiers in a specification",
    "section": "Nested loops",
    "text": "Nested loops\nSee Dafny Reference Manual on Nested loops.\nIn the case of nested loops, the verifier might timeout sometimes because of inadequate or too much available information. One way to mitigate this problem, when it happens, is to isolate the inner loop by refactoring it into a separate method, with suitable pre and postconditions that will usually assume and prove the invariant again. For example,\nwhile X\n  invariant Y\n{\n    while X'\n      invariant Y'\n    {\n\n    }\n}\ncould be refactored as this:\nwhile X\n   invariant Y\n {\n   innerLoop();\n }\n...\nmethod innerLoop()\n  require Y'\n  ensures Y'"
  },
  {
    "objectID": "Blogs/Dafny_two_quantifiers.html#my-findings",
    "href": "Blogs/Dafny_two_quantifiers.html#my-findings",
    "title": "Two quantifiers in a specification",
    "section": "My findings",
    "text": "My findings\nI think the main issue can be the Skolemization of the quantifiers.\nSkolemization: \\(\\forall x \\exists y R(x,y) \\Leftrightarrow \\forall x R(x,f(x))\\), here \\(f\\) is a Skolem function.\nIn test1, after Skolemization:\n\nthe requirement becomes: \\(\\forall x P(a, x, f(x))\\).\nthe ensures becomes: \\(\\forall x P(a, x, g(x))\\).\nDafny cannot find the relation between f and g, so it cannot prove the lemma.\n\nIn test2, after Skolemization:\n\nthe requirement becomes: \\(P(a, h, y)\\).\nthe ensures becomes: \\(P(a, k, y)\\).\nSimilarly, Dafny cannot find the relation between h and k, so it cannot prove the lemma.\n\nAnd based on this understanding, I tried to prove two quantifers of \\(\\forall x \\forall y\\) and \\(\\exists x \\exists y\\), and Dafny can prove them successfully.\nlemma test1(a: seq&lt;int&gt;)\n    requires forall x :: (forall y :: P(a, x, y))\n    ensures forall x :: (forall y :: P(a, x, y))\n{\n    // proved\n}\n\nlemma test2(a: seq&lt;int&gt;)\n    requires exists x :: (exists y :: P(a, x, y))\n    ensures exists x :: (exists y :: P(a, x, y))\n{\n    // proved\n}"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hello, this is VectorPikachu, or Hangzhou Lyu (吕杭州, lǚ háng zhōu). Currently I’m a student majored in Software Engineering. And my research interest lies on Program Verification, including Dafny, Coq, Verus, et.al."
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "About",
    "section": "Education",
    "text": "Education\n\nPeking University | Beijing, China  B.Eng. in Software Engineering | Sept 2022 - June 2026  北京大学 | 中国北京  软件工程 | 2022 年 9 月 - 2026 年 6 月\nPeking University | Beijing, China  B.S. in Economics (Dual Degree Program in National School of Development, NSD) | Sept 2023 - June 2026  北京大学 | 中国北京  经济学 (国发院双学位) | 2023 年 9 月 - 2026 年 6 月"
  },
  {
    "objectID": "about.html#certificates",
    "href": "about.html#certificates",
    "title": "About",
    "section": "Certificates",
    "text": "Certificates\n\nCollege English Test Band4, CET4 | 671  大学英语四级考试 | 671\nCollege English Test Band6, CET6 | 650  大学英语六级考试 | 650"
  },
  {
    "objectID": "about.html#awards",
    "href": "about.html#awards",
    "title": "About",
    "section": "Awards",
    "text": "Awards\n\n2025 CCF ChinaSoft Theorem Proving Contest | Third Prize  2025中国软件大会定理证明竞赛 | 三等奖"
  },
  {
    "objectID": "Blogs/DataflowAnalysis.html",
    "href": "Blogs/DataflowAnalysis.html",
    "title": "Dataflow Analysis",
    "section": "",
    "text": "Dataflow analysis is a static analysis technique used to gather information about the possible set of values computed at various points in a program, aiding in optimization and error detection."
  },
  {
    "objectID": "Blogs/DataflowAnalysis.html#mathematical-foundations",
    "href": "Blogs/DataflowAnalysis.html#mathematical-foundations",
    "title": "Dataflow Analysis",
    "section": "Mathematical Foundations",
    "text": "Mathematical Foundations\nSemilattice (半格). Semilattice is a structure \\((S, \\sqcup)\\), where \\(S\\) is a set and \\(\\sqcup: S \\times S \\to S\\) is a binary operation on \\(S\\) that is:\n\nidempotent (幂等): \\(x \\sqcup x = x\\);\ncommutative (交换): \\(x \\sqcup y = y \\sqcup x\\);\nassociative (结合): \\(x \\sqcup (y \\sqcup z) = (x \\sqcup y) \\sqcup z\\).\n\nBounded Semilattice (有界半格). A bounded semilattice is a semilattice that has a least element (bottom) \\(\\bot\\) such that for all \\(x \\in S\\), \\(x \\sqcup \\bot = x\\).\nPartial Order (偏序). A partial order is a binary relation \\(\\sqsubseteq\\) over a set \\(S\\) that is:\n\nreflexive (自反): \\(x \\sqsubseteq x\\) for all \\(x \\in S\\);\ntransitive (传递): if \\(x \\sqsubseteq y\\) and \\(y \\sqsubseteq z\\), then \\(x \\sqsubseteq z\\);\nantisymmetric (反对称): if \\(x \\sqsubseteq y\\) and \\(y \\sqsubseteq x\\), then \\(x = y\\).\n\nEvery bounded semilattice \\((S, \\sqcup, \\bot)\\) induces a partial order \\(\\sqsubseteq\\) defined by \\(x \\sqsubseteq y\\) if and only if \\(x \\sqcup y = y\\).\nMonotone (Increasing) Function. A function \\(f: S \\to S\\) is monotone with respect to a partial order \\(\\sqsubseteq\\) if for all \\(x, y \\in S\\), \\(x \\sqsubseteq y\\) implies \\(f(x) \\sqsubseteq f(y)\\).\nFixed Point. A fixed point of a function \\(f: S \\to S\\) is an element \\(x \\in S\\) such that \\(f(x) = x\\).\nFixed Point Theorem. In a bounded semilattice, whose height is finite, every monotone function has a least fixed point, which can be computed as the limit of the ascending chain starting from the least element.\nProof. Let \\((S, \\sqcup, \\bot)\\) be a bounded semilattice with finite height, and let \\(f: S \\to S\\) be a monotone function. We construct an ascending chain starting from \\(\\bot\\): \\[\n    x_0 = \\bot, \\quad x_{n+1} = f(x_n).\n\\]\n\\(\\bot \\sqsubseteq f(\\bot) \\sqsubseteq f(f(\\bot)) \\sqsubseteq \\cdots\\), that is, \\(x_0 \\sqsubseteq x_1 \\sqsubseteq x_2 \\sqsubseteq \\cdots\\). Since the height of the semilattice is finite, this chain must stabilize at some \\(x_k\\) such that \\(x_k = f(x_k)\\). Thus, \\(x_k\\) is a fixed point of \\(f\\). Moreover, it is the least fixed point because any other fixed point \\(y\\) must satisfy \\(\\bot \\sqsubseteq y\\), and by monotonicity, \\(x_n \\sqsubseteq f^n(y) = y\\) for all \\(n\\), leading to \\(x_k \\sqsubseteq y\\). And thus, \\(x_k\\) is the least fixed point of \\(f\\)."
  },
  {
    "objectID": "Blogs/DataflowAnalysis.html#dataflow-analysis-framework",
    "href": "Blogs/DataflowAnalysis.html#dataflow-analysis-framework",
    "title": "Dataflow Analysis",
    "section": "Dataflow Analysis Framework",
    "text": "Dataflow Analysis Framework\n\n\n\\begin{algorithm} \\caption{Dataflow Analysis Framework} \\begin{algorithmic} \\Require A control flow graph (CFG) $G = (V, E)$, a semilattice $(S, \\sqcup, \\bot)$, an initial value of entry node $\\text{OUT}_{\\text{entry}} \\in S$, transfer functions $f_v: S \\to S$ for each node $v \\in V - \\text{entry}$. \\Ensure Dataflow values $\\text{OUT}_v \\in S$ for each node $v \\in V$. \\Procedure{Workflow}{$G, (S, \\sqcup, \\bot), \\text{OUT}_{\\text{entry}}, \\{f_v\\}_{v \\in V - \\text{entry}}$} \\State $\\forall v \\in V - \\text{entry}, \\text{OUT}_v = \\bot$ \\State $\\text{ToVisit} = V - \\text{entry}$ \\While{$\\text{ToVisit} \\neq \\varnothing$} \\State Select and remove a node $v$ from $\\text{ToVisit}$ \\State $\\text{IN}_v = \\bigsqcup_{(u, v) \\in E} \\text{OUT}_u$ \\State $\\text{OUT}_v^{\\text{NEW}} = f_v(\\text{IN}_v)$ \\If{$\\text{OUT}_v^{\\text{NEW}} \\neq \\text{OUT}_v$} \\State $\\text{OUT}_v = \\text{OUT}_v^{\\text{NEW}}$ \\State $\\text{ToVisit} = \\text{ToVisit} \\cup \\{ w \\mid (v, w) \\in E \\}$ \\EndIf \\EndWhile \\EndProcedure \\end{algorithmic} \\end{algorithm}\n\n\n\nConvergence and Safety\nConvergence = Termination + Confluent\n\nTermination\nTermination of Algorithm 1. Suppose \\(\\text{OUT}_v^i\\) is the value of \\(\\text{OUT}_v\\) after the \\(i\\)-th update. Now let’s prove that for each node \\(v\\), the sequence \\(\\{\\text{OUT}_v^i\\}\\) is ascending:\n\nUsing the induction on the number of updates.\nBase case: before any updates, \\(\\text{OUT}_v^0 = \\bot\\). After one update, we must have \\(\\text{OUT}_v^0 \\sqsubseteq \\text{OUT}_v^1\\).\nNow assume after \\(k\\) updates, \\(\\{\\text{OUT}_v^i\\}_{i \\leq k}\\) is ascending for all \\(v\\). Let’s consider the \\((k+1)\\)-th update.\n\nNode \\(v\\) is not selected for update: \\(\\text{OUT}_v^{k+1} = \\text{OUT}_v^k\\). And we must have \\(\\text{OUT}_v^k \\sqsubseteq \\text{OUT}_v^{k+1}\\).\nNode \\(v\\) is selected for update: \\(\\text{OUT}_v^{k+1} = f_v\\left( \\bigsqcup_{(u, v) \\in E} \\text{OUT}_u^k \\right)\\).\n\nIf \\(\\text{OUT}_v^k = \\bot\\), then \\(\\text{OUT}_v^k \\sqsubseteq \\text{OUT}_v^{k+1}\\).\nIf \\(\\text{OUT}_v^k \\neq \\bot\\), then there must be a previous update \\(j &lt; k\\) such that \\(\\text{OUT}_v^k = f_v\\left( \\bigsqcup_{(u, v) \\in E} \\text{OUT}_u^j \\right)\\). By the induction hypothesis, for all \\(u\\) with \\((u, v) \\in E\\), we have \\(\\text{OUT}_u^j \\sqsubseteq \\text{OUT}_u^k\\). By monotonicity of \\(f_v\\) and \\(\\sqcup\\), we have: \\[\n  \\text{OUT}_v^k = f_v\\left( \\bigsqcup_{(u, v) \\in E} \\text{OUT}_u^j \\right) \\sqsubseteq f_v\\left( \\bigsqcup_{(u, v) \\in E} \\text{OUT}_u^k \\right) = \\text{OUT}_v^{k+1}.\n\\]\n\nThus, in both cases, we have \\(\\text{OUT}_v^k \\sqsubseteq \\text{OUT}_v^{k+1}\\).\n\nBy induction, we conclude that for each node \\(v\\), the sequence \\(\\{\\text{OUT}_v^i\\}\\) is ascending.\n\nSince \\((S, \\sqcup, \\bot)\\) has finite height, the ascending sequence \\(\\{\\text{OUT}_v^i\\}\\) must stabilize at some \\(\\text{OUT}_v^*\\). Therefore, Algorithm 1 terminates.\n\n\nConfluent\nWe define the following Round-Robin (轮询) function: \\[\nF(X) = \\left(f_v\\left( \\bigsqcup_{(u, v) \\in E} X(u) \\right) \\right)_{v \\in V},\n\\] where \\(X = (X(v))_{v \\in V} \\in S^{|V|}\\) is a vector of dataflow values for all nodes in the CFG.\n\\(F\\) is monotone because it is composed of monotone functions (the transfer functions \\(f_v\\) and the join operation \\(\\sqcup\\)). By the Fixed Point Theorem, since \\((S, \\sqcup, \\bot)\\) has finite height, \\(F\\) has a least fixed point.\nNow let’s prove \\(F\\) and Algorithm 1 compute the same fixed point → This is called Confluent. That is, no matter how we select nodes for update in Algorithm 1, we always reach the same final dataflow values.\n\nThe main difference is that Algorithm 1 updates nodes one at a time, while \\(F\\) updates all nodes simultaneously.\n\nLet \\(X_i = (\\text{OUT}_v^i)_{v \\in V}\\) be the vector of dataflow values after the \\(i\\)-th update. \\(Y_i = F^i(\\text{OUT}_{\\text{entry}}, \\bot, \\ldots, \\bot)\\). And we want to prove that for all \\(i\\), \\(X_i \\sqsubseteq Y_i\\).\n\nUsing induction on \\(i\\).\nBase case: \\(i = 0\\), \\(X_0 = (\\text{OUT}_{\\text{entry}}, \\bot, \\ldots, \\bot) = Y_0\\).\nNow assume \\(X_k \\sqsubseteq Y_k\\) for some \\(k \\geq 0\\). Let’s consider the \\((k+1)\\)-th update.\n\nSuppose node \\(v\\) is selected for update. Then: \\[\n    \\text{OUT}_v^{k+1} = f_v\\left( \\bigsqcup_{(u, v) \\in E} \\text{OUT}_u^k \\right) = f_v\\left( \\bigsqcup_{(u, v) \\in E} X_k(u) \\right).\n\\] By the induction hypothesis, for all \\(u\\) with \\((u, v) \\in E\\), we have \\(X_k(u) \\sqsubseteq Y_k(u)\\). By monotonicity of \\(f_v\\) and \\(\\sqcup\\), we have: \\[\n    \\text{OUT}_v^{k+1} = f_v\\left( \\bigsqcup_{(u, v) \\in E} X_k(u) \\right) \\sqsubseteq f_v\\left( \\bigsqcup_{(u, v) \\in E} Y_k(u) \\right) = Y_{k+1}(v).\n\\]\nFor nodes not selected for update, \\(\\text{OUT}_w^{k+1} = \\text{OUT}_w^k \\sqsubseteq Y_k(w) \\sqsubseteq Y_{k+1}(w)\\).\nThus, in both cases, we have \\(X_{k+1} \\sqsubseteq Y_{k+1}\\).\n\nBy induction, we conclude that for all \\(i\\), \\(X_i \\sqsubseteq Y_i\\).\n\nSuppose Algorithm 1 terminates at iteration \\(N\\), then \\(X_N\\) is a fixed point of \\(F\\) (You can simply check and find \\(F(X_N) = X_N\\)). Since \\(X_N \\sqsubseteq Y_N\\) for all \\(N\\), and \\(Y_N\\) converges to the least fixed point of \\(F\\), we conclude that \\(X_N\\) is the least fixed point of \\(F\\).\nConclusively, Algorithm 1 computes the least fixed point of the Round-Robin function \\(F\\).\n\n\nSafety\nSafety. We will state the safety property using abstract interpretation. Let \\(C\\) be the concrete domain of program states, and let \\(\\alpha: C \\to S\\) be the abstraction function mapping concrete states to abstract states in the semilattice \\(S\\). We say that the dataflow analysis is safe if for every program point \\(v\\) and every concrete state \\(c\\) reachable at \\(v\\), the abstract value \\(\\text{OUT}_v\\) computed by the analysis satisfies:\n\\[\n    \\alpha(c) \\sqsubseteq \\text{OUT}_v.\n\\]\nThis means that the abstract value \\(\\text{OUT}_v\\) over-approximates all possible concrete states at that program point, ensuring that no concrete behavior is missed by the analysis.\nSince \\(f_v\\) are designed to be sound abstractions of the concrete semantics, and the join operation \\(\\sqcup\\) combines information from all predecessors, the dataflow analysis framework guarantees that the computed abstract values are safe with respect to the concrete program semantics."
  },
  {
    "objectID": "Blogs/DataflowAnalysis.html#examples-of-dataflow-analyses",
    "href": "Blogs/DataflowAnalysis.html#examples-of-dataflow-analyses",
    "title": "Dataflow Analysis",
    "section": "Examples of Dataflow Analyses",
    "text": "Examples of Dataflow Analyses\n\nSign Analysis\nWe define a lattice of signs: \\[\n  \\text{Sign} = \\{ \\bot, -, 0, +, \\top\\}.\n\\]\nLet \\(\\text{Var}\\) be the set of variables occurring in the given program. The semilattice for sign analysis is defined as: \\[\n    S = \\text{Var} \\to \\text{Sign},\n\\]\nThe abstract interpretation of this lattice is as follows:\n\nThe concrete domain \\(C\\) is \\(\\text{Var} \\to \\mathbb{Z}\\), mapping variables to integer values.\nThe abstraction function \\(\\alpha: C \\to S\\) is defined by: \\[\n  \\alpha(c)(x) = \\begin{cases}\n    - & \\text{if } c(x) &lt; 0 \\\\\n    0 & \\text{if } c(x) = 0 \\\\\n    + & \\text{if } c(x) &gt; 0\n  \\end{cases}\n\\]\nThe concretization function \\(\\gamma: S \\to 2^C\\) is defined by: \\[\n  \\gamma(s) = \\{ c \\in C \\mid \\forall x \\in \\text{Var}, c(x) \\text{ matches } s(x) \\}\n\\]\n\nThe transfer functions: \\[\n  f_v(s) = \\begin{cases}\n   x := e & \\text{update } s \\text{ based on the sign of } e \\\\\n   ...\n  \\end{cases}\n\\]\nThe join operation \\(\\sqcup\\) is defined pointwise: \\[\n    (s_1 \\sqcup s_2)(x) = \\text{join\\_sign}(s_1(x), s_2(x)),\n\\]\n\n\nReaching Definitions Analysis\nFor every program point, we want to determine which definitions may reach that point.\nExample:\n1. a = 100;     // [a -&gt; 1]\n2. if (c &gt; 0)   // [a -&gt; 1]\n3.   a = 200;   // [a -&gt; 3]\n4.   b = a;     // [b -&gt; 4]\n5. return a;    // [a -&gt; {1, 3}, b -&gt; 4]\nThe semilattice for reaching definitions analysis is defined as: \\[\n    S = \\text{Var} \\to 2^{\\text{Def}},\n\\] which is the mapping from variables to the set of definitions that may reach that variable.\nThe initial value for each variable is the empty set: \\[\n    \\bot(x) = \\varnothing,\n\\] and the initial value for the entry node is also the empty set for all variables.\nThe join operation \\(\\sqcup\\) is defined pointwise as the union of sets: \\[\n    (s_1 \\sqcup s_2)(x) = s_1(x) \\cup s_2(x).\n\\]\nThe transfer functions are defined as follows: \\[\n    f_v(s)(x) = (s(x) - \\text{KILL}_v(x)) \\cup \\text{GEN}_v(x),\n\\tag{1}\\]\n\nfor an assignment statement \\(x := e\\) at node \\(v\\):\n\n\\(\\text{KILL}_v(x)\\) is the set of all definitions of \\(x\\) in the program (since the new definition at \\(v\\) kills all previous definitions of \\(x\\)).\n\\(\\text{GEN}_v(x) = \\{ v \\}\\), representing the new definition of \\(x\\) at node \\(v\\).\n\nfor other statements, \\(\\text{KILL}_v(x) = \\varnothing\\) and \\(\\text{GEN}_v(x) = \\varnothing\\) for all variables \\(x\\).\n\nEquation 1 is the standard way to define transfer functions for dataflow analysis.\n\n\nAvailable Expressions Analysis\nFor every program point, we want to determine the expressions that have already been computed and whose values are still available. E.g., \\(a+b\\) is available at a program point if on every path from the entry to that point, \\(a+b\\) has been computed and neither \\(a\\) nor \\(b\\) has been modified since then.\nExample:\n1. a = c + (b + 10); // 1 end: {b + 10, c + (b + 10)}\n2. if (a &gt; b)        // 2 end: {b + 10, c + (b + 10), a &gt; b}\n3.   c = a + 10;     // 3 end: {b + 10, a + 10, a &gt; b}\n4. return a;         // 4 end: {b + 10, a &gt; b}\nThe semilattice for available expressions analysis is \\(2^\\text{Expr}\\), which is the set of all expressions in the program.\nThe initial value for each variable is the set of all expressions, and the initial value for the entry node is the empty set.\nAnd the join operation \\(\\sqcup\\) is defined as the intersection of sets: \\[\n    (s_1 \\sqcup s_2) = s_1 \\cap s_2.\n\\]\nThe transfer functions are defined as follows: \\[\n    f_v(s) = (s - \\text{KILL}_v) \\cup \\text{GEN}_v,\n\\]\n\nfor an assignment statement \\(x := e\\) at node \\(v\\):\n\n\\(\\text{KILL}_v\\) is the set of all expressions that contain the variable \\(x\\) (since assigning to \\(x\\) may change the value of these expressions).\n\\(\\text{GEN}_v = \\{ e \\}\\), representing the expression computed at node \\(v\\).\n\nfor other statements, \\(\\text{KILL}_v = \\varnothing\\) and \\(\\text{GEN}_v =\\) the expression computed at node \\(v\\).\n\n\n\nLiveness Analysis\nWe want to determine, for every program point, which variables may be used in the future before being redefined.\n\nThe semilattice: \\(S = 2^{\\text{Var}}\\).\nHere we must revert the control flow graph (CFG) edges, so that the analysis proceeds backward from the exit to the entry.\nThe initial value for each variable is the empty set, and the initial value for the exit node is also the empty set.\nThe join operation \\(\\sqcup\\) is defined as the union of sets.\nThe transfer functions:\n\n\\(\\text{GEN}_v\\) is the set of variables used in node \\(v\\).\n\\(\\text{KILL}_v\\) is the set of variables defined (or assigned) in node \\(v\\).\n\n\n\n\nVery Busy Expressions Analysis\nFor every program point, we want to determine the expressions that will be computed on every path from that point to the exit, before any of their operands are redefined.\nExample:\n1. if (a &gt; b)  // Here, {b - a, a + b, a &gt; b} are very busy\n2.   x = b - a\n3.   y = x - y + (a + b + b)\n4. else\n5.   y = b - a\n6.   x = x - y + (a + b)\n\nThe semilattice: \\(S = 2^{\\text{Expr}}\\).\nThe analysis proceeds backward from the exit to the entry.\nThe initial value for each variable is the emptyset, and the initial value for the exit node is also the emptyset.\nThe join operation \\(\\sqcup\\) is defined as the intersection of sets.\nThe transfer functions:\n\n\\(\\text{GEN}_v\\) is the set of expressions computed in node \\(v\\).\n\\(\\text{KILL}_v\\) is the set of expressions that contain any variable defined (or assigned) in node \\(v\\).\n\n\n\n\n\nThe Analysis Result of the Example\n\n\n\n\nConstant Propagation Analysis\nFor every program point, we want to determine the variables that have a constant value.\nExample:\nvar x, y, z;\nx = 27;\ny = input;\nz = 2 * x + y;\nif (x &lt; 0) { y = z - 3; } else { y = 12; }\noutput y;\n\nThe semilattice: \\(S = \\text{Var} \\to (\\mathbb{Z} \\cup \\{\\bot, \\top\\})\\). \\(\\bot\\) represents “not a constant” and \\(\\top\\) represents “undefined”.\nThe initial value for each variable is \\(\\bot\\), and the initial value for the entry node is also \\(\\bot\\) for all variables.\nThe join operation \\(\\sqcup\\) is defined as follows: \\[\n  (s_1 \\sqcup s_2)(x) = \\begin{cases}\n    \\bot & \\text{if } s_1(x) = \\bot \\text{ or } s_2(x) = \\bot \\\\\n    c & \\text{if } s_1(x) = s_2(x) = c \\in \\mathbb{Z} \\\\\n    \\bot & \\text{if } s_1(x) \\neq s_2(x) \\\\\n    s_1(x) & \\text{if } s_2(x) = \\top \\\\\n    s_2(x) & \\text{if } s_1(x) = \\top\n  \\end{cases}\n\\]\nThe transfer functions are defined based on the operations in the program, propagating constant values and updating variables accordingly."
  },
  {
    "objectID": "Blogs/ICSE23.html",
    "href": "Blogs/ICSE23.html",
    "title": "Reliability Assurance for Deep Neural Network Architectures Against Numerical Defects",
    "section": "",
    "text": "To assure high reliability against numerical defects, in this paper, we propose the RANUM approach including novel techniques for three reliability assurance tasks: detection of potential numerical defects, confirmation of potential-defect feasibility, and suggestion of defect fixes. To the best of our knowledge, RANUM is the first approach that confirms potential-defect feasibility with failure-exhibiting tests and suggests fixes automatically.\nBut here I will only focus on the detection of potential numerical defects via static analysis."
  },
  {
    "objectID": "Blogs/ICSE23.html#static-analysis-for-potential-defect-detection",
    "href": "Blogs/ICSE23.html#static-analysis-for-potential-defect-detection",
    "title": "Reliability Assurance for Deep Neural Network Architectures Against Numerical Defects",
    "section": "Static Analysis for Potential-Defect Detection",
    "text": "Static Analysis for Potential-Defect Detection\nThe computational graph can be viewed as a Directed Acyclic Graph (DAG): \\(\\mathcal{G} = \\langle\\mathcal{V}, \\mathcal{E} \\rangle\\).\nWe call nodes with zero in-degree as initial nodes, which correspond to input, weight, or constant nodes.\nWe call nodes with positive in-degree as internal nodes, which correspond to concrete operators, such as matrix multiplication (MatMul) and addition (Add).\nWe let \\(\\mathbfit{x}\\) and \\(\\mathbfit{w}\\) denote the concatenation of data from all input nodes and data from all weight nodes, respectively. E.g., in Figure 1, \\(\\mathbfit{x}\\) concatenates data from nodes 1 and 11; and \\(\\mathbfit{w}\\) concatenates data from nodes 2 and 4.\nWe use \\(f_n^{\\textsf{in}}(\\mathbfit{x}; \\mathbfit{w})\\) and \\(f_n^{\\textsf{out}}(\\mathbfit{x}; \\mathbfit{w})\\) to express input and output data of node \\(n\\), respectively, given \\(\\mathbfit{x}\\) and \\(\\mathbfit{w}\\).\ninput_data = tf.placeholder(\"float\", [1, n_features], name='x-input')\ninput_labels = tf.placeholder(\"float\", [1, n_classes], name='y-input')\nself.W_ = tf.Variable(tf.zeros([n_features, n_classes]), name='weights')\nself.b_ = tf.Variable(tf.zeros([n_classes]), name='biases')\nmodel_output = tf.nn.softmax(tf.matmul(input_data, self.W_) + self.b_)\ncost = -tf.reduce_mean(input_labels * tf.log(model_output) +\n                       (1 - input_labels) * tf.log(1 - model_output),\n                       name='cost')\nself.obj_function = tf.reduce_min(tf.abs(model_output), name='obj_function')\n\n\n\n\n\n\nFigure 1: Computational graph encoded by the snippet\n\n\n\nDefinition. For the given computational graph \\(\\mathcal{G} = \\langle\\mathcal{V}, \\mathcal{E} \\rangle\\), if there is a node \\(n_0 \\in \\mathcal{V}\\), such that there exists a valid input and valid weights that can let the input of node \\(n_0\\) fall within the invalid range, we say there is a numerical defect at node \\(n_0\\). Formally, \\(\\exists \\mathbfit{x}_0 \\in \\mathcal{X}_{\\textsf{valid}}, \\mathbfit{w}_0 \\in \\mathcal{W}_{\\textsf{valid}}, f_{n_0}^{\\textsf{in}}(\\mathbfit{x}_0; \\mathbfit{w}_0) \\in \\mathcal{I}_{n_0,\\textsf{invalid}} \\Longrightarrow\\) \\(\\exists\\) numerical defect at node \\(n_0\\).\nFor example, ImageNet Resnet50 models have\n\nvalid input range \\(\\mathcal{X}_{\\textsf{valid}} = [0,1]^{3\\times 224 \\times 224}\\): image pixel intensities are within \\([0,1]\\);\nvalid weight range \\(\\mathcal{W}_{\\textsf{valid}} = [-1,1]^{p}\\): weights of well-trained Resnet50 models are typically within \\([-1,1]\\);\nThe invalid range \\(\\mathcal{I}_{n_0,\\textsf{invalid}}\\): determined by the operator type of node \\(n_0\\). For example, for the Log operator, the invalid range is \\((-\\infty,U_{\\text{min}}]\\), where \\(U_{\\text{min}}\\) is the smallest positive number of a tensor’s data type.\n\n\nDNN Static Analysis Framework with Backward Fine-Grained Node Labeling for Potential-Defect Detection\nA DNN architecture + valid ranges for input and weight nodes \\(\\Rightarrow\\) interval abstractions for possible inputs and outputs of each node.\nFormally, for given valid ranges of inference input and model weights, namely \\(\\mathcal{X}\\) and \\(\\mathcal{W}\\), for each node \\(n \\in \\mathcal{V}\\), our framework computes sound input interval abstraction \\([\\mathbfit{l}_n, \\mathbfit{u}_n] := \\{\\mathbfit{x} : \\mathbfit{l}_n \\leq x \\leq \\mathbfit{u}_n\\}\\) such that \\([\\mathbfit{l}_n,\\mathbfit{u}_n]\\) always captures all possible inputs of the node: \\([\\mathbfit{l}_n,\\mathbfit{u}_n] \\supseteq \\{f_n^{\\textsf{in}}(\\mathbfit{x}, \\mathbfit{w}) : \\mathbfit{x} \\in \\mathcal{X} , \\mathbfit{w} \\in \\mathcal{W}\\}\\). We also compute output interval abstractions similarly.\nThe interval domain with tensor partitioning provides a degree of freedom in terms of the partition granularity, i.e., we can choose the subblock size for each node’s abstraction. When the finest granularity, i.e., elementwise abstraction, is chosen, the abstraction interval is the most concrete. When the coarsest granularity (i.e., one scalar to summarize the node tensor) is chosen, the abstraction saves the most space and computational cost but loses much precision.\nE.g., \\(([−1, 0], [0, 1], [1, 2], [−1, 0])\\):\n\nthe finest granularity, \\([\\mathbfit{l}_n, \\mathbfit{u}_n] = [(−1, 0, 1, −1),(0, 1, 2, 0)]\\).\nthe coarsest granularity, \\([\\mathbfit{l}_n, \\mathbfit{u}_n] = [−1, 2]\\).\n\nUsing the finest instead of the coarsest granularity for some nodes is more beneficial for overall abstraction preciseness.\n\nthe control-flow operators, e.g., Loop\nthe indexing operators, e.g., Slice\nshaping operators, e.g., Reshape"
  },
  {
    "objectID": "Blogs/Ocaml 学习笔记.html",
    "href": "Blogs/Ocaml 学习笔记.html",
    "title": "Ocaml 学习笔记",
    "section": "",
    "text": "OCaml Programming: Correct + Efficient + Beautiful\nThis book is the textbook for CS 3110 Data Structures and Functional Programming at Cornell University.\n现在我的 WSL2 里的环境如下:\n使用下面的命令创建一个新的 Switch:\nYou should now be able to launch utop, the OCaml Universal Toplevel."
  },
  {
    "objectID": "Blogs/Ocaml 学习笔记.html#the-basics-of-ocaml",
    "href": "Blogs/Ocaml 学习笔记.html#the-basics-of-ocaml",
    "title": "Ocaml 学习笔记",
    "section": "The Basics of Ocaml",
    "text": "The Basics of Ocaml\n\nToplevel\n我现在安装了 utop.\n\n\n\nutop 运行示例\n\n\nThe best workflow when using the toplevel with code stored in files is:\n\nEdit the code in the file.\nLoad the code in the toplevel with #use.\nInteractively test the code.\nExit the toplevel. Warning: do not skip this step. #quit;;\n\n\n\nStoring code in files\n现在我们开始在文件里写一些代码: - There is no double semicolon ;; at the end of that line of code. The double semicolon is intended for interactive sessions in the toplevel, so that the toplevel knows you are done entering a piece of code. There’s usually no reason to write it in a .ml file.\n(* hello.ml *)\nlet _ = print_endline \"Hello world!\"\nmkdir hello-world\ncd hello-world\nocamlc -o hello.byte hello.ml\n./hello.byte # Hello world!\n\n\nDune\n\n手工创建一个 Dune Project\n\n创建一个名为 dune 的文件, 里面写上:\n\n(executable\n (name hello))\n\n创建一个名为 dune-project 的文件, 里面写上: (lang dune 3.4)\ndune build hello.exe 来构建\n接下来在 _build/default/hello.exe 处就可以找到构建后的可执行文件\n或者使用 dune exec hello.exe 来执行文件\ndune clean 来清理构建的文件\n\n\n\n自动创建一个 Dune Project\ndune init project calculator\ncd calculator\ncode .\ndune exec bin/main.exe\n\n\n\ndune init 的运行示例\n\n\n在 VSCode 里显示如下:\n\n\n\nDune Project in VSCode\n\n\n可以和 typst watch main.typ 一样, 我们也有: dune build --watch.\n\n\n\nOcaml 里的表达式\n注意:\n\nocaml 里的 * 只能用作整数乘法, 浮点数必须为 *. (这后面有个小数点.)\n字符串的 ^ 表示拼接\n\n\n\n\nOcaml 里的表达式\n\n\nif 表达式, let ... in ... 表达式, assert 表达式, 函数表达式.\n\n\n\nif表达式, let ... in ... 表达式, assert 表达式\n\n\n函数表达式:\n\n普通函数: let f x = ...\n递归函数: let rec f x = ...\nMutually Recursive Function: let rec f x1 ... xn = e1 and g y1 ... ym = e2\n也可以把函数写成: let f = fun x -&gt; ...\n\nOCaml 提供一个 |&gt; 的中缀运算符, 实现管道 (Pipelines) 操作:\nsquare (inc 5);;\n5 |&gt; inc |&gt; square;;\n\n\n\n函数表达式和 Pipeline\n\n\n\nPolymorphic Functions\nidentity function: let id x = x; val id : 'a -&gt; 'a = &lt;fun&gt;.\n\n'a 是一个类型变量\n\n我们可以通过: 提供参数的类型, 提供函数的类型, 提供参数之间的运算 (这样来确定参数类型), 把多态函数确定下来.\n\n\n\nPolymorphic Functions\n\n\n\n\nLabeled and Optional Arguments\nlet f ~name1:arg1 ~name2:arg2 = arg1 + arg2;;\nlet f ~name1:name1 ~name2:name2 = name1 + name2;;\nlet f ~name1 ~name2 = name1 + name2;;\n(* 后面两种是等价的, 标签名和参数变量名一样, 这种情况可以只写标签名. *)\n\nlet f ~name1:(arg1 : int) ~name2:(arg2 : int) = arg1 + arg2\nlet f ?name:(arg1=8) arg2 = arg1 + arg2\n(* ?name代表的是可选参数, 你可以直接使用 f 7, 也可以 f ~name:2 7 *)\n\n\n\nLabeled and Optional Arguments\n\n\n\n\nPartial Application\nlet add x y = x + y\nlet addx x = fun y -&gt; x + y\nlet add5 = addx 5\nadd5 2\n与此同时, ( + ) 也是一个函数, 我们甚至可以自己定义自己的中缀运算符: let ( op ) ... = ...\n\n\n\nPartial Application and Operators as Functions\n\n\n\n\n尾递归 (Tail Recursion)\nlet rec count n =\n  if n = 0 then 0 else 1 + count (n - 1)\n  \nlet rec count_aux n acc =\n  if n = 0 then acc else count_aux (n - 1) (acc + 1)\n\nlet count_tr n = count_aux n 0\n\nA recursive call in tail position does not need a new stack frame. It can just reuse the existing stack frame.\nA good compiler (and the OCaml compiler is good this way) can notice when a recursive call is in tail position, which is a technical way of saying “there’s no more computation to be done after it returns”.\n\n换言之, 返回后就不会有更多的计算了.\n\ncount 在计算完 count (n - 1) 之后还需要计算一次 1 + ...;\n而 count_aux 返回后不必进行计算了.\n\nThe Recipe for Tail Recursion. In a nutshell, here’s how we made a function be tail recursive:\n\nChange the function into a helper function. Add an extra argument: the accumulator, often named acc.\nWrite a new “main” version of the function that calls the helper. It passes the original base case’s return value as the initial value of the accumulator.\nChange the helper function to return the accumulator in the base case.\nChange the helper function’s recursive case. It now needs to do the extra work on the accumulator argument, before the recursive call. This is the only step that requires much ingenuity.\n\n(** [fact n] is [n] factorial. *)\nlet rec fact n =\n  if n = 0 then 1 else n * fact (n - 1)\n  \nlet rec fact_aux n acc =\n  if n = 0 then acc else fact_aux (n - 1) (acc * n)\nlet fact_tr n = fact_aux n 1\n但是这实际上会遇见 integer overflow. \\(\\rightarrow\\) opam install zarith (Ocaml 的大整数库)\n#require \"zarith.top\";;\nlet rec zfact_aux n acc =\n  if Z.equal n Z.zero then acc else zfact_aux (Z.pred n) (Z.mul acc n);;\n\nlet zfact_tr n = zfact_aux n Z.one;;\n\nzfact_tr (Z.of_int 50)\n\n\n\n尾递归和zarith库\n\n\n\n\n\nDocumentation\n(** [sum lst] is the sum of the elements of [lst]. *)\nlet rec sum lst = ...\n\n(** Sum a list.\n    @param lst The list to be summed.\n    @return The sum of the list. *)\nlet rec sum lst = ...\n\n\nPrinting\n\n使用 print_endline 来打印, 多个打印可以使用分号的语法糖.\n可以使用 print_string, print_float, print_newline 等\n可以使用 Printf.printf: %s 代表 string, %F 代表 float.\n\n\n\n\nPrinting\n\n\n\n\nDebugging\n\n使用 print\n#trace 很牛\nocamldebug\n\n\n\n\n使用#trace来debug\n\n\n\n\nExercises\nWrite an expression that computes 4.2 raised to the seventh power.\nlet rec ( ^^ ) x y = if y = 0 then 1. else x *. (( ^^ ) x (y - 1));;\n(* val ( ^^ ) : float -&gt; int -&gt; float = &lt;fun&gt; *)\n4.2 ^^ 7;;\n(* - : float = 23053.9333248000075 *)\n注意: x1 = x2 (Structural Equality) 比较内容相等 (比如两个引用, 可以物理位置不同但是内容相同); x1 == x2(Physical Equality) 表示必须物理上的完全一样. - \"hi\" = \"hi\" 为 true, 而 \"hi\" == \"hi\" 为 false. ### OCaml operator cheatsheet #### Built-in infix operators\n\n\n\n\n\n\n\nOperator\nDescription\n\n\n\n\n=\nStructural equality\n\n\n&lt;&gt;\nStructural inequality\n\n\n&lt;\nLess than\n\n\n&gt;\nGreater than\n\n\n&lt;=\nLess than or equal\n\n\n&gt;=\nGreater than or equal\n\n\n==\nPhysical equality (same object)\n\n\n!=\nPhysical inequality (not same object)\n\n\n&&\nBoolean and\n\n\n||\nBoolean or\n\n\n|&gt;\nReverse function application (x |&gt; f is the same as f x)\n\n\n@@\nFunction application (f @@ x is the same as f x)\n\n\n**\nFloat exponentiation\n\n\n^\nString concatenation\n\n\n@\nList concatenation\n\n\n!\nGet the value of a ref\n\n\n:=\nSet the value of a ref\n\n\n^^\nFormat string concatenation"
  },
  {
    "objectID": "Blogs/Ocaml 学习笔记.html#datas-and-types",
    "href": "Blogs/Ocaml 学习笔记.html#datas-and-types",
    "title": "Ocaml 学习笔记",
    "section": "Datas and Types",
    "text": "Datas and Types\n\nLists\n\n[]: 'a list (注意到: list 是放在类型后面的.)\ne1 :: e2 :: e3 = e1 :: (e2 :: e3)\n[e1; e2; ...; en] = e1 :: e2 :: ... :: en :: []\n\n列表常见的语法:\n\nPattern Matching with Lists\n\nlet rec sum lst =\n  match lst with\n  | [] -&gt; 0\n  | h :: t -&gt; h + sum t\n\nlet rec length lst =\n  match lst with\n  | [] -&gt; 0\n  | h :: t -&gt; 1 + length t\n\nlet rec append lst1 lst2 =\n  match lst1 with\n  | [] -&gt; lst2\n  | h :: t -&gt; h :: append t lst2\n\n\nVariants\ntype day = Sun | Mon | Tue | Wed | Thu | Fri | Sat\nlet d = Tue\n\n\nUnit Testing with OUnit2\n\ndune init project calculator\nlib 文件夹下建立一个 lib.ml, 写入比如一个 let rec sum lst = ...\ntest 的 dune 文件里写入:\n\n(test\n (name test_calculator)\n (libraries ounit2 calculator))\n\ntest 的 test_calculator.ml 文件里写入:\n\nopen OUnit2\nopen Calculator.Lib\n\nlet tests = \"test suite for sum\" &gt;::: [\n  \"empty\" &gt;:: (fun _ -&gt; assert_equal 0 (sum []));\n  \"singleton\" &gt;:: (fun _ -&gt; assert_equal 1 (sum [1]));\n  \"two_elements\" &gt;:: (fun _ -&gt; assert_equal 3 (sum [1; 2]));\n]\n  \nlet _ = run_test_tt_main tests\n\ndune exec test/test_calculator.exe\n\n\n\n\n正确和错误的示例\n\n\n这里的 &gt;:: 和 &gt;::: 都是 Ounit2 自定义的运算符.\n\n\nRecords and Tuples\ntype ptype = TNormal | TFire | TWater\ntype mon = {name : string; hp : int; ptype : ptype}\n{name = \"Charmander\"; hp = 39; ptype = TFire}\n\n\n\nRecords and Tuples\n\n\n\n\nType Synonyms\ntype point = float * float\ntype vector = float list\ntype matrix = float list list\n\n\nOptions\n\nt option is a type for every type t.\n\nlet rec list_max lst =\n  match lst with\n  | [] -&gt; None\n  | h :: t -&gt; match list_max t with\n              | None -&gt; Some h\n              | Some m -&gt; Some (max h m);;\n(* val list_max : 'a list -&gt; 'a option = &lt;fun&gt; *)\nlist_max [1; 2; 3; 4; 10; 0];;\n(* - : int option = Some 10 *)\n\n\n\nOptions\n\n\n\n\nAlgebraic Data Types\ntype point = float * float\ntype shape =\n  | Point of point\n  | Circle of point * float (* center and radius *)\n  | Rect of point * point (* lower-left and upper-right corners *)\nlet area sh =\n  match sh with\n  | Point _ -&gt; 0.0\n  | Circle (_, r) -&gt; Float.pi *. (r ** 2.0)\n  | Rect ((x1, y1), (x2, y2)) -&gt;\n      let w = x2 -. x1 in\n      let h = y2 -. y1 in\n      w *. h\n\nlet center sh =\n  match sh with\n  | Point p -&gt; p\n  | Circle (p, _) -&gt; p\n  | Rect ((x1, y1), (x2, y2)) -&gt; ((x2 +. x1) /. 2.0, (y2 +. y1) /. 2.0)\n还可以实现 Recursive Variants:\ntype intlist = Nil | Cons of int * intlist\ntype 'a mylist = Nil | Cons of 'a * 'a mylist\n\nlet lst3 = Cons (3, Nil)  (* similar to [3] *)\nlet lst_hi = Cons (\"hi\", Nil)  (* similar to [\"hi\"] *)\n\n\nExceptions\nexception E of t\n\n\n\nExceptions"
  },
  {
    "objectID": "Blogs/Ocaml 学习笔记.html#higher-order-functions",
    "href": "Blogs/Ocaml 学习笔记.html#higher-order-functions",
    "title": "Ocaml 学习笔记",
    "section": "Higher-Order Functions",
    "text": "Higher-Order Functions\nlet rec map f = function\n  | [] -&gt; []\n  | h :: t -&gt; f h :: map f t\n\nlet p x = print_int x; print_newline(); x + 1\n\nlet rec map f = function\n  | [] -&gt; []\n  | h :: t -&gt; let h' = f h in h' :: map f t\n\nlet lst2 = map p [1; 2]\n比较两种实现:\n\n第一种实现 evaluates to: p 1 :: (p 2 :: []), 那么 p 2 会先被调用, 然后是 p 1. 打印的顺序是 2 然后是 1.\n第二种实现 evaluates to: let h' = p 1 in h' :: (let h' = p 2 in h' :: []), 那么 p 1 会先被调用, 然后是 p 2. 打印的顺序是 1 然后是 2.\n\nlet rec map_tr_aux f acc = function\n  | [] -&gt; acc\n  | h :: t -&gt; map_tr_aux f (f h :: acc) t\n\nlet map_tr f = map_tr_aux f []\n\nlet lst = map_tr (fun x -&gt; x + 1) [1; 2; 3]\nFilter and Tail Recursion:\nlet rec filter_aux p acc = function\n  | [] -&gt; acc\n  | h :: t -&gt; if p h then filter_aux p (h :: acc) t else filter_aux p acc t\n\nlet filter p = filter_aux p []\n\nlet lst = filter even [1; 2; 3; 4]\nFold left and Fold right:\nval fold_left : ('acc -&gt; 'a -&gt; 'acc) -&gt; 'acc -&gt; 'a list -&gt; 'acc\nfold_left f init [b1; ...; bn] is f (... (f (f init b1) b2) ...) bn\n\nval fold_right : ('a -&gt; 'acc -&gt; 'acc) -&gt; 'a list -&gt; 'acc -&gt; 'acc\nfold_right f [a1; ...; an] init is f a1 (f a2 (... (f an init) ...))"
  },
  {
    "objectID": "Blogs/Ocaml 学习笔记.html#modular-programming",
    "href": "Blogs/Ocaml 学习笔记.html#modular-programming",
    "title": "Ocaml 学习笔记",
    "section": "Modular Programming",
    "text": "Modular Programming\nA structure is simply a collection of definitions, such as:\nstruct\n  let inc x = x + 1\n  type primary_color = Red | Green | Blue\n  exception Oops\nend\nmodule MyModule = struct\n  let inc x = x + 1\n  type primary_color = Red | Green | Blue\n  exception Oops\nend\n会产生下面的结果:\nmodule MyModule :\n  sig\n    val inc : int -&gt; int\n    type primary_color = Red | Green | Blue\n    exception Oops\n  end\n关于一个 module 的类型, 我们称之为一个 module type (或者 signature):\nmodule type LIST_STACK = sig\n  exception Empty\n  val empty : 'a list\n  val is_empty : 'a list -&gt; bool\n  val push : 'a -&gt; 'a list -&gt; 'a list\n  val peek : 'a list -&gt; 'a\n  val pop : 'a list -&gt; 'a list\nend\nmodule type MATH = sig\n  (** [fact n] is [n!]. *)\n  val fact : int -&gt; int\nend\n\nmodule Math : MATH = struct\n  (** [fact_aux n acc] is [n! * acc]. *)\n  let rec fact_aux n acc =\n    if n = 0 then acc else fact_aux (n - 1) (n * acc)\n\n  let fact n = fact_aux n 1\nend\n\n(* Math.fact_aux 就无法访问, 从而 module type 提供了一个隐藏实现细节的功能 *)\nFucntors, 把 module 作为参数传递给另一个 module:\nmodule type STACK = sig\n  exception Empty\n  type 'a stack\n  val empty : 'a stack\n  val is_empty : 'a stack -&gt; bool\n  val push : 'a -&gt; 'a stack -&gt; 'a stack\n  val peek : 'a stack -&gt; 'a\n  val pop : 'a stack -&gt; 'a stack\nend\n\nmodule ListStack : STACK = struct\n  exception Empty\n  type 'a stack = 'a list\n  let empty = []\n  let is_empty s = (s = [])\n  let push x s = x :: s\n  let peek s =\n    match s with\n    | [] -&gt; raise Empty\n    | h :: _ -&gt; h\n  let pop s =\n    match s with\n    | [] -&gt; raise Empty\n    | _ :: t -&gt; t\nend\n\nmodule VariantStack = struct\n  type 'a t = E | S of 'a * 'a t\n  let empty = E\n  let push x s = S (x, s)\n  let peek = function E -&gt; raise Empty | S (x, _) -&gt; x\n  let pop = function E -&gt; raise Empty | S (_, s) -&gt; s\nend\n\n(* Functor 的用处: 为不同的实现写同样的代码 *)\nmodule StackTester (S : Stack) = struct\n  let tests = [\n    \"peek (push x empty) = x\" &gt;:: fun _ -&gt;\n      assert_equal 1 S.(empty |&gt; push 1 |&gt; peek)\n  ]\nend\n\nmodule ListStackTester = StackTester (ListStack)\nmodule VariantStackTester = StackTester (VariantStack)\n\nlet all_tests = List.flatten [\n  ListStackTester.tests;\n  VariantStackTester.tests\n]"
  },
  {
    "objectID": "blogs.html",
    "href": "blogs.html",
    "title": "Blogs",
    "section": "",
    "text": "Here are the blogs where I share my thoughts and notes on various topics."
  },
  {
    "objectID": "blogs.html#llm-for-theorem-proving",
    "href": "blogs.html#llm-for-theorem-proving",
    "title": "Blogs",
    "section": "LLM for Theorem Proving",
    "text": "LLM for Theorem Proving\nCCF软件工程专业委员会首批发布的三个重要难题之一：自动程序定理证明（如何高度自动化地生成程序定理的形式化证明？） One of the three key challenges initially released by the CCF Technical Committee of Software Engineering: Automated Program Theorem Proving (How can formal proofs of program theorems be generated in a highly automated manner?)\n\nSeedProver: (Chen et al. 2025)\n\nLemma-Style Proving: 分解任务, 独立验证, 构建知识库, 组合证明.\nTest-Time Scaling\n\nLight: Proof Sketch → Lean → Error Feedback → Refine\nMedium: Outer Loop for main theorem, Inner Loop for hard lemmas.\nHeavy: Conjecture Proposer (Conjecture Pool) → Light Prover → Lemma Pool → Evaluate → Select High-Quality Lemmas, let Medium Prover prove main theorem again.\n\nIMO 2025: 4/6 problems solved.\n\n\nIn my opinion, some agent techniques can be helpful for theorem proving as well, so I may record some notes of agent papers here:\n\nLive-SWE-Agent: (Xia et al. 2025)\n\nthe first live software agent that can autonomously and continuously evolve itself on-the-fly during runtime\nstarts with the most basic agent scaffold with only access to bash tools\nautonomously evolves its own scaffold implementation\n75.4% in SWE-bench Verified; 45.8% in SWE-Bench Pro. (SOTA in 2025.11)\nQ: What are the tools in Coq/Lean that can help us evolve the proof strategies on-the-fly during proof construction?\n\nthe necessary helper lemmas\nReducing to only necessary hypotheses that imply the goal (Brendel, Sivaraman, and Millstein 2025)"
  },
  {
    "objectID": "blogs.html#formal-methods-in-ai",
    "href": "blogs.html#formal-methods-in-ai",
    "title": "Blogs",
    "section": "Formal Methods in AI",
    "text": "Formal Methods in AI\n\nStatic Analysis for DL Architectures\n\nDEBAR: Detecting numerical bugs in neural network architectures (Zhang et al. 2020)\n\nAffine Relations Abstract Domain.\nTensor Partitioning.\n\nRANUM: Reliability Assurance for Deep Neural Network Architectures Against Numerical Defects (Li et al. 2023)\n\nPotential-Defect Detection via Static Analysis.\nFeasibility Confirmation via Two-Step Test Generation.\nFix Suggestion via Abstract Optimization.\n\n\n\n\nStatic Analysis for DL Models\n\nUse SMT solvers to verify properties of DL models.\nUse integer programming to verify robustness of DL models.\nAbstract interpretation for DL models. (e.g., \\(\\text{AI}^2\\), DeepPoly, etc.)\n\nZonotope abstract domain.\n\n\nSOTA tools:\n\n\\(\\alpha,\\beta\\)-CROWN"
  },
  {
    "objectID": "blogs.html#dafny-blogs",
    "href": "blogs.html#dafny-blogs",
    "title": "Blogs",
    "section": "Dafny Blogs",
    "text": "Dafny Blogs\n\nTwo quantifiers in a specification"
  },
  {
    "objectID": "blogs.html#others",
    "href": "blogs.html#others",
    "title": "Blogs",
    "section": "Others",
    "text": "Others\n\nA brief note about Dataflow Analysis\nThe first Theorem Proving Competition: 第一届定理证明竞赛\nOCaml 学习笔记: OCaml 学习笔记\n如何在 Mogan STEM 中修改字体: 如何在 Mogan STEM 中修改字体"
  },
  {
    "objectID": "Course_Notes/数理逻辑/数理逻辑.html",
    "href": "Course_Notes/数理逻辑/数理逻辑.html",
    "title": "数理逻辑",
    "section": "",
    "text": "形式系统包括两部分: 表述命题的形式语言, 由形式语言表述的公理和推理规则."
  },
  {
    "objectID": "Course_Notes/数理逻辑/数理逻辑.html#命题逻辑",
    "href": "Course_Notes/数理逻辑/数理逻辑.html#命题逻辑",
    "title": "数理逻辑",
    "section": "",
    "text": "形式系统包括两部分: 表述命题的形式语言, 由形式语言表述的公理和推理规则."
  },
  {
    "objectID": "Course_Notes/数理逻辑/数理逻辑.html#一阶谓词演算",
    "href": "Course_Notes/数理逻辑/数理逻辑.html#一阶谓词演算",
    "title": "数理逻辑",
    "section": "2 一阶谓词演算",
    "text": "2 一阶谓词演算\n接下来我们要建立谓词演算的两个形式系统 \\(N_{\\mathcal{L}}\\) 和 \\(P_{\\mathcal{L}}\\), 它们分别对应于命题演算的形式系统 \\(N\\) 和 \\(P\\).\n要讨论形式系统, 就是要讨论:\n\n形式语言\n公理和推理规则\n\n\n2.1 一阶语言\n而谓词演算系统的形式语言即为一阶语言. 它包括:\n\n符号库\n\n非逻辑符号\n\n个体常元符号: \\(c, c_1,c_2,\\ldots\\)\n谓词符号: \\(F^n, G^n, \\ldots\\). \\(n\\) 为谓词符号的元数.\n函数符号: \\(f^n, g^n, \\ldots\\). \\(n\\) 为函数符号的元数.\n\n由一些非逻辑符号作为元素组成的集合通常记为 \\(\\mathcal{L}\\).  一阶语言与符号库指定的非逻辑符号 \\(\\mathcal{L}\\) 有关, 称为 \\(\\mathcal{L}\\) 生成的一阶语言.\n逻辑符号\n\n个体变元符号: \\(x_0, x_1, x_2, \\ldots\\)\n联结词符号: \\(\\neg, \\land, \\lor, \\to, \\leftrightarrow\\)\n量词符号: \\(\\forall, \\exists\\)\n辅助符号: \\(), , , (\\)\n\n\n谓词公式\n\n项: \\(\\mathcal{L}\\) 生成的一阶语言中的“项”归纳定义如下:\n\n个体变元符号和 \\(\\mathcal{L}\\) 中的个体常元符号都是 \\(\\mathcal{L}\\) 的项;\n若 \\(f^n\\) 是 \\(\\mathcal{L}\\) 中的一个 \\(n\\) 元函数符号, 且 \\(t_1, t_2, \\ldots, t_n\\) 都是 \\(\\mathcal{L}\\) 的项, 则 \\(f^n(t_1, t_2, \\ldots, t_n)\\) 也是 \\(\\mathcal{L}\\) 的项;\n\\(\\mathcal{L}\\) 中的每个项都是有限次应用上述两条所定义的构造规则得到的.\n\n公式: \\(\\mathcal{L}\\) 生成的一阶语言中的“公式”归纳定义如下:\n\n(原子公式) 若 \\(F^n\\) 是 \\(\\mathcal{L}\\) 中的一个 \\(n\\) 元谓词符号, 且 \\(t_1, t_2, \\ldots, t_n\\) 都是 \\(\\mathcal{L}\\) 的项, 则 \\(F^n(t_1, t_2, \\ldots, t_n)\\) 是 \\(\\mathcal{L}\\) 的一个公式;\n若 \\(\\alpha\\) 是 \\(\\mathcal{L}\\) 的一个公式, 则 \\(\\neg \\alpha\\) 也是 \\(\\mathcal{L}\\) 的一个公式;\n若 \\(\\alpha\\) 和 \\(\\beta\\) 都是 \\(\\mathcal{L}\\) 的公式, 则 \\((\\alpha \\land \\beta), (\\alpha \\lor \\beta), (\\alpha \\to \\beta), (\\alpha \\leftrightarrow \\beta)\\) 都是 \\(\\mathcal{L}\\) 的公式;\n若 \\(\\alpha\\) 是 \\(\\mathcal{L}\\) 的一个公式, 且 \\(x\\) 是个体变元符号, 则 \\((\\forall x) \\alpha\\) 和 \\((\\exists x) \\alpha\\) 都是 \\(\\mathcal{L}\\) 的公式;\n\\(\\mathcal{L}\\) 中的每个公式都是有限次应用上述四条所定义的构造规则得到的.\n\n\n\n\n\n\n\n\n\nNote辖域\n\n\n\n称公式 \\((\\forall x) \\alpha\\) 中的 \\(\\alpha\\) 为量词 \\((\\forall x)\\) 的辖域; 同理, 公式 \\((\\exists x) \\alpha\\) 中的 \\(\\alpha\\) 也为量词 \\((\\exists x)\\) 的辖域.\n\n\n\n\n\n\n\n\nNote约束出现与自由出现\n\n\n\n变元符号 \\(x\\) 在公式 \\(\\alpha\\) 中的某处出现被称为约束出现, 如果该变元出现在某个量词 \\((\\forall x)\\) 或 \\((\\exists x)\\) 的辖域内, 或者是 \\((\\forall x)\\) 中的 \\(x\\), 或者是 \\((\\exists x)\\) 中的 \\(x\\); 否则称为自由出现.\n\n\n\n\n\n\n\n\nNote约束变元与自由变元\n\n\n\n设个体变元 \\(x\\) 在公式 \\(\\alpha\\) 中所有出现都是约束出现, 则称 \\(x\\) 为 \\(\\alpha\\) 的约束变元; 反之, 若 \\(x\\) 在 \\(\\alpha\\) 中有自由出现, 则称 \\(x\\) 为 \\(\\alpha\\) 的自由变元.\n\n\n\n\n\n\n\n\nNote\\(t\\) 对 \\(x\\) 在 \\(\\alpha\\) 中可代入\n\n\n\n设 \\(\\alpha\\) 是 \\(\\mathcal{L}\\) 中的公式, \\(t\\) 是 \\(\\mathcal{L}\\) 中的项, 且 \\(x\\) 是 \\(\\mathcal{L}\\) 中的个体变元符号. 如果对 \\(t\\) 中每个出现的变元符号 \\(y\\), \\(\\alpha\\) 中每处自由出现的 \\(x\\) 都不在某个量词 \\((\\forall y)\\) 或 \\((\\exists y)\\) 的辖域内, 则称 \\(t\\) 对 \\(x\\) 在 \\(\\alpha\\) 中可代入 或 \\(t\\) 对 \\(x\\) 在 \\(\\alpha\\) 中自由.\nps: 这句话就是说, 把公式 \\(\\alpha\\) 中的 \\(x\\) 全部替换成项 \\(t\\) 后, 不会导致 \\(\\alpha\\) 的真假值改变.\n\n\n\\(\\alpha(x/t)\\) 是将 \\(\\alpha\\) 中的每个自由出现的 \\(x\\) 都替换成项 \\(t\\) 所得到的公式 (不论 \\(t\\) 是否对 \\(x\\) 在 \\(\\alpha\\) 中自由), 这称为 \\(\\alpha\\) 的一个例式.\n简单的性质:\n\n\\(x\\) 对 \\(x\\) 在任一公式 \\(\\alpha\\) 中自由.\n若 \\(x\\) 不在 \\(\\alpha\\) 中自由出现, 则 \\(t\\) 对 \\(x\\) 在 \\(\\alpha\\) 中自由.\n若 \\(t\\) 对 \\(x\\) 在 \\(\\alpha\\) 中自由, 则 \\(\\alpha\\) 与 \\(\\alpha(x/t)\\) 的“可满足性”差别不大.\n\n\n\n\n\n\n\nNote闭公式 (closed formula)\n\n\n\n\n若 \\(\\mathcal{L}\\) 的项 \\(t\\) 中不含任何个体变元符号, 则称 \\(t\\) 为 \\(\\mathcal{L}\\) 的一个闭项;\n若 \\(\\mathcal{L}\\) 的公式 \\(\\alpha\\) 中不含任何自由变元符号, 则称 \\(\\alpha\\) 为 \\(\\mathcal{L}\\) 的一个闭公式.\n\n\n\n\n\n2.2 一阶谓词演算自然推演系统 \\(N_{\\mathcal{L}}\\)\n现在给定了形式语言 (\\(\\mathcal{L}\\) 生成的一阶语言), \\(N_{\\mathcal{L}}\\) 的形式推理为:\n\n形式公理: \\(\\varnothing\\)\n形式规则: 15 条\n\n(1)-(10): 与命题演算自然推演系统 \\(N\\) 的规则相同.\n增加前提率: 若 \\(\\Gamma \\vdash \\alpha\\), 则 \\(\\Gamma, \\beta \\vdash \\alpha\\). \\((+)\\)\n\\(\\forall\\) 消去律: 若 \\(\\Gamma \\vdash \\forall x \\alpha\\), 且 \\(t\\) 对 \\(x\\) 在 \\(\\alpha\\) 中自由, 则 \\(\\Gamma \\vdash \\alpha(x/t)\\). \\((\\forall -)\\)\n\\(\\forall\\) 引入律: 若 \\(\\Gamma \\vdash \\alpha\\), 且 \\(x\\) 不在 \\(\\Gamma\\) 的任何公式中自由出现, 则 \\(\\Gamma \\vdash \\forall x \\alpha\\). \\((\\forall +)\\)\n\\(\\exists\\) 消去律: 若 \\(\\Gamma, \\alpha \\vdash \\beta\\), 且 \\(x\\) 不在 \\(\\Gamma \\cup \\{\\beta\\}\\) 的任何公式中自由出现, 则 \\(\\Gamma, \\exists x \\alpha \\vdash \\beta\\). \\((\\exists -)\\)\n\\(\\exists\\) 引入律: 若 \\(\\Gamma \\vdash \\alpha(x/t)\\), 且 \\(t\\) 对 \\(x\\) 在 \\(\\alpha\\) 中自由, 则 \\(\\Gamma \\vdash \\exists x \\alpha\\). \\((\\exists +)\\)\n\n\n两个特例: \\(\\alpha(x/x)=\\alpha\\), 且 \\(x\\) 对 \\(x\\) 在 \\(\\alpha\\) 中自由.\n\n若 \\(\\Gamma \\vdash \\forall x \\alpha\\), 则 \\(\\Gamma \\vdash \\alpha\\). \\((\\forall -)\\)\n若 \\(\\Gamma \\vdash \\alpha\\), 则 \\(\\Gamma \\vdash \\exists x \\alpha\\). \\((\\exists +)\\)\n\n\n\n\n\n\n\nNote\\(N_{\\mathcal{L}}\\) 的形式证明序列\n\n\n\n若有限序列 \\[\n\\Gamma_1 \\vdash \\alpha_1, \\quad \\Gamma_2 \\vdash \\alpha_2, \\quad \\ldots,  \\quad \\Gamma_n \\vdash \\alpha_n\n\\] 满足:\n\n每个 \\(\\Gamma_i (1 \\leq i \\leq n)\\) 都是 \\(N_{\\mathcal{L}}\\) 的有限公式集;\n每个 \\(\\Gamma_i (1 \\leq i \\leq n)\\) 都是对此序列中它之前的若干 \\(\\Gamma_j \\vdash \\alpha_j (1 \\leq j &lt; i)\\) 应用 \\(N_{\\mathcal{L}}\\) 的形式推理规则得到的.\n\n则称此序列为 \\(N_{\\mathcal{L}}\\) 的一个(形式) 证明序列.\n也称 \\(\\alpha_n\\) 可由 \\(\\Gamma_n\\) 在 \\(N_{\\mathcal{L}}\\) 中形式推出, 记为 \\(\\Gamma_n \\vdash_{N_{\\mathcal{L}}} \\alpha_n\\), 或 \\(\\Gamma_n \\vdash \\alpha_n\\).\n\n\n\\(N\\) 的定理也是 \\(N_{\\mathcal{L}}\\) 的定理.\n\\(N_{\\mathcal{L}}\\) 中的一些可证式子:\n\\[\\begin{aligned}\n&\\begin{cases}\n\\alpha \\to \\forall x \\beta \\vdash\\dashv \\forall x (\\alpha \\to \\beta) \\\\\n\\alpha \\to \\exists x \\beta \\vdash\\dashv \\exists x (\\alpha \\to \\beta) \\\\\n\\end{cases} \\quad \\text{若 } x \\text{ 不在 } \\alpha \\text{ 中自由出现.} \\\\\n\n&\\begin{cases}\n\\forall x \\alpha \\to \\beta \\vdash\\dashv \\exists x (\\alpha \\to \\beta) \\\\\n\\exists x \\alpha \\to \\beta \\vdash\\dashv \\forall x (\\alpha \\to \\beta) \\\\\n\\end{cases} \\quad \\text{若 } x \\text{ 不在 } \\beta \\text{ 中自由出现.} \\\\\n\n&\\begin{cases}\n\\alpha \\land \\forall x \\beta \\vdash\\dashv \\forall x (\\alpha \\land \\beta) \\\\\n\\alpha \\land \\exists x \\beta \\vdash\\dashv \\exists x (\\alpha \\land \\beta) \\\\\n\\alpha \\lor \\forall x \\beta \\vdash\\dashv \\forall x (\\alpha \\lor \\beta) \\\\\n\\alpha \\lor \\exists x \\beta \\vdash\\dashv \\exists x (\\alpha \\lor \\beta) \\\\\n\\end{cases} \\quad \\text{若 } x \\text{ 不在 } \\alpha \\text{ 中自由出现.} \\\\\n\n&\\begin{cases}\n\\neg \\forall x \\alpha \\vdash\\dashv \\exists x \\neg \\alpha \\\\\n\\neg \\exists x \\alpha \\vdash\\dashv \\forall x \\neg \\alpha \\\\\n\\end{cases} \\\\\n\n&\\begin{cases}\n\\forall x \\alpha \\vdash\\dashv \\forall y \\alpha(x/y) \\\\\n\\exists x \\alpha \\vdash\\dashv \\exists y \\alpha(x/y) \\\\\n\\end{cases} \\quad \\text{若 } y \\text{ 不在 } \\alpha \\text{ 中自由出现.}\n\n\\end{aligned}\\]\n\n\n\n\n\n\nNote前束范式\n\n\n\n\\(\\mathcal{L}\\) 的一个公式 \\(\\alpha\\) 如果具有如下形状: \\[\nQ_1 v_1 Q_2 v_2 \\ldots Q_n v_n \\beta\n\\] 其中:\n\n\\(Q_i\\) 为量词 \\(\\forall\\) 或 \\(\\exists\\) (\\(1 \\leq i \\leq n\\));\n\\(v_i\\) 为个体变元符号 (\\(1 \\leq i \\leq n\\));\n\\(\\beta\\) 为不含量词的公式.\n\n则称 \\(\\alpha\\) 为\\(\\mathcal{L}\\) 的一个前束范式.\n\n\n范式定理: 对 \\(\\mathcal{L}\\) 中任一个公式 \\(\\alpha\\), 存在 \\(\\mathcal{L}\\) 的一个前束范式 \\(\\alpha'\\), 使得 \\(\\alpha\\vdash\\dashv\\alpha'\\). 也称此 \\(\\alpha'\\) 为 \\(\\alpha\\) 的一个前束范式.\nProof. 对于 \\(\\alpha\\) 中所含的联结词与量词的个数 \\(d\\) 进行归纳证明.\n\n\n\n\n\n\nNote谓词公式按前束范式的分类\n\n\n\n设 \\(n\\) 是一个非零的自然数.\n\n若前束范式 \\(\\alpha\\) 的量词以全称量词开始, 并且全称量词组与存在量词组有 \\(n-1\\) 次交替, 则称 \\(\\alpha\\) 为\\(\\Pi_n\\) 型前束范式, 简称\\(\\Pi_n\\) 型公式.\n若前束范式 \\(\\alpha\\) 的量词以存在量词开始, 并且存在量词组与全称量词组有 \\(n-1\\) 次交替, 则称 \\(\\alpha\\) 为\\(\\Sigma_n\\) 型前束范式, 简称\\(\\Sigma_n\\) 型公式.\n\n例如: \\(\\forall x_1 \\forall x_2 (F^1(x_1)\\to F^1(x_2))\\) 是 \\(\\Pi_1\\) 型公式; \\(\\exists x_1 \\forall x_2 \\exists x_3 (F^2(x_1,x_2)\\lor F^1(x_3))\\) 是 \\(\\Sigma_3\\) 型公式.\n\n\n\n\n2.3 一阶谓词演算的形式系统 \\(K_{\\mathcal{L}}\\)\n\\(K_{\\mathcal{L}}\\) 与 \\(P\\) 相对应. 给定非逻辑符号集 \\(\\mathcal{L}\\), \\(K_{\\mathcal{L}}\\) 的构成如下:\n\n形式语言: \\(\\mathcal{L}\\) 生成的一阶语言的一个子语言.\n形式推理:\n\n形式公理: 命题演算系统 \\(P\\) 的所有公理 (3 条), 加上下列公理模式:\n\n(K4): \\(\\forall x \\alpha \\to \\alpha(x/t)\\), 其中 \\(t\\) 对 \\(x\\) 在 \\(\\alpha\\) 中自由.\n(K5): \\(\\alpha \\to \\forall x \\alpha\\), 若 \\(x\\) 不在 \\(\\alpha\\) 中自由出现.\n(K6): \\(\\forall x (\\alpha\\to\\beta) \\to (\\forall x \\alpha \\to \\forall x \\beta)\\).\n(K7): 若 \\(\\alpha\\) 是 \\(K_{\\mathcal{L}}\\) 的一个公理, 则 \\(\\forall x \\alpha\\) 也是 \\(K_{\\mathcal{L}}\\) 的一个公理.\n\n形式规则: 与命题演算系统 \\(P\\) 的规则相同, 即 分离规则 (M).\n\n\n\n\n\n\n\n\nNote\\(K_{\\mathcal{L}}\\) 公式的简写\n\n\n\n\n\\(\\alpha \\lor \\beta\\) 为 \\(\\neg \\alpha \\to \\beta\\) 的简写.\n\\(\\alpha \\land \\beta\\) 为 \\(\\neg (\\alpha \\to \\neg \\beta)\\) 的简写.\n\\(\\alpha \\leftrightarrow \\beta\\) 为 \\(\\neg((\\alpha\\to\\beta)\\to\\neg(\\beta\\to\\alpha))\\) 的简写.\n\\(\\exists x \\alpha\\) 为 \\(\\neg \\forall x \\neg \\alpha\\) 的简写."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "VectorPikachu’s Website",
    "section": "",
    "text": "Here is the homepage of VectorPikachu. You can navigate to the About page to learn more about me. You can also check out my Course Notes for various courses I’ve taken in PKU. Blogs are the places where I share my thoughts and notes on various topics.\n\nAbout Me\nCourse Notes\nBlogs\n\nPlease read the following article and start protecting red pandas. These adorable creatures are facing serious threats such as habitat loss, illegal hunting, and climate change. By raising awareness, supporting conservation efforts, and making eco-friendly choices in our daily lives, we can all play a part in ensuring their survival. Every small action counts – let’s protect red pandas before it’s too late!\n\n\n\n被忽视的小熊猫的一生"
  }
]